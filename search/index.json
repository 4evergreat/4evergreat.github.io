[{"content":"本站以接入cusdis评论系统！！！\n","date":"2024-07-05T22:27:20+08:00","image":"https://4evergreat.github.io/cover/R11.jpg","permalink":"https://4evergreat.github.io/2024/annouce-blog-1/","title":"重要通知！ 本站的评论系统已上线"},{"content":"1. 资源文件 下载链接\n文件介绍：\nkity.min.js：核心 svg 渲染库 kityminder.core.min.js：脑图渲染库 mindmap.min.js：来自 @HunterXuan 开发的，用来将 li 结构转换成脑图需要的 json 的文件 kityminder.core.css：核心 svg 渲染库 mindmap.css：脑图渲染库 2. shortcode定制 在/layouts/shortcodes/ 下新建html， 根据脑图的大小样式，共有3个脑图的shortcodes：mind-sm, mind-md, mind-lg (名字可以自定) 分别对应height为400px，800px，1600px的脑图显示范围。\n示范\n创建 mind-sm.html为例，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- 引入思维导图mindmap --\u0026gt; \u0026lt;script src=\u0026#34;https://code.jquery.com/jquery-3.3.1.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;/js/mindmap/kity.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;/js/mindmap/kityminder.core.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- \u0026lt;script src=\u0026#34;/js/mindmap/mindmap.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; --\u0026gt; \u0026lt;script src=\u0026#34;/js/mindmap/mindmap.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;/js/mindmap/mindmap.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;link href=\u0026#34;/js/mindmap/kityminder.core.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;{{ .Get 0 }}\u0026#34; class=\u0026#34;mindmap mindmap-sm\u0026#34;\u0026gt; #这里改 mindmap-sm, mindmap-md, mindmap-lg 对应上述名字 {{- .Inner | markdownify -}} \u0026lt;/div\u0026gt; 3. 测试 1 2 3 4 5 6 7 8 9 10 # 需要加shortcode 将以下这段包起来 {{内容}} 其中内容为 mind-lg、mind-md、mind-sm - 在 Hugo 中使用思维导图 - 前言 - 操作指南 - 准备需要的文件 - 为主题添加 CSS/JS 文件 - 使用方法 {{ /内容}} 在 Hugo 中使用思维导图 前言 操作指南 准备需要的文件 为主题添加 CSS/JS 文件 使用方法 ","date":"2024-07-05T23:29:20+08:00","image":"https://4evergreat.github.io/cover/v2-077442bbd7eefdba06ccd5f6c5106177_r.png","permalink":"https://4evergreat.github.io/2024/hugo-blog-5/","title":"hugo-blog-5hugo支持思维导图"},{"content":"Maven 课程内容 初识Maven Maven概述 Maven模型介绍 Maven仓库介绍 Maven安装与配置 IDEA集成Maven 依赖管理 01. Maven课程介绍 1.1 课程安排 学习完前端Web开发技术后，我们即将开始学习后端Web开发技术。做为一名Java开发工程师，后端Web开发技术是我们学习的重点。\n后端Web开发技术的学习，我们会先学习Java项目的构建工具：Maven\n1.2 初识Maven 1.2.1 什么是Maven Maven是Apache旗下的一个开源项目，是一款用于管理和构建java项目的工具。\n官网：https://maven.apache.org/\nApache 软件基金会，成立于1999年7月，是目前世界上最大的最受欢迎的开源软件基金会，也是一个专门为支持开源项目而生的非盈利性组织。\n开源项目：https://www.apache.org/index.html#projects-list\n1.2.2 Maven的作用 使用Maven能够做什么呢？\n依赖管理 统一项目结构 项目构建 依赖管理：\n方便快捷的管理项目依赖的资源(jar包)，避免版本冲突问题 当使用maven进行项目依赖(jar包)管理，则很方便的可以解决这个问题。 我们只需要在maven项目的pom.xml文件中，添加一段如下图所示的配置即可实现。\n**统一项目结构 : **\n提供标准、统一的项目结构 在项目开发中，当你使用不同的开发工具 (如：Eclipse、Idea)，创建项目工程时：\n若我们创建的是一个maven工程，是可以帮我们自动生成统一、标准的项目目录结构：\n具体的统一结构如下：\n目录说明：\nsrc/main/java: java源代码目录 src/main/resources: 配置文件信息 src/test/java: 测试代码 src/test/resources: 测试配置文件信息 项目构建 :\nmaven提供了标准的、跨平台(Linux、Windows、MacOS) 的自动化项目构建方式 如上图所示我们开发了一套系统，代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。\n综上所述，可以得到一个结论：Maven是一款管理和构建java项目的工具\n02. Maven概述 2.1 Maven介绍 Apache Maven是一个项目管理和构建工具，它基于项目对象模型(Project Object Model , 简称: POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档。\n官网：https://maven.apache.org/\nMaven的作用：\n方便的依赖管理 统一的项目结构 标准的项目构建流程 2.2 Maven模型 项目对象模型 (Project Object Model) 依赖管理模型(Dependency) 构建生命周期/阶段(Build lifecycle \u0026amp; phases) 1). 构建生命周期/阶段(Build lifecycle \u0026amp; phases)\n以上图中紫色框起来的部分，就是用来完成标准化构建流程 。当我们需要编译，Maven提供了一个编译插件供我们使用；当我们需要打包，Maven就提供了一个打包插件供我们使用等。\n2). 项目对象模型 (Project Object Model)\n以上图中紫色框起来的部分属于项目对象模型，就是将我们自己的项目抽象成一个对象模型，有自己专属的坐标，如下图所示是一个Maven项目：\n坐标，就是资源(jar包)的唯一标识，通过坐标可以定位到所需资源(jar包)位置\n3). 依赖管理模型(Dependency)\n以上图中紫色框起来的部分属于依赖管理模型，是使用坐标来描述当前项目依赖哪些第三方jar包\n之前我们项目中需要jar包时，直接就把jar包复制到项目下的lib目录，而现在书写在pom.xml文件中的坐标又是怎么能找到所要的jar包文件的呢？\n答案：Maven仓库\n2.3 Maven仓库 仓库：用于存储资源，管理各种jar包\n仓库的本质就是一个目录(文件夹)，这个目录被用来存储开发中所有依赖(就是jar包)和插件\nMaven仓库分为：\n本地仓库：自己计算机上的一个目录(用来存储jar包) 中央仓库：由Maven团队维护的全球唯一的。仓库地址：https://repo1.maven.org/maven2/ 远程仓库(私服)：一般由公司团队搭建的私有仓库 当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包\n如果有，则在项目直接引用\n如果没有，则去中央仓库中下载对应的jar包到本地仓库\n如果还可以搭建远程仓库(私服)，将来jar包的查找顺序则变为： 本地仓库 \u0026ndash;\u0026gt; 远程仓库\u0026ndash;\u0026gt; 中央仓库\n2.4 Maven安装 认识了Maven后，我们就要开始使用Maven了，那么首先我们要进行Maven的下载与安装。\n2.4.1 下载 下载地址：https://maven.apache.org/download.cgi\n在提供的资料中，已经提供了下载好的安装包。如下：\n2.4.2 安装步骤 Maven安装配置步骤：\n解压安装 配置仓库 配置Maven环境变量 1、解压 apache-maven-3.6.1-bin.zip（解压即安装）\n建议解压到没有中文、特殊字符的路径下。如课程中解压到 E:\\develop 下。\n解压缩后的目录结构如下：\nbin目录 ： 存放的是可执行命令。（mvn 命令重点关注） conf目录 ：存放Maven的配置文件。（settings.xml配置文件后期需要修改） lib目录 ：存放Maven依赖的jar包。（Maven也是使用java开发的，所以它也依赖其他的jar包） 2、配置本地仓库\n2.1、在自己计算机上新一个目录（本地仓库，用来存储jar包）\n2.2、进入到conf目录下修改settings.xml配置文件\n1). 使用超级记事本软件，打开settings.xml文件，定位到53行\n2). 复制标签，粘贴到注释的外面（55行）\n3). 复制之前新建的用来存储jar包的路径，替换掉标签体内容\n3、配置阿里云私服\n由于中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。\n进入到conf目录下修改settings.xml配置文件：\n1). 使用超级记事本软件，打开settings.xml文件，定位到160行左右\n2). 在标签下为其添加子标签，内容如下：\n1 2 3 4 5 6 \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;alimaven\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public/\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt; 注意配置的位置，在 \u0026hellip; 中间添加配置。如下图所示：\n==注: 只可配置一个(另一个要注释!) ，不然两个可能发生冲突，导致jar包无法下载!!!!!!!==\n4、配置环境变量\nMaven环境变量的配置类似于JDK环境变量配置一样\n1). 在系统变量处新建一个变量MAVEN_HOME\nMAVEN_HOME环境变量的值，设置为maven的解压安装目录 2). 在Path中进行配置\nPATH环境变量的值，设置为：%MAVEN_HOME%\\bin 3). 打开DOS命令提示符进行验证，出现如图所示表示安装成功\n1 mvn -v 03. IDEA集成Maven 我们要想在IDEA中使用Maven进行项目构建，就需要在IDEA中集成Maven\n3.1 配置Maven环境 3.1.1 当前工程设置 1、选择 IDEA中 File =\u0026gt; Settings =\u0026gt; Build,Execution,Deployment =\u0026gt; Build Tools =\u0026gt; Maven\n2、设置IDEA使用本地安装的Maven，并修改配置文件及本地仓库路径\nMaven home path ：指定当前Maven的安装目录\nUser settings file ：指定当前Maven的settings.xml配置文件的存放路径\nLocal repository ：指定Maven的本地仓库的路径 (如果指定了settings.xml, 这个目录会自动读取出来, 可以不用手动指定)\n3、配置工程的编译版本为11\nMaven默认使用的编译版本为5（版本过低） 上述配置的maven环境，只是针对于当前工程的，如果我们再创建一个project，又恢复成默认的配置了。 要解决这个问题， 我们就需要配置全局的maven环境。\n3.1.2 全局设置 1、进入到IDEA欢迎页面\n选择 IDEA中 File =\u0026gt; close project 2、打开 All settings , 选择 Build,Execution,Deployment =\u0026gt; Build Tools =\u0026gt; Maven\n3、配置工程的编译版本为11\n这里所设置的maven的环境信息，并未指定任何一个project，此时设置的信息就属于全局配置信息。 以后，我们再创建project，默认就是使用我们全局配置的信息。\n3.2 Maven项目 3.2.1 创建Maven项目 1、创建一个空项目\n2、创建模块，选择Maven，点击Next\n3、填写模块名称，坐标信息，点击finish，创建完成\n4、在Maven工程下，创建HelloWorld类\nMaven项目的目录结构:\nmaven-project01 |\u0026mdash; src (源代码目录和测试代码目录) |\u0026mdash; main (源代码目录) |\u0026mdash; java (源代码java文件目录) |\u0026mdash; resources (源代码配置文件目录) |\u0026mdash; test (测试代码目录) |\u0026mdash; java (测试代码java目录) |\u0026mdash; resources (测试代码配置文件目录) |\u0026mdash; target (编译、打包生成文件存放目录)\n5、编写 HelloWorld，并运行\n1 2 3 4 5 public class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello Maven ...\u0026#34;); } } 3.2.2 POM配置详解 POM (Project Object Model) ：指的是项目对象模型，用来描述当前的maven项目。\n使用pom.xml文件来实现 pom.xml文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;!-- POM模型版本 --\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 当前项目坐标 --\u0026gt; \u0026lt;groupId\u0026gt;com.itheima\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven_project1\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;/project\u0026gt; pom文件详解：\n：pom文件的根标签，表示当前maven项目 ：声明项目描述遵循哪一个POM模型版本 虽然模型本身的版本很少改变，但它仍然是必不可少的。目前POM模型版本是4.0.0 坐标 ：、、 定位项目在本地仓库中的位置，由以上三个标签组成一个坐标 ：maven项目的打包方式，通常设置为jar或war（默认值：jar） 3.2.3 Maven坐标详解 什么是坐标？\nMaven中的坐标是==资源的唯一标识== , 通过该坐标可以唯一定位资源位置 使用坐标来定义项目或引入项目中需要的依赖 Maven坐标主要组成\ngroupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima） artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service） version：定义当前项目版本号 如下图就是使用坐标表示一个项目：\n注意：\n上面所说的资源可以是插件、依赖、当前项目。 我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。 3.3 导入Maven项目 方式1：使用Maven面板，快速导入项目 打开IDEA，选择右侧Maven面板，点击 + 号，选中对应项目的pom.xml文件，双击即可\n说明：如果没有Maven面板，选择 View =\u0026gt; Appearance =\u0026gt; Tool Window Bars\n方式2：使用idea导入模块项目 File =\u0026gt; Project Structure =\u0026gt; Modules =\u0026gt; + =\u0026gt; Import Module\n找到要导入工程的pom.xml\n04. 依赖管理 4.1 依赖配置 依赖：指当前项目运行所需要的jar包。一个项目中可以引入多个依赖：\n例如：在当前工程中，我们需要用到logback来记录日志，此时就可以在maven工程的pom.xml文件中，引入logback的依赖。具体步骤如下：\n在pom.xml中编写标签\n在标签中使用引入坐标\n定义坐标的 groupId、artifactId、version\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;dependencies\u0026gt; \u0026lt;!-- 第1个依赖 : logback --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.11\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 第2个依赖 : junit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 点击刷新按钮，引入最新加入的坐标 刷新依赖：保证每一次引入新的依赖，或者修改现有的依赖配置，都可以加入最新的坐标 注意事项：\n如果引入的依赖，在本地仓库中不存在，将会连接远程仓库 / 中央仓库，然后下载依赖（这个过程会比较耗时，耐心等待） 如果不知道依赖的坐标信息，可以到mvn的中央仓库（https://mvnrepository.com/）中搜索 添加依赖的几种方式：\n利用中央仓库搜索的依赖坐标\n利用IDEA工具搜索依赖\n熟练上手maven后，快速导入依赖\n4.2 依赖传递 4.2.1 依赖具有传递性 早期我们没有使用maven时，向项目中添加依赖的jar包，需要把所有的jar包都复制到项目工程下。如下图所示，需要logback-classic时，由于logback-classic又依赖了logback-core和slf4j，所以必须把这3个jar包全部复制到项目工程下\n我们现在使用了maven，当项目中需要使用logback-classic时，只需要在pom.xml配置文件中，添加logback-classic的依赖坐标即可。\n在pom.xml文件中只添加了logback-classic依赖，但由于maven的依赖具有传递性，所以会自动把所依赖的其他jar包也一起导入。\n依赖传递可以分为：\n直接依赖：在当前项目中通过依赖配置建立的依赖关系\n间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源\n比如以上图中：\nprojectA依赖了projectB。对于projectA 来说，projectB 就是直接依赖。 而projectB依赖了projectC及其他jar包。 那么此时，在projectA中也会将projectC的依赖传递下来。对于projectA 来说，projectC就是间接依赖。 4.2.2 排除依赖 问题：之前我们讲了依赖具有传递性。那么A依赖B，B依赖C，如果A不想将C依赖进来，是否可以做到？\n答案：在maven项目中，我们可以通过排除依赖来实现。\n什么是排除依赖？\n排除依赖：指主动断开依赖的资源。（被排除的资源无需指定版本） 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.itheima\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-projectB\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!--排除依赖, 主动断开依赖的资源--\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 依赖排除示例：\nmaven-projectA依赖了maven-projectB，maven-projectB依赖了Junit。基于依赖的传递性，所以maven-projectA也依赖了Junit 使用排除依赖后 4.3 依赖范围 在项目中导入依赖的jar包后，默认情况下，可以在任何地方使用。\n如果希望限制依赖的使用范围，可以通过标签设置其作用范围。\n作用范围：\n主程序范围有效（main文件夹范围内）\n测试程序范围有效（test文件夹范围内）\n是否参与打包运行（package指令范围内）\n如上图所示，给junit依赖通过scope标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。\nscope标签的取值范围：\nscope值 主程序 测试程序 打包（运行） 范例 compile（默认） Y Y Y log4j test - Y - junit provided Y Y - servlet-api runtime - Y Y jdbc驱动 4.4 生命周期 4.4.1 介绍 Maven的生命周期就是为了对所有的构建过程进行抽象和统一。 描述了一次项目构建，经历哪些阶段。\n在Maven出现之前，项目构建的生命周期就已经存在，软件开发人员每天都在对项目进行清理，编译，测试及部署。虽然大家都在不停地做构建工作，但公司和公司间、项目和项目间，往往使用不同的方式做类似的工作。\nMaven从大量项目和构建工具中学习和反思，然后总结了一套高度完美的，易扩展的项目构建生命周期。这个生命周期包含了项目的清理，初始化，编译，测试，打包，集成测试，验证，部署和站点生成等几乎所有构建步骤。\nMaven对项目构建的生命周期划分为3套（相互独立）：\nclean：清理工作。\ndefault：核心工作。如：编译、测试、打包、安装、部署等。\nsite：生成报告、发布站点等。\n三套生命周期又包含哪些具体的阶段呢, 我们来看下面这幅图:\n我们看到这三套生命周期，里面有很多很多的阶段，这么多生命周期阶段，其实我们常用的并不多，主要关注以下几个：\n• clean：移除上一次构建生成的文件\n• compile：编译项目源代码\n• test：使用合适的单元测试框架运行测试(junit)\n• package：将编译后的文件打包，如：jar、war等\n• install：安装项目到本地仓库\nMaven的生命周期是抽象的，这意味着生命周期本身不做任何实际工作。在Maven的设计中，实际任务（如源代码编译）都交由插件来完成。\nIDEA工具为了方便程序员使用maven生命周期，在右侧的maven工具栏中，已给出快速访问通道\n生命周期的顺序是：clean \u0026ndash;\u0026gt; validate \u0026ndash;\u0026gt; compile \u0026ndash;\u0026gt; test \u0026ndash;\u0026gt; package \u0026ndash;\u0026gt; verify \u0026ndash;\u0026gt; install \u0026ndash;\u0026gt; site \u0026ndash;\u0026gt; deploy\n我们需要关注的就是：clean \u0026ndash;\u0026gt; compile \u0026ndash;\u0026gt; test \u0026ndash;\u0026gt; package \u0026ndash;\u0026gt; install\n说明：在同一套生命周期中，我们在执行后面的生命周期时，前面的生命周期都会执行。\n思考：当运行package生命周期时，clean、compile生命周期会不会运行？\n​\tclean不会运行，compile会运行。 因为compile与package属于同一套生命周期，而clean与package不属于同一套生命周期。\n4.4.2 执行 在日常开发中，当我们要执行指定的生命周期时，有两种执行方式：\n在idea工具右侧的maven工具栏中，选择对应的生命周期，双击执行 在DOS命令行中，通过maven命令执行 方式一：在idea中执行生命周期\n选择对应的生命周期，双击执行 compile：\ntest：\npackage：\ninstall：\nclean：\n方式二：在命令行中执行生命周期\n进入到DOS命令行 05. 附录 5.1 更新依赖索引 有时候给idea配置完maven仓库信息后，在idea中依然搜索不到仓库中的jar包。这是因为仓库中的jar包索引尚未更新到idea中。这个时候我们就需要更新idea中maven的索引了，具体做法如下：\n打开设置\u0026mdash;-搜索maven\u0026mdash;-Repositories\u0026mdash;-选中本地仓库\u0026mdash;\u0026ndash;点击Update\n5.2 清理maven仓库 初始情况下，我们的本地仓库是没有任何jar包的，此时会从私服去下载（如果没有配置，就直接从中央仓库去下载），可能由于网络的原因，jar包下载不完全，这些不完整的jar包都是以lastUpdated结尾。此时，maven不会再重新帮你下载，需要你删除这些以lastUpdated结尾的文件，然后maven才会再次自动下载这些jar包。\n如果本地仓库中有很多这样的以lastUpadted结尾的文件，可以定义一个批处理文件，在其中编写如下脚本来删除：\n1 2 3 4 5 6 7 set REPOSITORY_PATH=E:\\develop\\apache-maven-3.6.1\\mvn_repo rem 正在搜索... del /s /q %REPOSITORY_PATH%\\*.lastUpdated rem 搜索完毕 pause 操作步骤如下：\n1). 定义批处理文件del_lastUpdated.bat (直接创建一个文本文件，命名为del_lastUpdated，后缀名直接改为bat即可 )\n2). 在上面的bat文件上右键\u0026mdash;》编辑 。修改文件：\n修改完毕后，双击运行即可删除maven仓库中的残留文件。\n","date":"2024-07-05T22:27:20+08:00","image":"https://picsum.photos/800/600 ","permalink":"https://4evergreat.github.io/2024/maven-blog-1/","title":"maven初级"},{"content":" Maven高级 Web开发讲解完毕之后，我们再来学习Maven高级。其实在前面的课程当中，我们已经学习了Maven。\n我们讲到 Maven 是一款构建和管理 Java 项目的工具。经过前面 10 多天 web 开发的学习，相信大家对于 Maven 这款工具的基本使用应该没什么问题了。我们掌握了 Maven 工具的基本使用之后，其实对于一些简单的项目的构建及管理基本上就没什么问题了。\n但是如果我们需要开发一些中大型的项目，此时仅凭我们前面所学习的 Maven 的基础知识就比较难以应对了。所以我们接下来还需要学习 Maven 提供的一些高级的功能，这些功能在构建和管理 Java 项目的时候用的也是非常多的。\nMaven高级内容包括:\n分模块设计与开发 继承与聚合 私服 1. 分模块设计与开发 1.1 介绍 所谓分模块设计，顾名思义指的就是我们在设计一个 Java 项目的时候，将一个 Java 项目拆分成多个模块进行开发。\n1). 未分模块设计的问题\n如果项目不分模块，也就意味着所有的业务代码是不是都写在这一个 Java 项目当中。随着这个项目的业务扩张，项目当中的业务功能可能会越来越多。\n假如我们开发的是一个大型的电商项目，里面可能就包括了商品模块的功能、搜索模块的功能、购物车模块、订单模块、用户中心等等。这些所有的业务代码我们都在一个 Java 项目当中编写。\n此时大家可以试想一下，假如我们开发的是一个大型的电商网站，这个项目组至少几十号甚至几百号开发人员，这些开发人员全部操作这一个 Java 项目。此时大家就会发现我们项目管理和维护起来将会非常的困难。而且大家再来看，假如在我们的项目当中，我们自己定义了一些通用的工具类以及通用的组件，而公司还有其他的项目组，其他项目组也想使用我们所封装的这些组件和工具类，其实是非常不方便的。因为 Java 项目当中包含了当前项目的所有业务代码，所以就造成了这里面所封装的一些组件会难以复用。\n总结起来，主要两点问题：不方便项目的维护和管理、项目中的通用组件难以复用。\n2). 分模块设计\n分模块设计我们在进行项目设计阶段，就可以将一个大的项目拆分成若干个模块，每一个模块都是独立的。\n比如我们可以将商品的相关功能放在商品模块当中，搜索的相关业务功能我都封装在搜索模块当中，还有像购物车模块、订单模块。而为了组件的复用，我们也可以将项目当中的实体类、工具类以及我们定义的通用的组件都单独的抽取到一个模块当中。\n如果当前这个模块，比如订单模块需要用到这些实体类以及工具类或者这些通用组件，此时直接在订单模块当中引入工具类的坐标就可以了。这样我们就将一个项目拆分成了若干个模块儿，这就是分模块儿设计。\n分模块儿设计之后，大家再来看。我们在进行项目管理的时候，我就可以几个人一组，几个人来负责订单模块儿，另外几个人来负责购物车模块儿，这样更加便于项目的管理以及项目的后期维护。\n而且分模块设计之后，如果我们需要用到另外一个模块的功能，我们直接依赖模块就可以了。比如商品模块、搜索模块、购物车订单模块都需要依赖于通用组件当中封装的一些工具类，我只需要引入通用组件的坐标就可以了。\n分模块设计就是将项目按照功能/结构拆分成若干个子模块，方便项目的管理维护、拓展，也方便模块键的相互调用、资源共享。\n1.2 实践 1.2.1 分析 好，我们明白了什么是分模块设计以及分模块设计的优势之后，接下来我们就来看一下我们之前所开发的案例工程。\n我们可以看到在这个项目当中，除了我们所开发的部门管理以及员工管理、登录认证等相关业务功能以外，我们是不是也定义了一些实体类，也就是pojo包下存放的一些类，像分页结果的封装类PageBean、 统一响应结果Result，我们还定义了一些通用的工具类，像Jwts、阿里云OSS操作的工具类等等。\n如果在当前公司的其他项目组当中，也想使用我们所封装的这些公共的组件，该怎么办？大家可以思考一下。\n方案一：直接依赖我们当前项目 tlias-web-management ，但是存在两大缺点：\n这个项目当中包含所有的业务功能代码，而想共享的资源，仅仅是pojo下的实体类，以及 utils 下的工具类。如果全部都依赖进来，项目在启动时将会把所有的类都加载进来，会影响性能。 如果直接把这个项目都依赖进来了，那也就意味着我们所有的业务代码都对外公开了，这个是非常不安全的。 方案二：分模块设计\n将pojo包下的实体类，抽取到一个maven模块中 tlias-pojo 将utils包下的工具类，抽取到一个maven模块中 tlias-utils 其他的业务代码，放在tlias-web-management这个模块中，在该模块中需要用到实体类pojo、工具类utils，直接引入对应的依赖即可。 ​\n​\t注意：分模块开发需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。\n​\tPS：当前我们是为了演示分模块开发，所以是基于我们前面开发的案例项目进行拆分的，实际中都是分模块设计，然后再开发的。\n1.2.2 实现 思路我们分析完毕，接下来，我们就根据我们分析的思路，按照如下模块进行拆分：\n1. 创建maven模块 tlias-pojo，存放实体类\nA. 创建一个正常的Maven模块，模块名tlias-pojo\nB. 然后在tlias-pojo中创建一个包 com.itheima.pojo (和原来案例项目中的pojo包名一致)\nC. 将原来案例项目 tlias-web-management 中的pojo包下的实体类，复制到tlias-pojo模块中\nD. 在 tlias-pojo 模块的pom.xml文件中引入依赖\n1 2 3 4 5 6 7 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; E. 删除原有案例项目tlias-web-management的pojo包【直接删除不要犹豫，我们已经将该模块拆分出去了】，然后在pom.xml中引入 tlias-pojo的依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.itheima\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-pojo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2. 创建Maven模块 tlias-utils，存放相关工具类\nA. 创建一个正常的Maven模块，模块名tlias-utils\nB. 然后在 tlias-utils 中创建一个包 com.itheima.utils (和原来案例项目中的utils包名一致)\nC. 将原来案例项目 tlias-web-management 中的utils包下的实体类，复制到tlias-utils模块中\nD. 在 tlias-utils 模块的pom.xml文件中引入依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 \u0026lt;dependencies\u0026gt; \u0026lt;!--JWT令牌--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--阿里云OSS--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-sdk-oss\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.15.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.xml.bind\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.activation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;activation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- no more than 2.3.3--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.glassfish.jaxb\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-runtime\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--WEB开发--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; E. 删除原有案例项目tlias-web-management的utils包【直接删除不要犹豫，我们已经将该模块拆分出去了】，然后在pom.xml中引入 tlias-utils的依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.itheima\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-utils\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 到此呢，就已经完成了模块的拆分，拆分出了 tlias-pojo、tlias-utils、tlias-web-management ，如果其他项目中需要用到 pojo，或者 utils工具类，就可以直接引入依赖。\n1.3 总结 1). 什么是分模块设计：将项目按照功能拆分成若干个子模块\n2). 为什么要分模块设计：方便项目的管理维护、扩展，也方便模块间的相互调用，资源共享\n3). 注意事项：分模块设计需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分\n2. 继承与聚合 在案例项目分模块开发之后啊，我们会看到tlias-pojo、tlias-utils、tlias-web-management中都引入了一个依赖 lombok 的依赖。我们在三个模块中分别配置了一次。\n如果是做一个大型的项目，这三个模块当中重复的依赖可能会很多很多。如果每一个 Maven 模块里面，我们都来单独的配置一次，功能虽然能实现，但是配置是比较繁琐的。\n而接下来我们要讲解的 Maven 的继承用来解决这问题的。\n2.1 继承 我们可以再创建一个父工程 tlias-parent ，然后让上述的三个模块 tlias-pojo、tlias-utils、tlias-web-management 都来继承这个父工程 。 然后再将各个模块中都共有的依赖，都提取到父工程 tlias-parent中进行配置，只要子工程继承了父工程，依赖它也会继承下来，这样就无需在各个子工程中进行配置了。\n概念：继承描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。\n作用：简化依赖配置、统一管理依赖\n实现：\n1 2 3 4 5 6 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;...\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;...\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;...\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;....\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; 这是我们在这里先介绍一下什么是继承以及继承的作用，以及在 maven 当中如何来实现这层继承关系。接下来我们就来创建这样一个 parent 父工程，我们就可以将各个子工程当中共有的这部分依赖统一的定义在父工程 parent 当中，从而来简化子工程的依赖配置。接下来我们来看一下具体的操作步骤。\n我们在这里先介绍一下什么是继承以及继承的作用，以及在 maven 当中如何来实现这层继承关系。接下来我们就来创建这样一个 parent 父工程，我们就可以将各个子工程当中共有的这部分依赖，统一的定义在父工程 parent 当中，从而来简化子工程的依赖配置。\n2.1.1 继承关系 2.1.1.1 思路分析 我们当前的项目 tlias-web-management，还稍微有一点特殊，因为是一个springboot项目，而所有的springboot项目都有一个统一的父工程，就是spring-boot-starter-parent。 与java语言类似，Maven不支持多继承，一个maven项目只能继承一个父工程，如果继承了spring-boot-starter-parent，就没法继承我们自己定义的父工程 tlias-parent了。\n那我们怎么来解决这个问题呢？\n那此时，大家可以想一下，Java虽然不支持多继承，但是可以支持多重继承，比如：A 继承 B， B 继承C。 那在Maven中也是支持多重继承的，所以呢，我们就可以让 我们自己创建的三个模块，都继承tlias-parent，而tlias-parent 再继承 spring-boot-starter-parent，就可以了。 具体结构如下：\n2.1.1.2 实现 1). 创建maven模块 tlias-parent ，该工程为父工程，设置打包方式pom(默认jar)。\n​\t工程结构如下：\n父工程tlias-parent的pom.xml文件配置如下：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.itheima\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; Maven打包方式：\njar：普通模块打包，springboot项目基本都是jar包（内嵌tomcat运行） war：普通web程序打包，需要部署在外部的tomcat服务器中运行 pom：父工程或聚合工程，该模块不写代码，仅进行依赖管理 2). 在子工程的pom.xml文件中，配置继承关系。\n1 2 3 4 5 6 7 8 9 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.itheima\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;../tlias-parent/pom.xml\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;tlias-utils\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; 这里是以 tlias-utils 为例，指定了其父工程。其他的模块，都是相同的配置方式。\n注意：\n在子工程中，配置了继承关系之后，坐标中的groupId是可以省略的，因为会自动继承父工程的 。 relativePath指定父工程的pom文件的相对位置（如果不指定，将从本地仓库/远程仓库查找该工程）。 ../ 代表的上一级目录 3). 在父工程中配置各个工程共有的依赖（子工程会自动继承父工程的依赖）。\n1 2 3 4 5 6 7 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 此时，我们已经将各个子工程中共有的依赖（lombok），都定义在了父工程中，子工程中的这一项依赖，就可以直接删除了。删除之后，我们会看到父工程中配置的依赖 lombok，子工程直接继承下来了。\n工程结构说明：\n我们当前的项目结构为：\n因为我们是项目开发完毕之后，给大家基于现有项目拆分的各个模块，tlias-web-management已经存在了，然后再创建各个模块与父工程，所以父工程与模块之间是平级的。\n而实际项目中，可能还会见到下面的工程结构：\n而在真实的企业开发中，都是先设计好模块之后，再开始创建模块，开发项目。 那此时呢，一般都会先创建父工程 tlias-parent，然后将创建的各个子模块，都放在父工程parent下面。 这样层级结构会更加清晰一些。\n​\nPS：上面两种工程结构，都是可以正常使用的，没有一点问题。 只不过，第二种结构，看起来，父子工程结构更加清晰、更加直观。\n2.1.2 版本锁定 2.1.2.1 场景 如果项目中各个模块中都公共的这部分依赖，我们可以直接定义在父工程中，从而简化子工程的配置。 然而在项目开发中，还有一部分依赖，并不是各个模块都共有的，可能只是其中的一小部分模块中使用到了这个依赖。\n比如：在tlias-web-management、tlias-web-system、tlias-web-report这三个子工程中，都使用到了jwt的依赖。 但是 tlias-pojo、tlias-utils中并不需要这个依赖，那此时，这个依赖，我们不会直接配置在父工程 tlias-parent中，而是哪个模块需要，就在哪个模块中配置。\n而由于是一个项目中的多个模块，那多个模块中，我们要使用的同一个依赖的版本要一致，这样便于项目依赖的统一管理。比如：这个jwt依赖，我们都使用的是 0.9.1 这个版本。\n那假如说，我们项目要升级，要使用到jwt最新版本 0.9.2 中的一个新功能，那此时需要将依赖的版本升级到0.9.2，那此时该怎么做呢 ？\n第一步：去找当前项目中所有的模块的pom.xml配置文件，看哪些模块用到了jwt的依赖。\n第二步：找到这个依赖之后，将其版本version，更换为 0.9.2。\n问题：如果项目拆分的模块比较多，每一次更换版本，我们都得找到这个项目中的每一个模块，一个一个的更改。 很容易就会出现，遗漏掉一个模块，忘记更换版本的情况。\n那我们又该如何来解决这个问题，如何来统一管理各个依赖的版本呢？\n答案：Maven的版本锁定功能。\n2.1.2.2 介绍 在maven中，可以在父工程的pom文件中通过 \u0026lt;dependencyManagement\u0026gt; 来统一管理依赖版本。\n父工程：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!--统一管理依赖版本--\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--JWT令牌--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 子工程：\n1 2 3 4 5 6 7 \u0026lt;dependencies\u0026gt; \u0026lt;!--JWT令牌--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 注意：\n在父工程中所配置的 \u0026lt;dependencyManagement\u0026gt; 只能统一管理依赖版本，并不会将这个依赖直接引入进来。 这点和 \u0026lt;dependencies\u0026gt; 是不同的。\n子工程要使用这个依赖，还是需要引入的，只是此时就无需指定 \u0026lt;version\u0026gt; 版本号了，父工程统一管理。变更依赖版本，只需在父工程中统一变更。\n2.1.2.3 实现 接下来，我们就可以将tlias-utils模块中单独配置的依赖，将其版本统一交给 tlias-parent 进行统一管理。\n具体步骤如下：\n1). tlias-parent 中的配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;!--统一管理依赖版本--\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--JWT令牌--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--阿里云OSS--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-sdk-oss\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.15.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.xml.bind\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.activation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;activation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- no more than 2.3.3--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.glassfish.jaxb\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-runtime\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 2). tlias-utils中的pom.xml配置\n如果依赖的版本已经在父工程进行了统一管理，所以在子工程中就无需再配置依赖的版本了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;dependencies\u0026gt; \u0026lt;!--JWT令牌--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--阿里云OSS--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-sdk-oss\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.xml.bind\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-api\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.activation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;activation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- no more than 2.3.3--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.glassfish.jaxb\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-runtime\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--WEB开发--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 我们之所以，在springboot项目中很多时候，引入依赖坐标，都不需要指定依赖的版本 \u0026lt;version\u0026gt; ，是因为在父工程 spring-boot-starter-parent中已经通过 \u0026lt;dependencyManagement\u0026gt;对依赖的版本进行了统一的管理维护。\n2.1.2.4 属性配置 我们也可以通过自定义属性及属性引用的形式，在父工程中将依赖的版本号进行集中管理维护。 具体语法为：\n1). 自定义属性\n1 2 3 \u0026lt;properties\u0026gt; \u0026lt;lombok.version\u0026gt;1.18.24\u0026lt;/lombok.version\u0026gt; \u0026lt;/properties\u0026gt; 2). 引用属性\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 接下来，我们就可以在父工程中，将所有的版本号，都集中管理维护起来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;11\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;11\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;lombok.version\u0026gt;1.18.24\u0026lt;/lombok.version\u0026gt; \u0026lt;jjwt.version\u0026gt;0.9.1\u0026lt;/jjwt.version\u0026gt; \u0026lt;aliyun.oss.version\u0026gt;3.15.1\u0026lt;/aliyun.oss.version\u0026gt; \u0026lt;jaxb.version\u0026gt;2.3.1\u0026lt;/jaxb.version\u0026gt; \u0026lt;activation.version\u0026gt;1.1.1\u0026lt;/activation.version\u0026gt; \u0026lt;jaxb.runtime.version\u0026gt;2.3.3\u0026lt;/jaxb.runtime.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!--统一管理依赖版本--\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--JWT令牌--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jjwt.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--阿里云OSS--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-sdk-oss\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${aliyun.oss.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.xml.bind\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jaxb.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.activation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;activation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${activation.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- no more than 2.3.3--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.glassfish.jaxb\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-runtime\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jaxb.runtime.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 版本集中管理之后，我们要想修改依赖的版本，就只需要在父工程中自定义属性的位置，修改对应的属性值即可。\n面试题：\u0026lt;dependencyManagement\u0026gt; 与 \u0026lt;dependencies\u0026gt; 的区别是什么?\n\u0026lt;dependencies\u0026gt; 是直接依赖，在父工程配置了依赖，子工程会直接继承下来。 \u0026lt;dependencyManagement\u0026gt; 是统一管理依赖版本，不会直接依赖，还需要在子工程中引入所需依赖(无需指定版本) 2.2 聚合 分模块设计与开发之后啊，我们的项目被拆分为多个模块，而模块之间的关系，可能错综复杂。 那就比如我们当前的案例项目，结构如下（相对还是比较简单的）：\n此时，tlias-web-management 模块的父工程是 tlias-parent，该模块又依赖了tlias-pojo、tlias-utils模块。 那此时，我们要想将 tlias-web-management 模块打包，是比较繁琐的。因为在进行项目打包时，maven会从本地仓库中来查找tlias-parent父工程，以及它所依赖的模块tlias-pojo、tlias-utils，而本地仓库目前是没有这几个依赖的。\n所以，我们再打包tlias-web-management 模块前，需要将 tlias-parent、tlias-pojo、tlias-utils分别执行install生命周期安装到maven的本地仓库，然后再针对于 tlias-web-management 模块执行package进行打包操作。\n那此时，大家试想一下，如果开发一个大型项目，拆分的模块很多，模块之间的依赖关系错综复杂，那此时要进行项目的打包、安装操作，是非常繁琐的。 而我们接下来，要讲解的maven的聚合就是来解决这个问题的，通过maven的聚合就可以轻松实现项目的一键构建（清理、编译、测试、打包、安装等）。\n2.2.1 介绍 **聚合：**将多个模块组织成一个整体，同时进行项目的构建。 **聚合工程：**一个不具有业务功能的“空”工程（有且仅有一个pom文件） 【PS：一般来说，继承关系中的父工程与聚合关系中的聚合工程是同一个】 **作用：**快速构建项目（无需根据依赖关系手动构建，直接在聚合工程上构建即可） 2.2.2 实现 在maven中，我们可以在聚合工程中通过 \u0026lt;moudules\u0026gt; 设置当前聚合工程所包含的子模块的名称。我们可以在 tlias-parent中，添加如下配置，来指定当前聚合工程，需要聚合的模块：\n1 2 3 4 5 6 \u0026lt;!--聚合其他模块--\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;../tlias-pojo\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../tlias-utils\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../tlias-web-management\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; 那此时，我们要进行编译、打包、安装操作，就无需在每一个模块上操作了。只需要在聚合工程上，统一进行操作就可以了。\n**测试：**执行在聚合工程 tlias-parent 中执行 package 打包指令\n那 tlias-parent 中所聚合的其他模块全部都会执行 package 指令，这就是通过聚合实现项目的一键构建（一键清理clean、一键编译compile、一键测试test、一键打包package、一键安装install等）。\n2.3 继承与聚合对比 作用\n聚合用于快速构建项目\n继承用于简化依赖配置、统一管理依赖\n相同点：\n聚合与继承的pom.xml文件打包方式均为pom，通常将两种关系制作到同一个pom文件中\n聚合与继承均属于设计型模块，并无实际的模块内容\n不同点：\n聚合是在聚合工程中配置关系，聚合可以感知到参与聚合的模块有哪些\n继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己\n3. 私服 前面我们在讲解多模块开发的时候，我们讲到我们所拆分的模块是可以在同一个公司各个项目组之间进行资源共享的。这个模块的资源共享，就需要通过我们接下来所讲解的 Maven 的私服来实现。\n首先我们先介绍一下什么是私服，以及它的作用是什么。再来介绍一下我们如何将每位模块打包上传到私服，以及从私服当中来下载。\n3.1 场景 在介绍什么是私服之前，我们先来分析一下同一个公司，两个项目组之间如何基于私服进行资源的共享。\n假设现在有两个团队，A 和 B。 A 开发了一个模块 tlias-utils，模块开发完毕之后，将模块打成jar包，并安装到了A的本地仓库。\n那此时，该公司的B团队开发项目时，要想使用 tlias-utils 中提供的工具类，该怎么办呢？ 对于maven项目来说，是不是在pom.xml文件中引入 tlias-utils的坐标就可以了呢？\n大家可以思考一下，当B团队在maven项目的pom.xml配置文件中引入了依赖的坐标之后，maven是如何查找这个依赖的？ 查找顺序为：\n1). 本地仓库：本地仓库中是没有这个依赖jar包的。\n2). 远程中央仓库：由于该模块时自己公司开发的，远程仓库中也没有这个依赖。\n因为目前tlias-utils这个依赖，还在A的本地仓库中的。 B电脑上的maven项目，是不可能找得到A电脑上maven本地仓库的jar包的。 那此时，大家可能会有一个想法：因为A和B都会连接中央仓库，我们可以将A本地仓库的jar包，直接上传到中央仓库，然后B从中央仓库中下载tlias-utils这个依赖。\n这个想法很美好，但是现实很残酷。这个方案是行不通的，因为中央仓库全球只有一个，不是什么人都可以往中央仓库中来上传jar包的，我们是没有权限操作的。\n那此时，maven的私服就出场了，私服其实就是架设在公司局域网内部的一台服务器，就是一种特殊的远程仓库。\n有了私服之后，各个团队就可以直接来连接私服了。 A 连接上私服之后，他就可以把jar包直接上传到私服当中。我公司自己内部搭建的服务器，我是不是有权限操作呀，把jar包上传到私服之后，我让 B 团队的所有开发人员也连接同一台私服。连接上这一台私服之后，他就会根据坐标的信息，直接从私服当中将对应的jar包下载到自己的本地仓库，这样就可以使用到依赖当中所提供的一些工具类了。这样我们就可以通过私服来完成资源的共享。\n而如果我们在项目中需要使用其他第三方提供的依赖，如果本地仓库没有，也会自动连接私服下载，如果私服没有，私服此时会自动连接中央仓库，去中央仓库中下载依赖，然后将下载的依赖存储在私服仓库及本地仓库中。\n3.2 介绍 **私服：**是一种特殊的远程仓库，它是架设在局域网内的仓库服务，用来代理位于外部的中央仓库，用于解决团队内部的资源共享与资源同步问题。 依赖查找顺序： 本地仓库 私服仓库 中央仓库 **注意事项：**私服在企业项目开发中，一个项目/公司，只需要一台即可（无需我们自己搭建，会使用即可）。 3.3 资源上传与下载 3.3.1 步骤分析 资源上传与下载，我们需要做三步配置，执行一条指令。\n第一步配置：在maven的配置文件中配置访问私服的用户名、密码。\n第二步配置：在maven的配置文件中配置连接私服的地址(url地址)。\n第三步配置：在项目的pom.xml文件中配置上传资源的位置(url地址)。\n配置好了上述三步之后，要上传资源到私服仓库，就执行执行maven生命周期：deploy。\n私服仓库说明：\nRELEASE：存储自己开发的RELEASE发布版本的资源。 SNAPSHOT：存储自己开发的SNAPSHOT发布版本的资源。 Central：存储的是从中央仓库下载下来的依赖。 项目版本说明：\nRELEASE(发布版本)：功能趋于稳定、当前更新停止，可以用于发行的版本，存储在私服中的RELEASE仓库中。 SNAPSHOT(快照版本)：功能不稳定、尚处于开发中的版本，即快照版本，存储在私服的SNAPSHOT仓库中。 3.3.2 具体操作 为了模拟企业开发，这里我准备好了一台服务器（192.168.150.101），私服已经搭建好了，我们可以访问私服测试：http://192.168.150.101:8081\n私服准备好了之后，我们要做如下几步配置：\n1.设置私服的访问用户名/密码（在自己maven安装目录下的conf/settings.xml中的servers中配置）\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;server\u0026gt; \u0026lt;id\u0026gt;maven-releases\u0026lt;/id\u0026gt; \u0026lt;username\u0026gt;admin\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;admin\u0026lt;/password\u0026gt; \u0026lt;/server\u0026gt; \u0026lt;server\u0026gt; \u0026lt;id\u0026gt;maven-snapshots\u0026lt;/id\u0026gt; \u0026lt;username\u0026gt;admin\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;admin\u0026lt;/password\u0026gt; \u0026lt;/server\u0026gt; 2.设置私服依赖下载的仓库组地址（在自己maven安装目录下的conf/settings.xml中的mirrors、profiles中配置）\n1 2 3 4 5 \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;maven-public\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;url\u0026gt;http://192.168.150.101:8081/repository/maven-public/\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;allow-snapshots\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;maven-public\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://192.168.150.101:8081/repository/maven-public/\u0026lt;/url\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;/profile\u0026gt; 3.IDEA的maven工程的pom文件中配置上传（发布）地址(直接在tlias-parent中配置发布地址)\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;distributionManagement\u0026gt; \u0026lt;!-- release版本的发布地址 --\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;maven-releases\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://192.168.150.101:8081/repository/maven-releases/\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;!-- snapshot版本的发布地址 --\u0026gt; \u0026lt;snapshotRepository\u0026gt; \u0026lt;id\u0026gt;maven-snapshots\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://192.168.150.101:8081/repository/maven-snapshots/\u0026lt;/url\u0026gt; \u0026lt;/snapshotRepository\u0026gt; \u0026lt;/distributionManagement\u0026gt; 配置完成之后，我们就可以在tlias-parent中执行deploy生命周期，将项目发布到私服仓库中。\n通过日志，我们可以看到，这几个模块打的jar包确实已经上传到了私服仓库中（由于当前我们的项目是SNAPSHOT版本，所以jar包是上传到了snapshot仓库中）。\n那接下来，我们再来打开私服来看一下：\n我们看到，我们项目中的这几个模块，在私服中都有了。 那接下来，当其他项目组的开发人员在项目中，就可以直接通过依赖的坐标，就可以完成引入对应的依赖，此时本地仓库没有，就会自动从私服仓库中下载。\n备注说明：\n课上演示的时候，为了模拟真实的线上环境，老师使用了一台服务器192.168.150.101，并在服务器上安装了maven的私服。 而这台服务器大家并不能直接访问。\n同学们如果要测试使用私服进行资源的上传和下载。可以参照如下步骤，启动给大家准备的本地私服操作：\n解压： 资料中提供的压缩包 apache-maven-nexus.zip\n进入目录： apache-maven-nexus\\nexus-3.39.0-01\\bin\n启动服务：双击 start.bat\n访问服务：localhost:8081\n私服配置说明：将上述配置私服信息的 192.168.150.101 改为 localhost\n","date":"2024-07-05T22:27:20+08:00","image":"https://picsum.photos/800/600 ","permalink":"https://4evergreat.github.io/2024/maven-blog-2/","title":"maven进阶"},{"content":"1. Mybatis基础操作 学习完mybatis入门后，我们继续学习mybatis基础操作。\n1.1 需求 需求说明：\n根据资料中提供的《tlias智能学习辅助系统》页面原型及需求，完成员工管理的需求开发。 通过分析以上的页面原型和需求，我们确定了功能列表：\n查询\n根据主键ID查询 条件查询 新增\n更新\n删除\n根据主键ID删除 根据主键ID批量删除 1.2 准备 实施前的准备工作：\n准备数据库表 创建一个新的springboot工程，选择引入对应的起步依赖（mybatis、mysql驱动、lombok） application.properties中引入数据库连接信息 创建对应的实体类 Emp（实体类属性采用驼峰命名） 准备Mapper接口 EmpMapper 准备数据库表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 -- 部门管理 create table dept ( id int unsigned primary key auto_increment comment \u0026#39;主键ID\u0026#39;, name varchar(10) not null unique comment \u0026#39;部门名称\u0026#39;, create_time datetime not null comment \u0026#39;创建时间\u0026#39;, update_time datetime not null comment \u0026#39;修改时间\u0026#39; ) comment \u0026#39;部门表\u0026#39;; -- 部门表测试数据 insert into dept (id, name, create_time, update_time) values (1, \u0026#39;学工部\u0026#39;, now(), now()), (2, \u0026#39;教研部\u0026#39;, now(), now()), (3, \u0026#39;咨询部\u0026#39;, now(), now()), (4, \u0026#39;就业部\u0026#39;, now(), now()), (5, \u0026#39;人事部\u0026#39;, now(), now()); -- 员工管理 create table emp ( id int unsigned primary key auto_increment comment \u0026#39;ID\u0026#39;, username varchar(20) not null unique comment \u0026#39;用户名\u0026#39;, password varchar(32) default \u0026#39;123456\u0026#39; comment \u0026#39;密码\u0026#39;, name varchar(10) not null comment \u0026#39;姓名\u0026#39;, gender tinyint unsigned not null comment \u0026#39;性别, 说明: 1 男, 2 女\u0026#39;, image varchar(300) comment \u0026#39;图像\u0026#39;, job tinyint unsigned comment \u0026#39;职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管, 5 咨询师\u0026#39;, entrydate date comment \u0026#39;入职时间\u0026#39;, dept_id int unsigned comment \u0026#39;部门ID\u0026#39;, create_time datetime not null comment \u0026#39;创建时间\u0026#39;, update_time datetime not null comment \u0026#39;修改时间\u0026#39; ) comment \u0026#39;员工表\u0026#39;; -- 员工表测试数据 INSERT INTO emp (id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time) VALUES (1, \u0026#39;jinyong\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;金庸\u0026#39;, 1, \u0026#39;1.jpg\u0026#39;, 4, \u0026#39;2000-01-01\u0026#39;, 2, now(), now()), (2, \u0026#39;zhangwuji\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;张无忌\u0026#39;, 1, \u0026#39;2.jpg\u0026#39;, 2, \u0026#39;2015-01-01\u0026#39;, 2, now(), now()), (3, \u0026#39;yangxiao\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;杨逍\u0026#39;, 1, \u0026#39;3.jpg\u0026#39;, 2, \u0026#39;2008-05-01\u0026#39;, 2, now(), now()), (4, \u0026#39;weiyixiao\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;韦一笑\u0026#39;, 1, \u0026#39;4.jpg\u0026#39;, 2, \u0026#39;2007-01-01\u0026#39;, 2, now(), now()), (5, \u0026#39;changyuchun\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;常遇春\u0026#39;, 1, \u0026#39;5.jpg\u0026#39;, 2, \u0026#39;2012-12-05\u0026#39;, 2, now(), now()), (6, \u0026#39;xiaozhao\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;小昭\u0026#39;, 2, \u0026#39;6.jpg\u0026#39;, 3, \u0026#39;2013-09-05\u0026#39;, 1, now(), now()), (7, \u0026#39;jixiaofu\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;纪晓芙\u0026#39;, 2, \u0026#39;7.jpg\u0026#39;, 1, \u0026#39;2005-08-01\u0026#39;, 1, now(), now()), (8, \u0026#39;zhouzhiruo\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;周芷若\u0026#39;, 2, \u0026#39;8.jpg\u0026#39;, 1, \u0026#39;2014-11-09\u0026#39;, 1, now(), now()), (9, \u0026#39;dingminjun\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;丁敏君\u0026#39;, 2, \u0026#39;9.jpg\u0026#39;, 1, \u0026#39;2011-03-11\u0026#39;, 1, now(), now()), (10, \u0026#39;zhaomin\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;赵敏\u0026#39;, 2, \u0026#39;10.jpg\u0026#39;, 1, \u0026#39;2013-09-05\u0026#39;, 1, now(), now()), (11, \u0026#39;luzhangke\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;鹿杖客\u0026#39;, 1, \u0026#39;11.jpg\u0026#39;, 5, \u0026#39;2007-02-01\u0026#39;, 3, now(), now()), (12, \u0026#39;hebiweng\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;鹤笔翁\u0026#39;, 1, \u0026#39;12.jpg\u0026#39;, 5, \u0026#39;2008-08-18\u0026#39;, 3, now(), now()), (13, \u0026#39;fangdongbai\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;方东白\u0026#39;, 1, \u0026#39;13.jpg\u0026#39;, 5, \u0026#39;2012-11-01\u0026#39;, 3, now(), now()), (14, \u0026#39;zhangsanfeng\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;张三丰\u0026#39;, 1, \u0026#39;14.jpg\u0026#39;, 2, \u0026#39;2002-08-01\u0026#39;, 2, now(), now()), (15, \u0026#39;yulianzhou\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;俞莲舟\u0026#39;, 1, \u0026#39;15.jpg\u0026#39;, 2, \u0026#39;2011-05-01\u0026#39;, 2, now(), now()), (16, \u0026#39;songyuanqiao\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;宋远桥\u0026#39;, 1, \u0026#39;16.jpg\u0026#39;, 2, \u0026#39;2010-01-01\u0026#39;, 2, now(), now()), (17, \u0026#39;chenyouliang\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;陈友谅\u0026#39;, 1, \u0026#39;17.jpg\u0026#39;, NULL, \u0026#39;2015-03-21\u0026#39;, NULL, now(), now()); 创建一个新的springboot工程，选择引入对应的起步依赖（mybatis、mysql驱动、lombok）\napplication.properties中引入数据库连接信息\n提示：可以把之前项目中已有的配置信息复制过来即可\n1 2 3 4 5 6 7 8 #驱动类名称 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver #数据库连接的url spring.datasource.url=jdbc:mysql://localhost:3306/mybatis #连接数据库的用户名 spring.datasource.username=root #连接数据库的密码 spring.datasource.password=1234 创建对应的实体类Emp（实体类属性采用驼峰命名）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Data @NoArgsConstructor @AllArgsConstructor public class Emp { private Integer id; private String username; private String password; private String name; private Short gender; private String image; private Short job; private LocalDate entrydate; //LocalDate类型对应数据表中的date类型 private Integer deptId; private LocalDateTime createTime;//LocalDateTime类型对应数据表中的datetime类型 private LocalDateTime updateTime; } 准备Mapper接口：EmpMapper\n1 2 3 4 5 6 7 /*@Mapper注解：表示当前接口为mybatis中的Mapper接口 程序运行时会自动创建接口的实现类对象(代理对象)，并交给Spring的IOC容器管理 */ @Mapper public interface EmpMapper { } 完成以上操作后，项目工程结构目录如下：\n1.3 删除 1.3.1 功能实现 页面原型：\n当我们点击后面的\u0026quot;删除\u0026quot;按钮时，前端页面会给服务端传递一个参数，也就是该行数据的ID。 我们接收到ID后，根据ID删除数据即可。\n功能：根据主键删除数据\nSQL语句 1 2 -- 删除id=17的数据 delete from emp where id = 17; Mybatis框架让程序员更关注于SQL语句\n接口方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Mapper public interface EmpMapper { //@Delete(\u0026#34;delete from emp where id = 17\u0026#34;) //public void delete(); //以上delete操作的SQL语句中的id值写成固定的17，就表示只能删除id=17的用户数据 //SQL语句中的id值不能写成固定数值，需要变为动态的数值 //解决方案：在delete方法中添加一个参数(用户id)，将方法中的参数，传给SQL语句 /** * 根据id删除数据 * @param id 用户id */ @Delete(\u0026#34;delete from emp where id = #{id}\u0026#34;)//使用#{key}方式获取方法中的参数值 public void delete(Integer id); } @Delete注解：用于编写delete操作的SQL语句\n如果mapper接口方法形参只有一个普通类型的参数，#{…} 里面的属性名可以随便写，如：#{id}、#{value}。但是建议保持名字一致。\n测试 在单元测试类中通过@Autowired注解注入EmpMapper类型对象 1 2 3 4 5 6 7 8 9 10 11 12 @SpringBootTest class SpringbootMybatisCrudApplicationTests { @Autowired //从Spring的IOC容器中，获取类型是EmpMapper的对象并注入 private EmpMapper empMapper; @Test public void testDel(){ //调用删除方法 empMapper.delete(16); } } 1.3.2 日志输入 在Mybatis当中我们可以借助日志，查看到sql语句的执行、执行传递的参数以及执行结果。具体操作如下：\n打开application.properties文件\n开启mybatis的日志，并指定输出到控制台\n1 2 #指定mybatis输出日志的位置, 输出控制台 mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 开启日志之后，我们再次运行单元测试，可以看到在控制台中，输出了以下的SQL语句信息：\n但是我们发现输出的SQL语句：delete from emp where id = ?，我们输入的参数16并没有在后面拼接，id的值是使用?进行占位。那这种SQL语句我们称为预编译SQL。\n1.3.3 预编译SQL 1.3.3.1 介绍 预编译SQL有两个优势：\n性能更高 更安全(防止SQL注入) 性能更高：预编译SQL，编译一次之后会将编译后的SQL语句缓存起来，后面再次执行这条语句时，不会再次编译。（只是输入的参数不同）\n更安全(防止SQL注入)：将敏感字进行转义，保障SQL的安全性。\n1.3.3.2 SQL注入 SQL注入：是通过操作输入的数据来修改事先定义好的SQL语句，以达到执行代码对服务器进行攻击的方法。\n由于没有对用户输入进行充分检查，而SQL又是拼接而成，在用户输入参数时，在参数中添加一些SQL关键字，达到改变SQL运行结果的目的，也可以完成恶意攻击。\n测试1：使用资料中提供的程序，来验证SQL注入问题\n第1步：进入到DOS\n第2步：执行以下命令，启动程序\n1 2 #启动存在SQL注入的程序 java -jar sql_Injection_demo-0.0.1-SNAPSHOT.jar 第3步：打开浏览器输入http://localhost:9090/login.html\n发现竟然能够登录成功：\n以上操作为什么能够登录成功呢？\n由于没有对用户输入内容进行充分检查，而SQL又是字符串拼接方式而成，在用户输入参数时，在参数中添加一些SQL关键字，达到改变SQL运行结果的目的，从而完成恶意攻击。 用户在页面提交数据的时候人为的添加一些特殊字符，使得sql语句的结构发生了变化，最终可以在没有用户名或者密码的情况下进行登录。\n测试2：使用资料中提供的程序，来验证SQL注入问题\n第1步：进入到DOS\n第2步：执行以下命令，启动程序：\n1 2 #启动解决了SQL注入的程序 java -jar sql_prepared_demo-0.0.1-SNAPSHOT.jar 第3步：打开浏览器输入http://localhost:9090/login.html\n发现无法登录：\n以上操作SQL语句的执行：\n把整个' or '1'='1作为一个完整的参数，赋值给第2个问号（' or '1'='1进行了转义，只当做字符串使用）\n1.3.3.3 参数占位符 在Mybatis中提供的参数占位符有两种：${\u0026hellip;} 、#{\u0026hellip;}\n#{\u0026hellip;}\n执行SQL时，会将#{…}替换为?，生成预编译SQL，会自动设置参数值 使用时机：参数传递，都使用#{…} ${\u0026hellip;}\n拼接SQL。直接将参数拼接在SQL语句中，存在SQL注入问题 使用时机：如果对表名、列表进行动态设置时使用 注意事项：在项目开发中，建议使用#{\u0026hellip;}，生成预编译SQL，防止SQL注入安全。\n1.4 新增 功能：新增员工信息\n1.4.1 基本新增 员工表结构：\nSQL语句：\n1 insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values (\u0026#39;songyuanqiao\u0026#39;,\u0026#39;宋远桥\u0026#39;,1,\u0026#39;1.jpg\u0026#39;,2,\u0026#39;2012-10-09\u0026#39;,2,\u0026#39;2022-10-01 10:00:00\u0026#39;,\u0026#39;2022-10-01 10:00:00\u0026#39;); 接口方法：\n1 2 3 4 5 6 7 @Mapper public interface EmpMapper { @Insert(\u0026#34;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime})\u0026#34;) public void insert(Emp emp); } 说明：#{\u0026hellip;} 里面写的名称是对象的属性名\n测试类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import com.itheima.mapper.EmpMapper; import com.itheima.pojo.Emp; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.time.LocalDate; import java.time.LocalDateTime; @SpringBootTest class SpringbootMybatisCrudApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testInsert(){ //创建员工对象 Emp emp = new Emp(); emp.setUsername(\u0026#34;tom\u0026#34;); emp.setName(\u0026#34;汤姆\u0026#34;); emp.setImage(\u0026#34;1.jpg\u0026#34;); emp.setGender((short)1); emp.setJob((short)1); emp.setEntrydate(LocalDate.of(2000,1,1)); emp.setCreateTime(LocalDateTime.now()); emp.setUpdateTime(LocalDateTime.now()); emp.setDeptId(1); //调用添加方法 empMapper.insert(emp); } } 日志输出：\n1.4.2 主键返回 概念：在数据添加成功后，需要获取插入数据库数据的主键。\n如：添加套餐数据时，还需要维护套餐菜品关系表数据。\n业务场景：在前面讲解到的苍穹外卖菜品与套餐模块的表结构，菜品与套餐是多对多的关系，一个套餐对应多个菜品。既然是多对多的关系，是不是有一张套餐菜品中间表来维护它们之间的关系。\n在添加套餐的时候，我们需要在界面当中来录入套餐的基本信息，还需要来录入套餐与菜品的关联信息。这些信息录入完毕之后，我们一点保存，就需要将套餐的信息以及套餐与菜品的关联信息都需要保存到数据库当中。其实具体的过程包括两步，首先第一步先需要将套餐的基本信息保存了，接下来第二步再来保存套餐与菜品的关联信息。套餐与菜品的关联信息就是往中间表当中来插入数据，来维护它们之间的关系。而中间表当中有两个外键字段，一个是菜品的ID，就是当前菜品的ID，还有一个就是套餐的ID，而这个套餐的 ID 指的就是此次我所添加的套餐的ID，所以我们在第一步保存完套餐的基本信息之后，就需要将套餐的主键值返回来供第二步进行使用。这个时候就需要用到主键返回功能。\n那要如何实现在插入数据之后返回所插入行的主键值呢？\n默认情况下，执行插入操作时，是不会主键值返回的。如果我们想要拿到主键值，需要在Mapper接口中的方法上添加一个Options注解，并在注解中指定属性useGeneratedKeys=true和keyProperty=\u0026ldquo;实体类属性名\u0026rdquo; 主键返回代码实现：\n1 2 3 4 5 6 7 8 9 @Mapper public interface EmpMapper { //会自动将生成的主键值，赋值给emp对象的id属性 @Options(useGeneratedKeys = true,keyProperty = \u0026#34;id\u0026#34;) @Insert(\u0026#34;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime})\u0026#34;) public void insert(Emp emp); } 测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @SpringBootTest class SpringbootMybatisCrudApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testInsert(){ //创建员工对象 Emp emp = new Emp(); emp.setUsername(\u0026#34;jack\u0026#34;); emp.setName(\u0026#34;杰克\u0026#34;); emp.setImage(\u0026#34;1.jpg\u0026#34;); emp.setGender((short)1); emp.setJob((short)1); emp.setEntrydate(LocalDate.of(2000,1,1)); emp.setCreateTime(LocalDateTime.now()); emp.setUpdateTime(LocalDateTime.now()); emp.setDeptId(1); //调用添加方法 empMapper.insert(emp); System.out.println(emp.getDeptId()); } } 1.5 更新 功能：修改员工信息\n点击\u0026quot;编辑\u0026quot;按钮后，会查询所在行记录的员工信息，并把员工信息回显在修改员工的窗体上(下个知识点学习)\n在修改员工的窗体上，可以修改的员工数据：用户名、员工姓名、性别、图像、职位、入职日期、归属部门\n思考：在修改员工数据时，要以什么做为条件呢？\n答案：员工id\nSQL语句：\n1 update emp set username = \u0026#39;linghushaoxia\u0026#39;, name = \u0026#39;令狐少侠\u0026#39;, gender = 1 , image = \u0026#39;1.jpg\u0026#39; , job = 2, entrydate = \u0026#39;2012-01-01\u0026#39;, dept_id = 2, update_time = \u0026#39;2022-10-01 12:12:12\u0026#39; where id = 18; 接口方法：\n1 2 3 4 5 6 7 8 9 10 @Mapper public interface EmpMapper { /** * 根据id修改员工信息 * @param emp */ @Update(\u0026#34;update emp set username=#{username}, name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_id=#{deptId}, update_time=#{updateTime} where id=#{id}\u0026#34;) public void update(Emp emp); } 测试类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @SpringBootTest class SpringbootMybatisCrudApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testUpdate(){ //要修改的员工信息 Emp emp = new Emp(); emp.setId(23); emp.setUsername(\u0026#34;songdaxia\u0026#34;); emp.setPassword(null); emp.setName(\u0026#34;老宋\u0026#34;); emp.setImage(\u0026#34;2.jpg\u0026#34;); emp.setGender((short)1); emp.setJob((short)2); emp.setEntrydate(LocalDate.of(2012,1,1)); emp.setCreateTime(null); emp.setUpdateTime(LocalDateTime.now()); emp.setDeptId(2); //调用方法，修改员工数据 empMapper.update(emp); } } 1.6 查询 1.6.1 根据ID查询 在员工管理的页面中，当我们进行更新数据时，会点击 “编辑” 按钮，然后此时会发送一个请求到服务端，会根据Id查询该员工信息，并将员工数据回显在页面上。\nSQL语句：\n1 select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp; 接口方法：\n1 2 3 4 5 @Mapper public interface EmpMapper { @Select(\u0026#34;select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp where id=#{id}\u0026#34;) public Emp getById(Integer id); } 测试类：\n1 2 3 4 5 6 7 8 9 10 11 @SpringBootTest class SpringbootMybatisCrudApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testGetById(){ Emp emp = empMapper.getById(1); System.out.println(emp); } } 执行结果：\n而在测试的过程中，我们会发现有几个字段(deptId、createTime、updateTime)是没有数据值的\n1.6.2 数据封装 我们看到查询返回的结果中大部分字段是有值的，但是deptId，createTime，updateTime这几个字段是没有值的，而数据库中是有对应的字段值的，这是为什么呢？\n原因如下：\n实体类属性名和数据库表查询返回的字段名一致，mybatis会自动封装。 如果实体类属性名和数据库表查询返回的字段名不一致，不能自动封装。 解决方案：\n起别名 结果映射 开启驼峰命名 起别名：在SQL语句中，对不一样的列名起别名，别名和实体类属性名一样\n1 2 3 4 5 @Select(\u0026#34;select id, username, password, name, gender, image, job, entrydate, \u0026#34; + \u0026#34;dept_id AS deptId, create_time AS createTime, update_time AS updateTime \u0026#34; + \u0026#34;from emp \u0026#34; + \u0026#34;where id=#{id}\u0026#34;) public Emp getById(Integer id); 再次执行测试类：\n手动结果映射：通过 @Results及@Result 进行手动结果映射\n1 2 3 4 5 @Results({@Result(column = \u0026#34;dept_id\u0026#34;, property = \u0026#34;deptId\u0026#34;), @Result(column = \u0026#34;create_time\u0026#34;, property = \u0026#34;createTime\u0026#34;), @Result(column = \u0026#34;update_time\u0026#34;, property = \u0026#34;updateTime\u0026#34;)}) @Select(\u0026#34;select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp where id=#{id}\u0026#34;) public Emp getById(Integer id); @Results源代码：\n1 2 3 4 5 6 7 8 @Documented @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.METHOD}) public @interface Results { String id() default \u0026#34;\u0026#34;; Result[] value() default {}; //Result类型的数组 } @Result源代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Documented @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.METHOD}) @Repeatable(Results.class) public @interface Result { boolean id() default false;//表示当前列是否为主键（true:是主键） String column() default \u0026#34;\u0026#34;;//指定表中字段名 String property() default \u0026#34;\u0026#34;;//指定类中属性名 Class\u0026lt;?\u0026gt; javaType() default void.class; JdbcType jdbcType() default JdbcType.UNDEFINED; Class\u0026lt;? extends TypeHandler\u0026gt; typeHandler() default UnknownTypeHandler.class; One one() default @One; Many many() default @Many; } 开启驼峰命名(推荐)：如果字段名与属性名符合驼峰命名规则，mybatis会自动通过驼峰命名规则映射\n驼峰命名规则： abc_xyz =\u0026gt; abcXyz\n表中字段名：abc_xyz 类中属性名：abcXyz 1 2 # 在application.properties中添加： mybatis.configuration.map-underscore-to-camel-case=true 要使用驼峰命名前提是 实体类的属性 与 数据库表中的字段名严格遵守驼峰命名。\n1.6.3 条件查询 在员工管理的列表页面中，我们需要根据条件查询员工信息，查询条件包括：姓名、性别、入职时间。\n通过页面原型以及需求描述我们要实现的查询：\n姓名：要求支持模糊匹配 性别：要求精确匹配 入职时间：要求进行范围查询 根据最后修改时间进行降序排序 SQL语句：\n1 2 3 4 5 6 select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp where name like \u0026#39;%张%\u0026#39; and gender = 1 and entrydate between \u0026#39;2010-01-01\u0026#39; and \u0026#39;2020-01-01 \u0026#39; order by update_time desc; 接口方法：\n方式一 1 2 3 4 5 6 7 8 9 @Mapper public interface EmpMapper { @Select(\u0026#34;select * from emp \u0026#34; + \u0026#34;where name like \u0026#39;%${name}%\u0026#39; \u0026#34; + \u0026#34;and gender = #{gender} \u0026#34; + \u0026#34;and entrydate between #{begin} and #{end} \u0026#34; + \u0026#34;order by update_time desc\u0026#34;) public List\u0026lt;Emp\u0026gt; list(String name, Short gender, LocalDate begin, LocalDate end); } 以上方式注意事项：\n方法中的形参名和SQL语句中的参数占位符名保持一致\n模糊查询使用${\u0026hellip;}进行字符串拼接，这种方式呢，由于是字符串拼接，并不是预编译的形式，所以效率不高、且存在sql注入风险。\n方式二（解决SQL注入风险） 使用MySQL提供的字符串拼接函数：concat(\u0026rsquo;%\u0026rsquo; , \u0026lsquo;关键字\u0026rsquo; , \u0026lsquo;%\u0026rsquo;) 1 2 3 4 5 6 7 8 9 10 11 @Mapper public interface EmpMapper { @Select(\u0026#34;select * from emp \u0026#34; + \u0026#34;where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) \u0026#34; + \u0026#34;and gender = #{gender} \u0026#34; + \u0026#34;and entrydate between #{begin} and #{end} \u0026#34; + \u0026#34;order by update_time desc\u0026#34;) public List\u0026lt;Emp\u0026gt; list(String name, Short gender, LocalDate begin, LocalDate end); } 执行结果：生成的SQL都是预编译的SQL语句（性能高、安全）\n1.6.4 参数名说明 在上面我们所编写的条件查询功能中，我们需要保证接口中方法的形参名和SQL语句中的参数占位符名相同。\n当方法中的形参名和SQL语句中的占位符参数名不相同时，就会出现以下问题：\n参数名在不同的SpringBoot版本中，处理方案还不同：\n在springBoot的2.x版本（保证参数名一致） springBoot的父工程对compiler编译插件进行了默认的参数parameters配置，使得在编译时，会在生成的字节码文件中保留原方法形参的名称，所以#{…}里面可以直接通过形参名获取对应的值\n在springBoot的1.x版本/单独使用mybatis（使用@Param注解来指定SQL语句中的参数名） 在编译时，生成的字节码文件当中，不会保留Mapper接口中方法的形参名称，而是使用var1、var2、\u0026hellip;这样的形参名字，此时要获取参数值时，就要通过@Param注解来指定SQL语句中的参数名\n2. Mybatis的XML配置文件 Mybatis的开发有两种方式：\n注解 XML 2.1 XML配置文件规范 使用Mybatis的注解方式，主要是来完成一些简单的增删改查功能。如果需要实现复杂的SQL功能，建议使用XML来配置映射语句，也就是将SQL语句写在XML配置文件中。\n在Mybatis中使用XML映射文件方式开发，需要符合一定的规范：\nXML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下（同包同名）\nXML映射文件的namespace属性为Mapper接口全限定名一致\nXML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致。\n\u0026lt;select\u0026gt;标签：就是用于编写select查询语句的。\nresultType属性，指的是查询返回的单条记录所封装的类型。 2.2 XML配置文件实现 第1步：创建XML映射文件\n第2步：编写XML映射文件\nxml映射文件中的dtd约束，直接从mybatis官网复制即可\n1 2 3 4 5 6 7 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/mapper\u0026gt; 配置：XML映射文件的namespace属性为Mapper接口全限定名\n1 2 3 4 5 6 7 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.itheima.mapper.EmpMapper\u0026#34;\u0026gt; \u0026lt;/mapper\u0026gt; 配置：XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.itheima.mapper.EmpMapper\u0026#34;\u0026gt; \u0026lt;!--查询操作--\u0026gt; \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.itheima.pojo.Emp\u0026#34;\u0026gt; select * from emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender = #{gender} and entrydate between #{begin} and #{end} order by update_time desc \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 运行测试类，执行结果：\n2.3 MybatisX的使用 MybatisX是一款基于IDEA的快速开发Mybatis的插件，为效率而生。\nMybatisX的安装：\n可以通过MybatisX快速定位：\nMybatisX的使用在后续学习中会继续分享\n学习了Mybatis中XML配置文件的开发方式了，大家可能会存在一个疑问：到底是使用注解方式开发还是使用XML方式开发？\n官方说明：https://mybatis.net.cn/getting-started.html\n**结论：**使用Mybatis的注解，主要是来完成一些简单的增删改查功能。如果需要实现复杂的SQL功能，建议使用XML来配置映射语句。\n3. Mybatis动态SQL 3.1 什么是动态SQL 在页面原型中，列表上方的条件是动态的，是可以不传递的，也可以只传递其中的1个或者2个或者全部。\n而在我们刚才编写的SQL语句中，我们会看到，我们将三个条件直接写死了。 如果页面只传递了参数姓名name 字段，其他两个字段 性别 和 入职时间没有传递，那么这两个参数的值就是null。\n此时，执行的SQL语句为：\n这个查询结果是不正确的。正确的做法应该是：传递了参数，再组装这个查询条件；如果没有传递参数，就不应该组装这个查询条件。\n比如：如果姓名输入了\u0026quot;张\u0026quot;, 对应的SQL为:\n1 select * from emp where name like \u0026#39;%张%\u0026#39; order by update_time desc; 如果姓名输入了\u0026quot;张\u0026quot;,，性别选择了\u0026quot;男\u0026quot;，则对应的SQL为:\n1 select * from emp where name like \u0026#39;%张%\u0026#39; and gender = 1 order by update_time desc; SQL语句会随着用户的输入或外部条件的变化而变化，我们称为：动态SQL。\n在Mybatis中提供了很多实现动态SQL的标签，我们学习Mybatis中的动态SQL就是掌握这些动态SQL标签。\n3.2 动态SQL-if \u0026lt;if\u0026gt;：用于判断条件是否成立。使用test属性进行条件判断，如果条件为true，则拼接SQL。\n1 2 3 \u0026lt;if test=\u0026#34;条件表达式\u0026#34;\u0026gt; 要拼接的sql语句 \u0026lt;/if\u0026gt; 接下来，我们就通过\u0026lt;if\u0026gt;标签来改造之前条件查询的案例。\n3.2.1 条件查询 示例：把SQL语句改造为动态SQL方式\n原有的SQL语句 1 2 3 4 5 6 7 \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.itheima.pojo.Emp\u0026#34;\u0026gt; select * from emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender = #{gender} and entrydate between #{begin} and #{end} order by update_time desc \u0026lt;/select\u0026gt; 动态SQL语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.itheima.pojo.Emp\u0026#34;\u0026gt; select * from emp where \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt; name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt; and gender = #{gender} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;begin != null and end != null\u0026#34;\u0026gt; and entrydate between #{begin} and #{end} \u0026lt;/if\u0026gt; order by update_time desc \u0026lt;/select\u0026gt; 测试方法：\n1 2 3 4 5 6 7 8 @Test public void testList(){ //性别数据为null、开始时间和结束时间也为null List\u0026lt;Emp\u0026gt; list = empMapper.list(\u0026#34;张\u0026#34;, null, null, null); for(Emp emp : list){ System.out.println(emp); } } 执行的SQL语句：\n下面呢，我们修改测试方法中的代码，再次进行测试，观察执行情况：\n1 2 3 4 5 6 7 8 @Test public void testList(){ //姓名为null List\u0026lt;Emp\u0026gt; list = empMapper.list(null, (short)1, null, null); for(Emp emp : list){ System.out.println(emp); } } 执行结果：\n再次修改测试方法中的代码，再次进行测试：\n1 2 3 4 5 6 7 8 @Test public void testList(){ //传递的数据全部为null List\u0026lt;Emp\u0026gt; list = empMapper.list(null, null, null, null); for(Emp emp : list){ System.out.println(emp); } } 执行的SQL语句：\n以上问题的解决方案：使用\u0026lt;where\u0026gt;标签代替SQL语句中的where关键字\n\u0026lt;where\u0026gt;只会在子元素有内容的情况下才插入where子句，而且会自动去除子句的开头的AND或OR 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.itheima.pojo.Emp\u0026#34;\u0026gt; select * from emp \u0026lt;where\u0026gt; \u0026lt;!-- if做为where标签的子元素 --\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt; and name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt; and gender = #{gender} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;begin != null and end != null\u0026#34;\u0026gt; and entrydate between #{begin} and #{end} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; order by update_time desc \u0026lt;/select\u0026gt; 测试方法：\n1 2 3 4 5 6 7 8 @Test public void testList(){ //只有性别 List\u0026lt;Emp\u0026gt; list = empMapper.list(null, (short)1, null, null); for(Emp emp : list){ System.out.println(emp); } } 执行的SQL语句：\n3.2.2 更新员工 案例：完善更新员工功能，修改为动态更新员工数据信息\n动态更新员工信息，如果更新时传递有值，则更新；如果更新时没有传递值，则不更新 解决方案：动态SQL 修改Mapper接口：\n1 2 3 4 5 6 @Mapper public interface EmpMapper { //删除@Update注解编写的SQL语句 //update操作的SQL语句编写在Mapper映射文件中 public void update(Emp emp); } 修改Mapper映射文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.itheima.mapper.EmpMapper\u0026#34;\u0026gt; \u0026lt;!--更新操作--\u0026gt; \u0026lt;update id=\u0026#34;update\u0026#34;\u0026gt; update emp set \u0026lt;if test=\u0026#34;username != null\u0026#34;\u0026gt; username=#{username}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt; name=#{name}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt; gender=#{gender}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;image != null\u0026#34;\u0026gt; image=#{image}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;job != null\u0026#34;\u0026gt; job=#{job}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;entrydate != null\u0026#34;\u0026gt; entrydate=#{entrydate}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;deptId != null\u0026#34;\u0026gt; dept_id=#{deptId}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;updateTime != null\u0026#34;\u0026gt; update_time=#{updateTime} \u0026lt;/if\u0026gt; where id=#{id} \u0026lt;/update\u0026gt; \u0026lt;/mapper\u0026gt; 测试方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Test public void testUpdate2(){ //要修改的员工信息 Emp emp = new Emp(); emp.setId(20); emp.setUsername(\u0026#34;Tom111\u0026#34;); emp.setName(\u0026#34;汤姆111\u0026#34;); emp.setUpdateTime(LocalDateTime.now()); //调用方法，修改员工数据 empMapper.update(emp); } 执行的SQL语句：\n再次修改测试方法，观察SQL语句执行情况：\n1 2 3 4 5 6 7 8 9 10 @Test public void testUpdate2(){ //要修改的员工信息 Emp emp = new Emp(); emp.setId(20); emp.setUsername(\u0026#34;Tom222\u0026#34;); //调用方法，修改员工数据 empMapper.update(emp); } 执行的SQL语句：\n以上问题的解决方案：使用\u0026lt;set\u0026gt;标签代替SQL语句中的set关键字\n\u0026lt;set\u0026gt;：动态的在SQL语句中插入set关键字，并会删掉额外的逗号。（用于update语句中） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.itheima.mapper.EmpMapper\u0026#34;\u0026gt; \u0026lt;!--更新操作--\u0026gt; \u0026lt;update id=\u0026#34;update\u0026#34;\u0026gt; update emp \u0026lt;!-- 使用set标签，代替update语句中的set关键字 --\u0026gt; \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;username != null\u0026#34;\u0026gt; username=#{username}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt; name=#{name}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt; gender=#{gender}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;image != null\u0026#34;\u0026gt; image=#{image}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;job != null\u0026#34;\u0026gt; job=#{job}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;entrydate != null\u0026#34;\u0026gt; entrydate=#{entrydate}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;deptId != null\u0026#34;\u0026gt; dept_id=#{deptId}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;updateTime != null\u0026#34;\u0026gt; update_time=#{updateTime} \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id=#{id} \u0026lt;/update\u0026gt; \u0026lt;/mapper\u0026gt; 再次执行测试方法，执行的SQL语句：\n小结\n\u0026lt;if\u0026gt;\n用于判断条件是否成立，如果条件为true，则拼接SQL\n形式：\n1 \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt; … \u0026lt;/if\u0026gt; \u0026lt;where\u0026gt;\nwhere元素只会在子元素有内容的情况下才插入where子句，而且会自动去除子句的开头的AND或OR \u0026lt;set\u0026gt;\n动态地在行首插入 SET 关键字，并会删掉额外的逗号。（用在update语句中） 3.3 动态SQL-foreach 案例：员工删除功能（既支持删除单条记录，又支持批量删除）\nSQL语句：\n1 delete from emp where id in (1,2,3); Mapper接口：\n1 2 3 4 5 @Mapper public interface EmpMapper { //批量删除 public void deleteByIds(List\u0026lt;Integer\u0026gt; ids); } XML映射文件：\n使用\u0026lt;foreach\u0026gt;遍历deleteByIds方法中传递的参数ids集合 1 2 3 \u0026lt;foreach collection=\u0026#34;集合名称\u0026#34; item=\u0026#34;集合遍历出来的元素/项\u0026#34; separator=\u0026#34;每一次遍历使用的分隔符\u0026#34; open=\u0026#34;遍历开始前拼接的片段\u0026#34; close=\u0026#34;遍历结束后拼接的片段\u0026#34;\u0026gt; \u0026lt;/foreach\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.itheima.mapper.EmpMapper\u0026#34;\u0026gt; \u0026lt;!--删除操作--\u0026gt; \u0026lt;delete id=\u0026#34;deleteByIds\u0026#34;\u0026gt; delete from emp where id in \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; \u0026lt;/mapper\u0026gt; 执行的SQL语句：\n3.4 动态SQL-sql\u0026amp;include 问题分析：\n在xml映射文件中配置的SQL，有时可能会存在很多重复的片段，此时就会存在很多冗余的代码 我们可以对重复的代码片段进行抽取，将其通过\u0026lt;sql\u0026gt;标签封装到一个SQL片段，然后再通过\u0026lt;include\u0026gt;标签进行引用。\n\u0026lt;sql\u0026gt;：定义可重用的SQL片段\n\u0026lt;include\u0026gt;：通过属性refid，指定包含的SQL片段\nSQL片段： 抽取重复的代码\n1 2 3 \u0026lt;sql id=\u0026#34;commonSelect\u0026#34;\u0026gt; select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp \u0026lt;/sql\u0026gt; 然后通过\u0026lt;include\u0026gt; 标签在原来抽取的地方进行引用。操作如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.itheima.pojo.Emp\u0026#34;\u0026gt; \u0026lt;include refid=\u0026#34;commonSelect\u0026#34;/\u0026gt; \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt; name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt; and gender = #{gender} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;begin != null and end != null\u0026#34;\u0026gt; and entrydate between #{begin} and #{end} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; order by update_time desc \u0026lt;/select\u0026gt; ","date":"2024-07-05T22:27:20+08:00","image":"https://picsum.photos/800/600 ","permalink":"https://4evergreat.github.io/2024/mybatis-blog-1/","title":"mybatis初级1"},{"content":"Mybatis入门 前言 在前面我们学习MySQL数据库时，都是利用图形化客户端工具(如：idea、datagrip)，来操作数据库的。\n在客户端工具中，编写增删改查的SQL语句，发给MySQL数据库管理系统，由数据库管理系统执行SQL语句并返回执行结果。\n增删改操作：返回受影响行数\n查询操作：返回结果集(查询的结果)\n我们做为后端程序开发人员，通常会使用Java程序来完成对数据库的操作。Java程序操作数据库，现在主流的方式是：Mybatis。\n什么是MyBatis?\nMyBatis是一款优秀的 持久层 框架，用于简化JDBC的开发。\nMyBatis本是 Apache的一个开源项目iBatis，2010年这个项目由apache迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。\n官网：https://mybatis.org/mybatis-3/zh/index.html\n在上面我们提到了两个词：一个是持久层，另一个是框架。\n持久层：指的是就是数据访问层(dao)，是用来操作数据库的。 框架：是一个半成品软件，是一套可重用的、通用的、软件基础代码模型。在框架的基础上进行软件开发更加高效、规范、通用、可拓展。 Mybatis课程安排：\nMybatis入门\nMybatis基础增删改查\nMybatis动态SQL\n接下来，我们就通过一个入门程序，让大家快速感受一下通过Mybatis如何来操作数据库。\n1. 快速入门 需求：使用Mybatis查询所有用户数据。\n1.1 入门程序分析 以前我们是在图形化客户端工具中编写SQL查询代码，发送给数据库执行，数据库执行后返回操作结果。\n图形化工具会把数据库执行的查询结果，使用表格的形式展现出来\n现在使用Mybatis操作数据库，就是在Mybatis中编写SQL查询代码，发送给数据库执行，数据库执行后返回结果。\nMybatis会把数据库执行的查询结果，使用实体类封装起来（一行记录对应一个实体类对象）\nMybatis操作数据库的步骤：\n准备工作(创建springboot工程、数据库表user、实体类User)\n引入Mybatis的相关依赖，配置Mybatis(数据库连接信息)\n编写SQL语句(注解/XML)\n1.2 入门程序实现 1.2.1 准备工作 1.2.1.1 创建springboot工程 创建springboot工程，并导入 mybatis的起步依赖、mysql的驱动包。\n项目工程创建完成后，自动在pom.xml文件中，导入Mybatis依赖和MySQL驱动依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!-- 仅供参考：只粘贴了pom.xml中部分内容 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- mybatis起步依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mysql驱动包依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-j\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- spring单元测试 (集成了junit) --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 1.2.1.2 数据准备 创建用户表user，并创建对应的实体类User。\n用户表： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 -- 用户表 create table user( id int unsigned primary key auto_increment comment \u0026#39;ID\u0026#39;, name varchar(100) comment \u0026#39;姓名\u0026#39;, age tinyint unsigned comment \u0026#39;年龄\u0026#39;, gender tinyint unsigned comment \u0026#39;性别, 1:男, 2:女\u0026#39;, phone varchar(11) comment \u0026#39;手机号\u0026#39; ) comment \u0026#39;用户表\u0026#39;; -- 测试数据 insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;白眉鹰王\u0026#39;,55,\u0026#39;1\u0026#39;,\u0026#39;18800000000\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;金毛狮王\u0026#39;,45,\u0026#39;1\u0026#39;,\u0026#39;18800000001\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;青翼蝠王\u0026#39;,38,\u0026#39;1\u0026#39;,\u0026#39;18800000002\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;紫衫龙王\u0026#39;,42,\u0026#39;2\u0026#39;,\u0026#39;18800000003\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;光明左使\u0026#39;,37,\u0026#39;1\u0026#39;,\u0026#39;18800000004\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;光明右使\u0026#39;,48,\u0026#39;1\u0026#39;,\u0026#39;18800000005\u0026#39;); 实体类\n实体类的属性名与表中的字段名一一对应。 1 2 3 4 5 6 7 8 9 public class User { private Integer id; //id（主键） private String name; //姓名 private Short age; //年龄 private Short gender; //性别 private String phone; //手机号 //省略GET, SET方法 } 1.2.2 配置Mybatis 在之前使用图形化客户端工具，连接MySQL数据库时，需要配置：\n连接数据库的四大参数：\nMySQL驱动类 登录名 密码 数据库连接字符串 基于上述分析，在Mybatis中要连接数据库，同样也需要以上4个参数配置。\n在springboot项目中，可以编写application.properties文件，配置数据库连接信息。我们要连接数据库，就需要配置数据库连接的基本信息，包括：driver-class-name、url 、username，password。\n在入门程序中，大家可以直接这么配置，后面会介绍什么是驱动。\napplication.properties:\n1 2 3 4 5 6 7 8 #驱动类名称 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver #数据库连接的url spring.datasource.url=jdbc:mysql://localhost:3306/mybatis #连接数据库的用户名 spring.datasource.username=root #连接数据库的密码 spring.datasource.password=1234 上述的配置，可以直接复制过去，不要敲错了。 全部都是 spring.datasource.xxxx 开头。\n1.2.3 编写SQL语句 在创建出来的springboot工程中，在引导类所在包下，在创建一个包 mapper。在mapper包下创建一个接口 UserMapper ，这是一个持久层接口（Mybatis的持久层接口规范一般都叫 XxxMapper）。\nUserMapper：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import com.itheima.pojo.User; import org.apache.ibatis.annotations.Mapper; import org.apache.ibatis.annotations.Select; import java.util.List; @Mapper public interface UserMapper { //查询所有用户数据 @Select(\u0026#34;select id, name, age, gender, phone from user\u0026#34;) public List\u0026lt;User\u0026gt; list(); } @Mapper注解：表示是mybatis中的Mapper接口\n程序运行时：框架会自动生成接口的实现类对象(代理对象)，并给交Spring的IOC容器管理 @Select注解：代表的就是select查询，用于书写select查询语句\n1.2.4 单元测试 在创建出来的SpringBoot工程中，在src下的test目录下，已经自动帮我们创建好了测试类 ，并且在测试类上已经添加了注解 @SpringBootTest，代表该测试类已经与SpringBoot整合。\n该测试类在运行时，会自动通过引导类加载Spring的环境（IOC容器）。我们要测试那个bean对象，就可以直接通过@Autowired注解直接将其注入进行，然后就可以测试了。\n测试类代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @SpringBootTest public class MybatisQuickstartApplicationTests { @Autowired private UserMapper userMapper; @Test public void testList(){ List\u0026lt;User\u0026gt; userList = userMapper.list(); for (User user : userList) { System.out.println(user); } } } 运行结果：\n1 2 3 4 5 6 User{id=1, name=\u0026#39;白眉鹰王\u0026#39;, age=55, gender=1, phone=\u0026#39;18800000000\u0026#39;} User{id=2, name=\u0026#39;金毛狮王\u0026#39;, age=45, gender=1, phone=\u0026#39;18800000001\u0026#39;} User{id=3, name=\u0026#39;青翼蝠王\u0026#39;, age=38, gender=1, phone=\u0026#39;18800000002\u0026#39;} User{id=4, name=\u0026#39;紫衫龙王\u0026#39;, age=42, gender=2, phone=\u0026#39;18800000003\u0026#39;} User{id=5, name=\u0026#39;光明左使\u0026#39;, age=37, gender=1, phone=\u0026#39;18800000004\u0026#39;} User{id=6, name=\u0026#39;光明右使\u0026#39;, age=48, gender=1, phone=\u0026#39;18800000005\u0026#39;} 1.3 解决SQL警告与提示 默认我们在UserMapper接口上加的@Select注解中编写SQL语句是没有提示的。 如果想让idea给我们提示对应的SQL语句，我们需要在IDEA中配置与MySQL数据库的链接。\n默认我们在UserMapper接口上的@Select注解中编写SQL语句是没有提示的。如果想让idea给出提示，可以做如下配置：\n配置完成之后，发现SQL语句中的关键字有提示了，但还存在不识别表名(列名)的情况：\n产生原因：Idea和数据库没有建立连接，不识别表信息\n解决方案：在Idea中配置MySQL数据库连接\n在配置的时候指定连接那个数据库，如上图所示连接的就是mybatis数据库。\n2. JDBC介绍(了解) 2.1 介绍 通过Mybatis的快速入门，我们明白了，通过Mybatis可以很方便的进行数据库的访问操作。但是大家要明白，其实java语言操作数据库呢，只能通过一种方式：使用sun公司提供的 JDBC 规范。\nMybatis框架，就是对原始的JDBC程序的封装。\n那到底什么是JDBC呢，接下来，我们就来介绍一下。\nJDBC： ( Java DataBase Connectivity )，就是使用Java语言操作关系型数据库的一套API。\n本质：\nsun公司官方定义的一套操作所有关系型数据库的规范，即接口。\n各个数据库厂商去实现这套接口，提供数据库驱动jar包。\n我们可以使用这套接口(JDBC)编程，真正执行的代码是驱动jar包中的实现类。\n2.2 代码 下面我们看看原始的JDBC程序是如何操作数据库的。操作步骤如下：\n注册驱动 获取连接对象 执行SQL语句，返回执行结果 处理执行结果 释放资源 在pom.xml文件中已引入MySQL驱动依赖，我们直接编写JDBC代码即可\nJDBC具体代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import com.itheima.pojo.User; import org.junit.jupiter.api.Test; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; import java.util.ArrayList; import java.util.List; public class JdbcTest { @Test public void testJdbc() throws Exception { //1. 注册驱动 Class.forName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); //2. 获取数据库连接 String url=\u0026#34;jdbc:mysql://127.0.0.1:3306/mybatis\u0026#34;; String username = \u0026#34;root\u0026#34;; String password = \u0026#34;1234\u0026#34;; Connection connection = DriverManager.getConnection(url, username, password); //3. 执行SQL Statement statement = connection.createStatement(); //操作SQL的对象 String sql=\u0026#34;select id,name,age,gender,phone from user\u0026#34;; ResultSet rs = statement.executeQuery(sql);//SQL查询结果会封装在ResultSet对象中 List\u0026lt;User\u0026gt; userList = new ArrayList\u0026lt;\u0026gt;();//集合对象（用于存储User对象） //4. 处理SQL执行结果 while (rs.next()){ //取出一行记录中id、name、age、gender、phone下的数据 int id = rs.getInt(\u0026#34;id\u0026#34;); String name = rs.getString(\u0026#34;name\u0026#34;); short age = rs.getShort(\u0026#34;age\u0026#34;); short gender = rs.getShort(\u0026#34;gender\u0026#34;); String phone = rs.getString(\u0026#34;phone\u0026#34;); //把一行记录中的数据，封装到User对象中 User user = new User(id,name,age,gender,phone); userList.add(user);//User对象添加到集合 } //5. 释放资源 statement.close(); connection.close(); rs.close(); //遍历集合 for (User user : userList) { System.out.println(user); } } } DriverManager(类)：数据库驱动管理类。\n作用：\n注册驱动\n创建java代码和数据库之间的连接，即获取Connection对象\nConnection(接口)：建立数据库连接的对象\n作用：用于建立java程序和数据库之间的连接 Statement(接口)： 数据库操作对象(执行SQL语句的对象)。\n作用：用于向数据库发送sql语句 ResultSet(接口)：结果集对象（一张虚拟表）\n作用：sql查询语句的执行结果会封装在ResultSet中 通过上述代码，我们看到直接基于JDBC程序来操作数据库，代码实现非常繁琐，所以在项目开发中，我们很少使用。 在项目开发中，通常会使用Mybatis这类的高级技术来操作数据库，从而简化数据库操作、提高开发效率。\n2.3 问题分析 原始的JDBC程序，存在以下几点问题：\n数据库链接的四要素(驱动、链接、用户名、密码)全部硬编码在java代码中 查询结果的解析及封装非常繁琐 每一次查询数据库都需要获取连接,操作完毕后释放连接, 资源浪费, 性能降低 2.4 技术对比 分析了JDBC的缺点之后，我们再来看一下在mybatis中，是如何解决这些问题的：\n数据库连接四要素(驱动、链接、用户名、密码)，都配置在springboot默认的配置文件 application.properties中\n查询结果的解析及封装，由mybatis自动完成映射封装，我们无需关注\n在mybatis中使用了数据库连接池技术，从而避免了频繁的创建连接、销毁连接而带来的资源浪费。\n使用SpringBoot+Mybatis的方式操作数据库，能够提升开发效率、降低资源浪费\n而对于Mybatis来说，我们在开发持久层程序操作数据库时，需要重点关注以下两个方面：\napplication.properties\n1 2 3 4 5 6 7 8 #驱动类名称 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver #数据库连接的url spring.datasource.url=jdbc:mysql://localhost:3306/mybatis #连接数据库的用户名 spring.datasource.username=root #连接数据库的密码 spring.datasource.password=1234 Mapper接口（编写SQL语句）\n1 2 3 4 5 @Mapper public interface UserMapper { @Select(\u0026#34;select id, name, age, gender, phone from user\u0026#34;) public List\u0026lt;User\u0026gt; list(); } 3. 数据库连接池 在前面我们所讲解的mybatis中，使用了数据库连接池技术，避免频繁的创建连接、销毁连接而带来的资源浪费。\n下面我们就具体的了解下数据库连接池。\n3.1 介绍 没有使用数据库连接池：\n客户端执行SQL语句：要先创建一个新的连接对象，然后执行SQL语句，SQL语句执行后又需要关闭连接对象从而释放资源，每次执行SQL时都需要创建连接、销毁链接，这种频繁的重复创建销毁的过程是比较耗费计算机的性能。 数据库连接池是个容器，负责分配、管理数据库连接(Connection)\n程序在启动时，会在数据库连接池(容器)中，创建一定数量的Connection对象 允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个\n客户端在执行SQL时，先从连接池中获取一个Connection对象，然后在执行SQL语句，SQL语句执行完之后，释放Connection时就会把Connection对象归还给连接池（Connection对象可以复用） 释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏\n客户端获取到Connection对象了，但是Connection对象并没有去访问数据库(处于空闲)，数据库连接池发现Connection对象的空闲时间 \u0026gt; 连接池中预设的最大空闲时间，此时数据库连接池就会自动释放掉这个连接对象 数据库连接池的好处：\n资源重用 提升系统响应速度 避免数据库连接遗漏 3.2 产品 要怎么样实现数据库连接池呢？\n官方(sun)提供了数据库连接池标准（javax.sql.DataSource接口）\n功能：获取连接\n1 public Connection getConnection() throws SQLException; 第三方组织必须按照DataSource接口实现\n常见的数据库连接池：\nC3P0 DBCP Druid Hikari (springboot默认) 现在使用更多的是：Hikari、Druid （性能更优越）\nHikari（追光者） [默认的连接池] Druid（德鲁伊）\nDruid连接池是阿里巴巴开源的数据库连接池项目\n功能强大，性能优秀，是Java语言最好的数据库连接池之一\n​\n如果我们想把默认的数据库连接池切换为Druid数据库连接池，只需要完成以下两步操作即可：\n参考官方地址：https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter\n在pom.xml文件中引入依赖 1 2 3 4 5 6 \u0026lt;dependency\u0026gt; \u0026lt;!-- Druid连接池依赖 --\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在application.properties中引入数据库连接配置 方式1：\n1 2 3 4 spring.datasource.druid.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.druid.url=jdbc:mysql://localhost:3306/mybatis spring.datasource.druid.username=root spring.datasource.druid.password=1234 方式2：\n1 2 3 4 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/mybatis spring.datasource.username=root spring.datasource.password=1234 4. lombok 4.1 介绍 Lombok是一个实用的Java类库，可以通过简单的注解来简化和消除一些必须有但显得很臃肿的Java代码。\n通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，并可以自动化生成日志变量，简化java开发、提高效率。\n注解 作用 @Getter/@Setter 为所有的属性提供get/set方法 @ToString 会给类自动生成易阅读的 toString 方法 @EqualsAndHashCode 根据类所拥有的非静态字段自动重写 equals 方法和 hashCode 方法 @Data 提供了更综合的生成代码功能（@Getter + @Setter + @ToString + @EqualsAndHashCode） @NoArgsConstructor 为实体类生成无参的构造器方法 @AllArgsConstructor 为实体类生成除了static修饰的字段之外带有各参数的构造器方法。 4.2 使用 第1步：在pom.xml文件中引入依赖\n1 2 3 4 5 \u0026lt;!-- 在springboot的父工程中，已经集成了lombok并指定了版本号，故当前引入依赖时不需要指定version --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 第2步：在实体类上添加注解\n1 2 3 4 5 6 7 8 9 10 import lombok.Data; @Data public class User { private Integer id; private String name; private Short age; private Short gender; private String phone; } 在实体类上添加了@Data注解，那么这个类在编译时期，就会生成getter/setter、equals、hashcode、toString等方法。\n说明：@Data注解中不包含全参构造方法，通常在实体类上，还会添加上：全参构造、无参构造\n1 2 3 4 5 6 7 8 9 10 11 12 import lombok.Data; @Data //getter方法、setter方法、toString方法、hashCode方法、equals方法 @NoArgsConstructor //无参构造 @AllArgsConstructor//全参构造 public class User { private Integer id; private String name; private Short age; private Short gender; private String phone; } Lombok的注意事项：\nLombok会在编译时，会自动生成对应的java代码 在使用lombok时，还需要安装一个lombok的插件（新版本的IDEA中自带） or\n","date":"2024-07-05T22:27:20+08:00","image":"https://picsum.photos/800/600 ","permalink":"https://4evergreat.github.io/2024/mybatis-blog-2/","title":"mybatis初级2"},{"content":"一、下载 点开下面的链接：https://dev.mysql.com/downloads/mysql/\n点击Download 就可以下载对应的安装包了, 安装包如下: 二、解压 下载完成后我们得到的是一个压缩包，将其解压，我们就可以得到MySQL 8.0.31 的软件本体了(就是一个文件夹)，我们可以把它放在你想安装的位置 。\n三、配置 1. 添加环境变量 环境变量里面有很多选项，这里我们只用到Path这个参数。为什么在初始化的开始要添加环境变量呢？\n在黑框(即CMD)中输入一个可执行程序的名字，Windows会先在环境变量中的Path所指的路径中寻找一遍，如果找到了就直接执行，没找到就在当前工作目录找，如果还没找到，就报错。我们添加环境变量的目的就是能够在任意一个黑框直接调用MySQL中的相关程序而不用总是修改工作目录，大大简化了操作。\n右键此电脑→属性，点击高级系统设置\n点击环境变量\n在系统变量中新建MYSQL_HOME\n在系统变量中找到并双击Path\n点击新建\n最后点击确定。\n如何验证是否添加成功？\n右键开始菜单(就是屏幕左下角)，选择命令提示符(管理员)，打开黑框，敲入mysql，回车。\n如果提示Can't connect to MySQL server on 'localhost'则证明添加成功；\n如果提示mysql不是内部或外部命令，也不是可运行的程序或批处理文件则表示添加添加失败，请重新检查步骤并重试。\n2. 初始化MySQL ==以管理员身份，运行命令行窗口：==\n在刚才的命令行中，输入如下的指令：\n1 mysqld --initialize-insecure 稍微等待一会，如果出现没有出现报错信息，则证明data目录初始化没有问题，此时再查看MySQL目录下已经有data目录生成。\ntips：如果出现如下错误\n是由于权限不足导致的，以管理员方式运行 cmd\n3. 注册MySQL服务 命令行（注意必须以管理员身份启动）中，输入如下的指令，回车执行：\n1 mysqld -install 现在你的计算机上已经安装好了MySQL服务了。\n4. 启动MySQL服务 在黑框里敲入net start mysql，回车。\n1 2 3 net start mysql // 启动mysql服务 net stop mysql // 停止mysql服务 5. 修改默认账户密码 在黑框里敲入mysqladmin -u root password 1234，这里的1234就是指默认管理员(即root账户)的密码，可以自行修改成你喜欢的。\n1 mysqladmin -u root password 1234 四、登录MySQL 右键开始菜单，选择命令提示符，打开黑框。 在黑框中输入，mysql -uroot -p1234，回车，出现下图且左下角为mysql\u0026gt;，则登录成功。\n1 mysql -uroot -p1234 到这里你就可以开始你的MySQL之旅了！\n退出mysql：\n1 2 exit quit 登陆参数：\n1 mysql -u用户名 -p密码 -h要连接的mysql服务器的ip地址(默认127.0.0.1) -P端口号(默认3306) 五、卸载MySQL 如果你想卸载MySQL，也很简单。\n点击开始菜单，输入cmd，选择 \u0026ldquo;命令提示符\u0026rdquo;，选择右侧的 \u0026ldquo;以管理员身份运行\u0026rdquo;。\n敲入net stop mysql，回车。 1 net stop mysql 再敲入mysqld -remove mysql，回车。 1 mysqld -remove mysql 最后删除MySQL目录及相关的环境变量。 至此，MySQL卸载完成！\n","date":"2024-07-05T22:27:20+08:00","image":"https://picsum.photos/800/600 ","permalink":"https://4evergreat.github.io/2024/mysql-blog-1/","title":"mysql安装"},{"content":"数据库开发-MySQL 前言 在我们讲解SpringBootWeb基础知识(请求响应案例)的时候，我们讲到在web开发中，为了应用程序职责单一，方便维护，我们一般将web应用程序分为三层，即：Controller、Service、Dao 。\n之前我们的案例中，是这样子的请求流程：浏览器发起请求，先请求Controller；Controller接收到请求之后，调用Service进行业务逻辑处理；Service再调用Dao，Dao再解析user.xml中所存储的数据。\nxml文件中可以存储数据，但是在企业项目开发中不会使用xml文件存储数据，因为不便管理维护，操作难度大。 在真实的企业开发中呢，都会采用数据库来存储和管理数据，那此时，web开发调用流程图如下所示：\n首先来了解一下什么是数据库。\n数据库：英文为 DataBase，简称DB，它是存储和管理数据的仓库。 像我们日常访问的电商网站京东，企业内部的管理系统OA、ERP、CRM这类的系统，以及大家每天都会刷的头条、抖音类的app，那这些大家所看到的数据，其实都是存储在数据库中的。最终这些数据，只是在浏览器或app中展示出来而已，最终数据的存储和管理都是数据库负责的。\n数据是存储在数据库中的，那我们要如何来操作数据库以及数据库中所存放的数据呢？\n那这里呢，会涉及到一个软件：数据库管理系统（DataBase Management System，简称DBMS）\nDBMS是操作和管理数据库的大型软件。将来我们只需要操作这个软件，就可以通过这个软件来操纵和管理数据库了。 此时又出现一个问题：DBMS这个软件怎么知道要操作的是哪个数据库、哪个数据呢？是对数据做修改还是查询呢？\n需要给DBMS软件发送一条指令，告诉这个软件我们要执行的是什么样的操作，要对哪个数据进行操作。而这个指令就是SQL语句 SQL（Structured Query Language，简称SQL）：结构化查询语言，它是操作关系型数据库的编程语言，定义了一套操作关系型数据库的统一标准。我们学习数据库开发，最为重要的就是学习SQL语句 。\n关系型数据库：我们后面会详细讲解，现在大家只需要知道我们学习的数据库属于关系型数据库即可。\n结论：程序员给数据库管理系统(DBMS)发送SQL语句，再由数据库管理系统操作数据库当中的数据。\n了解了数据库的一些简单概念之后，接下来我们再来介绍下目前主流的数据库，这里截取了排名前十的数据库：\nOracle：大型的收费数据库，Oracle公司产品，价格昂贵。（通常是不差钱的公司会选择使用这个数据库） MySQL：开源免费的中小型数据库，后来Sun公司收购了MySQL，而Oracle又收购了Sun公司。目前Oracle推出两个版本的Mysql：社区版(开源免费)、商业版(收费)。 SQL Server：Microsoft 公司推出的收费的中型数据库，C#、.net等语言常用。 PostgreSQL：开源免费的中小型数据库。 DB2：IBM公司的大型收费数据库产品。 SQLLite：嵌入式的微型数据库。Android内置的数据库采用的就是该数据库。 MariaDB：开源免费的中小型数据库。是MySQL数据库的另外一个分支、另外一个衍生产品，与MySQL数据库有很好的兼容性。 那这么多数据库，我们全部都需要学习吗，其实并不用，我们只需要学习其中的一个就可以了，我们此次课程中学习的数据库是现在互联网公司开发使用最为流行的MySQL数据库。\n此时大家可能会有一个疑问，我们现在学习的是Mysql数据库，我们以后去公司做开发，如果用到的是Oracle数据库或SQL Server数据库该怎么办？其实大家完全不用担心这个问题，因为这些数据库都是属于关系型数据库，要操作关系型数据库都是通过 SQL语句来实现的，而SQL语句又是操作关系型数据库的统一标准。\n结论：只要我们学会了SQL语句，就可以通过SQL语句来操作Mysql，也可以通过SQL语句来操作Oracle或SQL Server\n课程内容安排：\n以上课程内容拆解为3部分知识点：\n接下来我们就先进入到第一天的Mysql概述学习。\n1. MySQL概述 官网：https://dev.mysql.com/\n1.1 安装 1.1.1 版本 MySQL官方提供了两个版本：\n商业版本（MySQL Enterprise Edition）\n该版本是收费的，我们可以使用30天。 官方会提供对应的技术支持。 社区版本（MySQL Community Server）\n该版本是免费的，但是MySQL不会提供任何的技术支持。 本课程，采用的是MySQL的社区版本（8.0.31）\n1.1.2 安装 官网下载地址：https://downloads.mysql.com/archives/community/\n这个安装包呢，大家可以不用下载，因为资料中已提供现成的安装包。 安装MySQL具体的步骤，参考资料中提供的 《MySQL安装文档》 ，进行软件的安装即可。\n1.1.3 连接 MySQL服务器启动完毕后，然后再使用如下指令，来连接MySQL服务器：\n1 mysql -u用户名 -p密码 [-h数据库服务器的IP地址 -P端口号] -h 参数不加，默认连接的是本地 127.0.0.1 的MySQL服务器\n-P 参数不加，默认连接的端口号是 3306\n上述指令，可以有两种形式：\n密码直接在-p参数之后直接指定 （这种方式不安全，密码直接以明文形式出现在命令行） 密码在-p回车之后，在命令行中输入密码，然后回车 1.1.4 企业使用方式(了解) 上述的MySQL服务器我们是安装在本地的，这个仅仅是在我们学习阶段，在真实的企业开发中，MySQL数据库服务器是不会在我们本地安装的，是在公司的服务器上安装的，而服务器还需要放置在专门的IDC机房中的，IDC机房呢，就需要保证恒温、恒湿、恒压，而且还要保证网络、电源的可靠性(备用电源及网络)。\n那我们要想使用服务器上的这台MySQL服务器，就需要在我们的电脑上去远程连接这台MySQL。 而服务器上安装的MySQL数据库呢，并不是你一个人在访问，我们项目组的其他开发人员也是需要访问这台MySQL的。\n我们在学习阶段，如果想提前体验一下企业中数据库的使用方式，可以借助于VMware虚拟机来实现。我们可以在我们的电脑上安装一个VMware，然后在Vmware虚拟机上在安装一个服务器操作系统Linux，然后再在Linux服务器上安装各种企业级软件。\n接下来，就来演示一下，通过MySQL的客户端命令行，如何来连接服务器上部署的MySQL ：\n1 mysql -u用户名 -p密码 [-h数据库服务器的IP地址 -P端口号] 1.2 数据模型 介绍完了Mysql数据库的安装配置之后，接下来我们再来聊一聊Mysql当中的数据模型。学完了这一小节之后，我们就能够知道在Mysql数据库当中到底是如何来存储和管理数据的。\n在介绍 Mysql的数据模型之前，需要先了解一个概念：关系型数据库。\n关系型数据库（RDBMS）\n概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。\n而所谓二维表，指的是由行和列组成的表，如下图：\n二维表的优点：\n使用表存储数据，格式统一，便于维护\n使用SQL语言操作，标准统一，使用方便，可用于复杂查询\n我们之前提到的MySQL、Oracle、DB2、SQLServer这些都是属于关系型数据库，里面都是基于二维表存储数据的。\n结论：基于二维表存储数据的数据库就成为关系型数据库，不是基于二维表存储数据的数据库，就是非关系型数据库（比如大家后面要学习的Redis，就属于非关系型数据库）。\n2). 数据模型\n介绍完了关系型数据库之后，接下来我们再来看一看在Mysql数据库当中到底是如何来存储数据的，也就是Mysql 的数据模型。\nMySQL是关系型数据库，是基于二维表进行数据存储的，具体的结构图下:\n通过MySQL客户端连接数据库管理系统DBMS，然后通过DBMS操作数据库 使用MySQL客户端，向数据库管理系统发送一条SQL语句，由数据库管理系统根据SQL语句指令去操作数据库中的表结构及数据 一个数据库服务器中可以创建多个数据库，一个数据库中也可以包含多张表，而一张表中又可以包含多行记录。 在Mysql数据库服务器当中存储数据，你需要：\n先去创建数据库（可以创建多个数据库，之间是相互独立的） 在数据库下再去创建数据表（一个数据库下可以创建多张表） 再将数据存放在数据表中（一张表可以存储多行数据） 1.3 SQL简介 SQL：结构化查询语言。一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准。\n在学习具体的SQL语句之前，先来了解一下SQL语言的语法。\n1.3.1 SQL通用语法 1、SQL语句可以单行或多行书写，以分号结尾。\n2、SQL语句可以使用空格/缩进来增强语句的可读性。\n3、MySQL数据库的SQL语句不区分大小写。\n4、注释：\n单行注释：\u0026ndash; 注释内容 或 # 注释内容(MySQL特有) 多行注释： /* 注释内容 */ 以上就是SQL语句的通用语法，这些通用语法大家目前先有一个直观的认识，我们后面在讲解每一类SQL语句的时候，还会再来强调通用语法。\n1.3.2 分类 SQL语句根据其功能被分为四大类：DDL、DML、DQL、DCL\n分类 全称 说明 DDL Data Definition Language 数据定义语言，用来定义数据库对象(数据库，表，字段) DML Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改 DQL Data Query Language 数据查询语言，用来查询数据库中表的记录 DCL Data Control Language 数据控制语言，用来创建数据库用户、控制数据库的访问权限 2. 数据库设计-DDL 下面我们就正式的进入到SQL语句的学习，在学习之前先给大家介绍一下我们要开发一个项目，整个开发流程是什么样的，以及在流程当中哪些环节会涉及到数据库。\n2.1 项目开发流程 需求文档：\n在我们开发一个项目或者项目当中的某个模块之前，会先会拿到产品经理给我们提供的页面原型及需求文档。 设计：\n拿到产品原型和需求文档之后，我们首先要做的不是编码，而是要先进行项目的设计，其中就包括概要设计、详细设计、接口设计、数据库设计等等。 数据库设计根据产品原型以及需求文档，要分析各个模块涉及到的表结构以及表结构之间的关系，以及表结构的详细信息。最终我们需要将数据库以及数据库当中的表结构设计创建出来。 开发/测试：\n参照页面原型和需求进行编码，实现业务功能。在这个过程当中，我们就需要来操作设计出来的数据库表结构，来完成业务的增删改查操作等。 部署上线：\n在项目的功能开发测试完成之后，项目就可以上线运行了，后期如果项目遇到性能瓶颈，还需要对项目进行优化。优化很重要的一个部分就是数据库的优化，包括数据库当中索引的建立、SQL 的优化、分库分表等操作。 在上述的流程当中，针对于数据库来说，主要包括三个阶段：\n数据库设计阶段 参照页面原型以及需求文档设计数据库表结构 数据库操作阶段 根据业务功能的实现，编写SQL语句对数据表中的数据进行增删改查操作 数据库优化阶段 通过数据库的优化来提高数据库的访问性能。优化手段：索引、SQL优化、分库分表等 接下来我们就先来学习第一部分数据库的设计，而数据库的设计就是来定义数据库，定义表结构以及表中的字段。\n2.2 数据库操作 我们在进行数据库设计，需要使用到刚才所介绍SQL分类中的DDL语句。\nDDL英文全称是Data Definition Language(数据定义语言)，用来定义数据库对象(数据库、表)。\nDDL中数据库的常见操作：查询、创建、使用、删除。\n2.2.1 查询数据库 查询所有数据库：\n1 show databases; 命令行中执行效果如下：\n查询当前数据库：\n1 select database(); 命令行中执行效果如果：\n我们要操作某一个数据库，必须要切换到对应的数据库中。\n通过指令：select database() ，就可以查询到当前所处的数据库\n2.2.2 创建数据库 语法：\n1 create database [ if not exists ] 数据库名; 案例： 创建一个itcast数据库。\n1 create database itcast; 命令行执行效果如下：\n==注意：在同一个数据库服务器中，不能创建两个名称相同的数据库，否则将会报错。==\n可以使用if not exists来避免这个问题 1 2 -- 数据库不存在,则创建该数据库；如果存在则不创建 create database if not extists itcast; 命令行执行效果如下： 2.2.3 使用数据库 语法：\n1 use 数据库名 ; 我们要操作某一个数据库下的表时，就需要通过该指令，切换到对应的数据库下，否则不能操作。\n案例：切换到itcast数据\n1 use itcast; 命令执行效果如下：\n2.2.4 删除数据库 语法：\n1 drop database [ if exists ] 数据库名 ; 如果删除一个不存在的数据库，将会报错。\n可以加上参数 if exists ，如果数据库存在，再执行删除，否则不执行删除。\n案例：删除itcast数据库\n1 drop database if exists itcast; -- itcast数据库存在时删除 命令执行效果如下：\n说明：上述语法中的database，也可以替换成 schema\n如：create schema db01; 如：show schemas; 2.3 图形化工具 2.3.1 介绍 前面我们讲解了DDL中关于数据库操作的SQL语句，在我们编写这些SQL时，都是在命令行当中完成的。大家在练习的时候应该也感受到了，在命令行当中来敲这些SQL语句很不方便，主要的原因有以下 3 点：\n没有任何代码提示。（全靠记忆，容易敲错字母造成执行报错） 操作繁琐，影响开发效率。（所有的功能操作都是通过SQL语句来完成的） 编写过的SQL代码无法保存。 在项目开发当中，通常为了提高开发效率，都会借助于现成的图形化管理工具来操作数据库。\n目前MySQL主流的图形化界面工具有以下几种：\nDataGrip是JetBrains旗下的一款数据库管理工具，是管理和开发MySQL、Oracle、PostgreSQL的理想解决方案。\n官网： https://www.jetbrains.com/zh-cn/datagrip/\n2.3.2 安装 安装： 参考资料中提供的《DataGrip安装手册》\n说明：DataGrip这款工具可以不用安装，因为Jetbrains公司已经将DataGrip这款工具的功能已经集成到了 IDEA当中，所以我们就可以使用IDEA来作为一款图形化界面工具来操作Mysql数据库。\n2.3.3 使用 2.2.3.1 连接数据库 1、打开IDEA自带的Database\n2、配置MySQL\n3、输入相关信息\n4、下载MySQL连接驱动\n5、测试数据库连接\n6、保存配置\n默认情况下，连接上了MySQL数据库之后， 数据库并没有全部展示出来。 需要选择要展示哪些数据库。具体操作如下：\n2.2.3.2 操作数据库 创建数据库：\n有了图形化界面工具后，就可以方便的使用图形化工具：创建数据库，创建表、修改表等DDL操作。\n其实工具底层也是通过DDL语句操作的数据库，只不过这些SQL语句是图形化界面工具帮我们自动完成的。\n查看所有数据库：\n2.3 表操作 学习完了DDL语句当中关于数据库的操作之后，接下来我们继续学习DDL语句当中关于表结构的操作。\n关于表结构的操作也是包含四个部分：创建表、查询表、修改表、删除表。\n2.3.1 创建 2.3.1.1 语法 1 2 3 4 5 6 create table 表名( 字段1 字段1类型 [约束] [comment 字段1注释 ], 字段2 字段2类型 [约束] [comment 字段2注释 ], ...... 字段n 字段n类型 [约束] [comment 字段n注释 ] ) [ comment 表注释 ] ; 注意： [ ] 中的内容为可选参数； 最后一个字段后面没有逗号\n案例：创建tb_user表\n对应的结构如下： 建表语句： 1 2 3 4 5 6 7 create table tb_user ( id int comment \u0026#39;ID,唯一标识\u0026#39;, # id是一行数据的唯一标识（不能重复） username varchar(20) comment \u0026#39;用户名\u0026#39;, name varchar(10) comment \u0026#39;姓名\u0026#39;, age int comment \u0026#39;年龄\u0026#39;, gender char(1) comment \u0026#39;性别\u0026#39; ) comment \u0026#39;用户表\u0026#39;; 数据表创建完成，接下来我们还需要测试一下是否可以往这张表结构当中来存储数据。\n双击打开tb_user表结构，大家会发现里面没有数据：\n添加数据：\n此时我们再插入一条数据：\n我们之前提到过：id字段是一行数据的唯一标识，不能有重复值。但是现在数据表中有两个相同的id值，这是为什么呢？\n其实我们现在创建表结构的时候， id这个字段我们只加了一个备注信息说明它是一个唯一标识，但是在数据库层面呢，并没有去限制字段存储的数据。所以id这个字段没有起到唯一标识的作用。 想要限制字段所存储的数据，就需要用到数据库中的约束。\n2.3.1.2 约束 概念：所谓约束就是作用在表中字段上的规则，用于限制存储在表中的数据。\n作用：就是来保证数据库当中数据的正确性、有效性和完整性。（后面的学习会验证这些）\n在MySQL数据库当中，提供了以下5种约束：\n约束 描述 关键字 非空约束 限制该字段值不能为null not null 唯一约束 保证字段的所有数据都是唯一、不重复的 unique 主键约束 主键是一行数据的唯一标识，要求非空且唯一 primary key 默认约束 保存数据时，如果未指定该字段值，则采用默认值 default 外键约束 让两张表的数据建立连接，保证数据的一致性和完整性 foreign key 注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。\n案例：创建tb_user表\n对应的结构如下： 在上述的表结构中:\nid 是一行数据的唯一标识\nusername 用户名字段是非空且唯一的\nname 姓名字段是不允许存储空值的\ngender 性别字段是有默认值，默认为男\n建表语句： 1 2 3 4 5 6 7 create table tb_user ( id int primary key comment \u0026#39;ID,唯一标识\u0026#39;, username varchar(20) not null unique comment \u0026#39;用户名\u0026#39;, name varchar(10) not null comment \u0026#39;姓名\u0026#39;, age int comment \u0026#39;年龄\u0026#39;, gender char(1) default \u0026#39;男\u0026#39; comment \u0026#39;性别\u0026#39; ) comment \u0026#39;用户表\u0026#39;; 数据表创建完成，接下来测试一下表中字段上的约束是否生效\n大家有没有发现一个问题：id字段下存储的值，如果由我们自己来维护会比较麻烦(必须保证值的唯一性)。MySQL数据库为了解决这个问题，给我们提供了一个关键字：auto_increment（自动增长）\n主键自增：auto_increment\n每次插入新的行记录时，数据库自动生成id字段(主键)下的值 具有auto_increment的数据列是一个正数序列开始增长(从1开始自增) 1 2 3 4 5 6 7 create table tb_user ( id int primary key auto_increment comment \u0026#39;ID,唯一标识\u0026#39;, #主键自动增长 username varchar(20) not null unique comment \u0026#39;用户名\u0026#39;, name varchar(10) not null comment \u0026#39;姓名\u0026#39;, age int comment \u0026#39;年龄\u0026#39;, gender char(1) default \u0026#39;男\u0026#39; comment \u0026#39;性别\u0026#39; ) comment \u0026#39;用户表\u0026#39;; 测试：主键自增\n2.3.1.3 数据类型 在上面建表语句中，我们在指定字段的数据类型时，用到了int 、varchar、char，那么在MySQL中除了以上的数据类型，还有哪些常见的数据类型呢？ 接下来,我们就来详细介绍一下MySQL的数据类型。\nMySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。\n数值类型\n类型 大小 有符号(SIGNED)范围 无符号(UNSIGNED)范围 描述 TINYINT 1byte (-128，127) (0，255) 小整数值 SMALLINT 2bytes (-32768，32767) (0，65535) 大整数值 MEDIUMINT 3bytes (-8388608，8388607) (0，16777215) 大整数值 INT/INTEGER 4bytes (-2147483648，2147483647) (0，4294967295) 大整数值 BIGINT 8bytes (-2^63，2^63-1) (0，2^64-1) 极大整数值 FLOAT 4bytes (-3.402823466 E+38，3.402823466351 E+38) 0 和 (1.175494351 E-38，3.402823466 E+38) 单精度浮点数值 DOUBLE 8bytes (-1.7976931348623157 E+308，1.7976931348623157 E+308) 0 和 (2.2250738585072014 E-308，1.7976931348623157 E+308) 双精度浮点数值 DECIMAL 依赖于M(精度)和D(标度)的值 依赖于M(精度)和D(标度)的值 小数值(精确定点数) 1 2 3 4 5 6 示例: 年龄字段 ---不会出现负数, 而且人的年龄不会太大 age tinyint unsigned 分数 ---总分100分, 最多出现一位小数 score double(4,1) 字符串类型\n类型 大小 描述 CHAR 0-255 bytes 定长字符串(需要指定长度) VARCHAR 0-65535 bytes 变长字符串(需要指定长度) TINYBLOB 0-255 bytes 不超过255个字符的二进制数据 TINYTEXT 0-255 bytes 短文本字符串 BLOB 0-65 535 bytes 二进制形式的长文本数据 TEXT 0-65 535 bytes 长文本数据 MEDIUMBLOB 0-16 777 215 bytes 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215 bytes 中等长度文本数据 LONGBLOB 0-4 294 967 295 bytes 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295 bytes 极大文本数据 char 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性能会更高些。\n1 2 3 4 5 6 示例： 用户名 username ---长度不定, 最长不会超过50 username varchar(50) 手机号 phone ---固定长度为11 phone char(11) 日期时间类型\n类型 大小 范围 格式 描述 DATE 3 1000-01-01 至 9999-12-31 YYYY-MM-DD 日期值 TIME 3 -838:59:59 至 838:59:59 HH:MM:SS 时间值或持续时间 YEAR 1 1901 至 2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00 至 9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:01 至 2038-01-19 03:14:07 YYYY-MM-DD HH:MM:SS 混合日期和时间值，时间戳 1 2 3 4 5 6 示例: 生日字段 birthday ---生日只需要年月日 birthday date 创建时间 createtime --- 需要精确到时分秒 createtime datetime 2.3.1.4 案例 需求：根据产品原型/需求创建表((设计合理的数据类型、长度、约束)\n参考资料中提供的《黑马-tlias智能学习辅助系统》页面原型，设计员工管理模块的表结构\n暂不考虑所属部门字段\n产品原型及需求如下：\n步骤：\n阅读产品原型及需求文档，看看里面涉及到哪些字段。\n查看需求文档说明，确认各个字段的类型以及字段存储数据的长度限制。\n在页面原型中描述的基础字段的基础上，再增加额外的基础字段。\n使用SQL创建表：\n1 2 3 4 5 6 7 8 9 10 11 12 create table emp ( id int unsigned primary key auto_increment comment \u0026#39;ID\u0026#39;, username varchar(20) not null unique comment \u0026#39;用户名\u0026#39;, password varchar(32) default \u0026#39;123456\u0026#39; comment \u0026#39;密码\u0026#39;, name varchar(10) not null comment \u0026#39;姓名\u0026#39;, gender tinyint unsigned not null comment \u0026#39;性别, 说明: 1 男, 2 女\u0026#39;, image varchar(300) comment \u0026#39;图像\u0026#39;, job tinyint unsigned comment \u0026#39;职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管\u0026#39;, entrydate date comment \u0026#39;入职时间\u0026#39;, create_time datetime not null comment \u0026#39;创建时间\u0026#39;, update_time datetime not null comment \u0026#39;修改时间\u0026#39; ) comment \u0026#39;员工表\u0026#39;; 除了使用SQL语句创建表外，我们还可以借助于图形化界面来创建表结构，这种创建方式会更加直观、更加方便。\n操作步骤如下：\n在指定操作的数据库上，右键New ==\u0026gt; Table 编辑表结构的相关信息 2.3.1.5 设计表流程 通过上面的案例，我们明白了，设计一张表，基本的流程如下：\n阅读页面原型及需求文档\n基于页面原则和需求文档，确定原型字段(类型、长度限制、约束)\n再增加表设计所需要的业务基础字段(id主键、插入时间、修改时间)\n说明：\ncreate_time：记录的是当前这条数据插入的时间。\nupdate_time：记录当前这条数据最后更新的时间。\n2.3.2 查询 关于表结构的查询操作，工作中一般都是直接基于图形化界面操作。\n查询当前数据库所有表\n1 show tables; 查看指定表结构\n1 desc 表名 ;#可以查看指定表的字段、字段的类型、是否可以为NULL、是否存在默认值等信息 查询指定表的建表语句\n1 show create table 表名 ; 2.3.3 修改 关于表结构的修改操作，工作中一般都是直接基于图形化界面操作。\n添加字段\n1 alter table 表名 add 字段名 类型(长度) [comment 注释] [约束]; 案例： 为tb_emp表添加字段qq，字段类型为 varchar(11)\n1 alter table tb_emp add qq varchar(11) comment \u0026#39;QQ号码\u0026#39;; 图形化操作：添加字段\n修改数据类型\n1 alter table 表名 modify 字段名 新数据类型(长度); 1 alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束]; 案例：修改qq字段的字段类型，将其长度由11修改为13\n1 alter table tb_emp modify qq varchar(13) comment \u0026#39;QQ号码\u0026#39;; 案例：修改qq字段名为 qq_num，字段类型varchar(13)\n1 alter table tb_emp change qq qq_num varchar(13) comment \u0026#39;QQ号码\u0026#39;; 图形化操作：修改数据类型和字段名\n删除字段\n1 alter table 表名 drop 字段名; 案例：删除tb_emp表中的qq_num字段\n1 alter table tb_emp drop qq_num; 图形化操作：删除字段\n修改表名\n1 rename table 表名 to 新表名; 案例：将当前的tb_emp表的表名修改为emp\n1 rename table tb_emp to emp; 图形化操作：修改表名\n2.3.4 删除 关于表结构的删除操作，工作中一般都是直接基于图形化界面操作。\n删除表语法：\n1 drop table [ if exists ] 表名; if exists ：只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不加该参数项，删除一张不存在的表，执行将会报错)。\n案例：如果tb_emp表存在，则删除tb_emp表\n1 drop table if exists tb_emp; -- 在删除表时，表中的全部数据也会被删除。 图形化操作：删除表\n3. 数据库操作-DML DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。\n添加数据（INSERT） 修改数据（UPDATE） 删除数据（DELETE） 3.1 增加(insert) insert语法：\n向指定字段添加数据\n1 insert into 表名 (字段名1, 字段名2) values (值1, 值2); 全部字段添加数据\n1 insert into 表名 values (值1, 值2, ...); 批量添加数据（指定字段）\n1 insert into 表名 (字段名1, 字段名2) values (值1, 值2), (值1, 值2); 批量添加数据（全部字段）\n1 insert into 表名 values (值1, 值2, ...), (值1, 值2, ...); 案例1：向tb_emp表的username、name、gender字段插入数据\n1 2 3 -- 因为设计表时create_time, update_time两个字段不能为NULL，所以也做为要插入的字段 insert into tb_emp(username, name, gender, create_time, update_time) values (\u0026#39;wuji\u0026#39;, \u0026#39;张无忌\u0026#39;, 1, now(), now()); 案例2：向tb_emp表的所有字段插入数据\n1 2 insert into tb_emp(id, username, password, name, gender, image, job, entrydate, create_time, update_time) values (null, \u0026#39;zhirou\u0026#39;, \u0026#39;123\u0026#39;, \u0026#39;周芷若\u0026#39;, 2, \u0026#39;1.jpg\u0026#39;, 1, \u0026#39;2010-01-01\u0026#39;, now(), now()); 案例3：批量向tb_emp表的username、name、gender字段插入数据\n1 2 3 insert into tb_emp(username, name, gender, create_time, update_time) values (\u0026#39;weifuwang\u0026#39;, \u0026#39;韦一笑\u0026#39;, 1, now(), now()), (\u0026#39;fengzi\u0026#39;, \u0026#39;张三疯\u0026#39;, 1, now(), now()); 图形化操作：双击tb_emp表查看数据\nInsert操作的注意事项：\n插入数据时，指定的字段顺序需要与值的顺序是一一对应的。\n字符串和日期型数据应该包含在引号中。\n插入的数据大小，应该在字段的规定范围内。\n3.2 修改(update) update语法：\n1 update 表名 set 字段名1 = 值1 , 字段名2 = 值2 , .... [where 条件] ; 案例1：将tb_emp表中id为1的员工，姓名name字段更新为\u0026rsquo;张三'\n1 update tb_emp set name=\u0026#39;张三\u0026#39;,update_time=now() where id=1; 案例2：将tb_emp表的所有员工入职日期更新为'2010-01-01'\n1 update tb_emp set entrydate=\u0026#39;2010-01-01\u0026#39;,update_time=now(); 注意事项:\n修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。\n在修改数据时，一般需要同时修改公共字段update_time，将其修改为当前操作时间。\n3.3 删除(delete) delete语法：\n1 delete from 表名 [where 条件] ; 案例1：删除tb_emp表中id为1的员工\n1 delete from tb_emp where id = 1; 案例2：删除tb_emp表中所有员工\n1 delete from tb_emp; 注意事项:\n​\t• DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。\n​\t• DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即可)。\n​\t• 当进行删除全部数据操作时，会提示询问是否确认删除所有数据，直接点击Execute即可。\n","date":"2024-07-05T22:27:20+08:00","image":"https://picsum.photos/800/600 ","permalink":"https://4evergreat.github.io/2024/mysql-blog-2/","title":"mysql中级1"},{"content":"数据库开发-MySQL 在上次学习的内容中，我们讲解了：\n使用DDL语句来操作数据库以及表结构（数据库设计） 使用DML语句来完成数据库中数据的增、删、改操作（数据库操作） 我们今天还是继续学习数据库操作方面的内容：查询（DQL语句）。\n查询操作我们分为两部分学习：\nDQL语句-单表操作 DQL语句-多表操作 1. 数据库操作-DQL 1.1 介绍 DQL英文全称是Data Query Language(数据查询语言)，用来查询数据库表中的记录。\n查询关键字：SELECT\n查询操作是所有SQL语句当中最为常见，也是最为重要的操作。在一个正常的业务系统中，查询操作的使用频次是要远高于增删改操作的。当我们打开某个网站或APP所看到的展示信息，都是通过从数据库中查询得到的，而在这个查询过程中，还会涉及到条件、排序、分页等操作。\n1.2 语法 DQL查询语句，语法结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 SELECT 字段列表 FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后条件列表 ORDER BY 排序字段列表 LIMIT 分页参数 我们今天会将上面的完整语法拆分为以下几个部分学习：\n基本查询（不带任何条件） 条件查询（where） 分组查询（group by） 排序查询（order by） 分页查询（limit） 准备一些测试数据用于查询操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 create database db02; -- 创建数据库 use db02; -- 切换数据库 -- 员工管理(带约束) create table tb_emp ( id int unsigned primary key auto_increment comment \u0026#39;ID\u0026#39;, username varchar(20) not null unique comment \u0026#39;用户名\u0026#39;, password varchar(32) default \u0026#39;123456\u0026#39; comment \u0026#39;密码\u0026#39;, name varchar(10) not null comment \u0026#39;姓名\u0026#39;, gender tinyint unsigned not null comment \u0026#39;性别, 说明: 1 男, 2 女\u0026#39;, image varchar(300) comment \u0026#39;图像\u0026#39;, job tinyint unsigned comment \u0026#39;职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管\u0026#39;, entrydate date comment \u0026#39;入职时间\u0026#39;, create_time datetime not null comment \u0026#39;创建时间\u0026#39;, update_time datetime not null comment \u0026#39;修改时间\u0026#39; ) comment \u0026#39;员工表\u0026#39;; -- 准备测试数据 INSERT INTO tb_emp (id, username, password, name, gender, image, job, entrydate, create_time, update_time) VALUES (1, \u0026#39;jinyong\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;金庸\u0026#39;, 1, \u0026#39;1.jpg\u0026#39;, 4, \u0026#39;2000-01-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:35:35\u0026#39;), (2, \u0026#39;zhangwuji\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;张无忌\u0026#39;, 1, \u0026#39;2.jpg\u0026#39;, 2, \u0026#39;2015-01-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:35:37\u0026#39;), (3, \u0026#39;yangxiao\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;杨逍\u0026#39;, 1, \u0026#39;3.jpg\u0026#39;, 2, \u0026#39;2008-05-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:35:39\u0026#39;), (4, \u0026#39;weiyixiao\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;韦一笑\u0026#39;, 1, \u0026#39;4.jpg\u0026#39;, 2, \u0026#39;2007-01-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:35:41\u0026#39;), (5, \u0026#39;changyuchun\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;常遇春\u0026#39;, 1, \u0026#39;5.jpg\u0026#39;, 2, \u0026#39;2012-12-05\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:35:43\u0026#39;), (6, \u0026#39;xiaozhao\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;小昭\u0026#39;, 2, \u0026#39;6.jpg\u0026#39;, 3, \u0026#39;2013-09-05\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:35:45\u0026#39;), (7, \u0026#39;jixiaofu\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;纪晓芙\u0026#39;, 2, \u0026#39;7.jpg\u0026#39;, 1, \u0026#39;2005-08-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:35:47\u0026#39;), (8, \u0026#39;zhouzhiruo\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;周芷若\u0026#39;, 2, \u0026#39;8.jpg\u0026#39;, 1, \u0026#39;2014-11-09\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:35:49\u0026#39;), (9, \u0026#39;dingminjun\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;丁敏君\u0026#39;, 2, \u0026#39;9.jpg\u0026#39;, 1, \u0026#39;2011-03-11\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:35:51\u0026#39;), (10, \u0026#39;zhaomin\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;赵敏\u0026#39;, 2, \u0026#39;10.jpg\u0026#39;, 1, \u0026#39;2013-09-05\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:35:53\u0026#39;), (11, \u0026#39;luzhangke\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;鹿杖客\u0026#39;, 1, \u0026#39;11.jpg\u0026#39;, 2, \u0026#39;2007-02-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:35:55\u0026#39;), (12, \u0026#39;hebiweng\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;鹤笔翁\u0026#39;, 1, \u0026#39;12.jpg\u0026#39;, 2, \u0026#39;2008-08-18\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:35:57\u0026#39;), (13, \u0026#39;fangdongbai\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;方东白\u0026#39;, 1, \u0026#39;13.jpg\u0026#39;, 1, \u0026#39;2012-11-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:35:59\u0026#39;), (14, \u0026#39;zhangsanfeng\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;张三丰\u0026#39;, 1, \u0026#39;14.jpg\u0026#39;, 2, \u0026#39;2002-08-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:36:01\u0026#39;), (15, \u0026#39;yulianzhou\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;俞莲舟\u0026#39;, 1, \u0026#39;15.jpg\u0026#39;, 2, \u0026#39;2011-05-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:36:03\u0026#39;), (16, \u0026#39;songyuanqiao\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;宋远桥\u0026#39;, 1, \u0026#39;16.jpg\u0026#39;, 2, \u0026#39;2010-01-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:36:05\u0026#39;), (17, \u0026#39;chenyouliang\u0026#39;, \u0026#39;12345678\u0026#39;, \u0026#39;陈友谅\u0026#39;, 1, \u0026#39;17.jpg\u0026#39;, null, \u0026#39;2015-03-21\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:36:07\u0026#39;), (18, \u0026#39;zhang1\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;张一\u0026#39;, 1, \u0026#39;2.jpg\u0026#39;, 2, \u0026#39;2015-01-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:36:09\u0026#39;), (19, \u0026#39;zhang2\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;张二\u0026#39;, 1, \u0026#39;2.jpg\u0026#39;, 2, \u0026#39;2012-01-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:36:11\u0026#39;), (20, \u0026#39;zhang3\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;张三\u0026#39;, 1, \u0026#39;2.jpg\u0026#39;, 2, \u0026#39;2018-01-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:36:13\u0026#39;), (21, \u0026#39;zhang4\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;张四\u0026#39;, 1, \u0026#39;2.jpg\u0026#39;, 2, \u0026#39;2015-01-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:36:15\u0026#39;), (22, \u0026#39;zhang5\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;张五\u0026#39;, 1, \u0026#39;2.jpg\u0026#39;, 2, \u0026#39;2016-01-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:36:17\u0026#39;), (23, \u0026#39;zhang6\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;张六\u0026#39;, 1, \u0026#39;2.jpg\u0026#39;, 2, \u0026#39;2012-01-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:36:19\u0026#39;), (24, \u0026#39;zhang7\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;张七\u0026#39;, 1, \u0026#39;2.jpg\u0026#39;, 2, \u0026#39;2006-01-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:36:21\u0026#39;), (25, \u0026#39;zhang8\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;张八\u0026#39;, 1, \u0026#39;2.jpg\u0026#39;, 2, \u0026#39;2002-01-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:36:23\u0026#39;), (26, \u0026#39;zhang9\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;张九\u0026#39;, 1, \u0026#39;2.jpg\u0026#39;, 2, \u0026#39;2011-01-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:36:25\u0026#39;), (27, \u0026#39;zhang10\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;张十\u0026#39;, 1, \u0026#39;2.jpg\u0026#39;, 2, \u0026#39;2004-01-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:36:27\u0026#39;), (28, \u0026#39;zhang11\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;张十一\u0026#39;, 1, \u0026#39;2.jpg\u0026#39;, 2, \u0026#39;2007-01-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:36:29\u0026#39;), (29, \u0026#39;zhang12\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;张十二\u0026#39;, 1, \u0026#39;2.jpg\u0026#39;, 2, \u0026#39;2020-01-01\u0026#39;, \u0026#39;2022-10-27 16:35:33\u0026#39;, \u0026#39;2022-10-27 16:36:31\u0026#39;); 1.3 基本查询 在基本查询的DQL语句中，不带任何的查询条件，语法如下：\n查询多个字段\n1 select 字段1, 字段2, 字段3 from 表名; 查询所有字段（通配符）\n1 select * from 表名; 设置别名\n1 select 字段1 [ as 别名1 ] , 字段2 [ as 别名2 ] from 表名; 去除重复记录\n1 select distinct 字段列表 from 表名; 案例1：查询指定字段 name，entrydate并返回\n1 select name,entrydate from tb_emp; 案例2：查询返回所有字段\n1 select * from tb_emp; *号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）\n案例3：查询所有员工的 name,entrydate，并起别名(姓名、入职日期)\n1 2 3 4 5 6 -- 方式1： select name AS 姓名, entrydate AS 入职日期 from tb_emp; -- 方式2： 别名中有特殊字符时，使用\u0026#39;\u0026#39;或\u0026#34;\u0026#34;包含 select name AS \u0026#39;姓 名\u0026#39;, entrydate AS \u0026#39;入职日期\u0026#39; from tb_emp; -- 方式3： select name AS \u0026#34;姓名\u0026#34;, entrydate AS \u0026#34;入职日期\u0026#34; from tb_emp; 案例4：查询已有的员工关联了哪几种职位(不要重复)\n1 select distinct job from tb_emp; 1.4 条件查询 语法：\n1 select 字段列表 from 表名 where 条件列表 ; -- 条件列表：意味着可以有多个条件 学习条件查询就是学习条件的构建方式，而在SQL语句当中构造条件的运算符分为两类：\n比较运算符 逻辑运算符 常用的比较运算符如下:\n比较运算符 功能 \u0026gt; 大于 \u0026gt;= 大于等于 \u0026lt; 小于 \u0026lt;= 小于等于 = 等于 \u0026lt;\u0026gt; 或 != 不等于 between \u0026hellip; and \u0026hellip; 在某个范围之内(含最小、最大值) in(\u0026hellip;) 在in之后的列表中的值，多选一（满足其一即可） like 占位符 模糊匹配(_匹配单个字符, %匹配任意个字符（0-多）) is null 是null（判断是否s） 常用的逻辑运算符如下:\n逻辑运算符 功能 and 或 \u0026amp;\u0026amp; 并且 (多个条件同时成立) or 或 || 或者 (多个条件任意一个成立) not 或 ! 非 , 不是 案例1：查询 姓名 为 杨逍 的员工\n1 2 3 select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp where name = \u0026#39;杨逍\u0026#39;; -- 字符串使用\u0026#39;\u0026#39;或\u0026#34;\u0026#34;包含 案例2：查询 id小于等于5 的员工信息\n1 2 3 select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp where id \u0026lt;=5; 案例3：查询 没有分配职位 的员工信息\n1 2 3 select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp where job is null ; 注意：查询为NULL的数据时，不能使用 = null\n案例4：查询 有职位 的员工信息\n1 2 3 select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp where job is not null ; 案例5：查询 密码不等于 \u0026lsquo;123456\u0026rsquo; 的员工信息\n1 2 3 4 5 6 7 8 -- 方式1： select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp where password \u0026lt;\u0026gt; \u0026#39;123456\u0026#39;; -- 方式2： select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp where password != \u0026#39;123456\u0026#39;; 案例6：查询 入职日期 在 \u0026lsquo;2000-01-01\u0026rsquo; (包含) 到 \u0026lsquo;2010-01-01\u0026rsquo;(包含) 之间的员工信息\n1 2 3 4 5 6 7 8 -- 方式1： select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp where entrydate\u0026gt;=\u0026#39;2000-01-01\u0026#39; and entrydate\u0026lt;=\u0026#39;2010-01-01\u0026#39;; -- 方式2： between...and select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp where entrydate between \u0026#39;2000-01-01\u0026#39; and \u0026#39;2010-01-01\u0026#39;; 案例7：查询 入职时间 在 \u0026lsquo;2000-01-01\u0026rsquo; (包含) 到 \u0026lsquo;2010-01-01\u0026rsquo;(包含) 之间 且 性别为女 的员工信息\n1 2 3 4 select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp where entrydate between \u0026#39;2000-01-01\u0026#39; and \u0026#39;2010-01-01\u0026#39; and gender = 2; 案例8：查询 职位是 2 (讲师), 3 (学工主管), 4 (教研主管) 的员工信息\n1 2 3 4 5 6 7 8 -- 方式1：使用or连接多个条件 select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp where job=2 or job=3 or job=4; -- 方式2：in关键字 select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp where job in (2,3,4); 案例9：查询 姓名 为两个字的员工信息\n1 2 3 select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp where name like \u0026#39;__\u0026#39;; # 通配符 \u0026#34;_\u0026#34; 代表任意1个字符 案例10：查询 姓 \u0026lsquo;张\u0026rsquo; 的员工信息\n1 2 3 select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp where name like \u0026#39;张%\u0026#39;; # 通配符 \u0026#34;%\u0026#34; 代表任意个字符（0个 ~ 多个） 1.5 聚合函数 之前我们做的查询都是横向查询，就是根据条件一行一行的进行判断，而使用聚合函数查询就是纵向查询，它是对一列的值进行计算，然后返回一个结果值。（将一列数据作为一个整体，进行纵向计算）\n语法：\n1 select 聚合函数(字段列表) from 表名 ; 注意 : 聚合函数会忽略空值，对NULL值不作为统计。\n常用聚合函数：\n函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 count ：按照列去统计有多少行数据。\n在根据指定的列统计的时候，如果这一列中有null的行，该行不会被统计在其中。 sum ：计算指定列的数值和，如果不是数值类型，那么计算结果为0\nmax ：计算指定列的最大值\nmin ：计算指定列的最小值\navg ：计算指定列的平均值\n案例1：统计该企业员工数量\n1 2 3 4 5 6 7 8 9 10 # count(字段) select count(id) from tb_emp;-- 结果：29 select count(job) from tb_emp;-- 结果：28 （聚合函数对NULL值不做计算） # count(常量) select count(0) from tb_emp; select count(\u0026#39;A\u0026#39;) from tb_emp; # count(*) 推荐此写法（MySQL底层进行了优化） select count(*) from tb_emp; 案例2：统计该企业最早入职的员工\n1 select min(entrydate) from tb_emp; 案例3：统计该企业最迟入职的员工\n1 select max(entrydate) from tb_emp; 案例4：统计该企业员工 ID 的平均值\n1 select avg(id) from tb_emp; 案例5：统计该企业员工的 ID 之和\n1 select sum(id) from tb_emp; 1.6 分组查询 分组： 按照某一列或者某几列，把相同的数据进行合并输出。\n分组其实就是按列进行分类(指定列下相同的数据归为一类)，然后可以对分类完的数据进行合并计算。\n分组查询通常会使用聚合函数进行计算。\n语法：\n1 select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件]; 案例1：根据性别分组 , 统计男性和女性员工的数量\n1 2 3 select gender, count(*) from tb_emp group by gender; -- 按照gender字段进行分组（gender字段下相同的数据归为一组） 案例2：查询入职时间在 \u0026lsquo;2015-01-01\u0026rsquo; (包含) 以前的员工 , 并对结果根据职位分组 , 获取员工数量大于等于2的职位\n1 2 3 4 5 select job, count(*) from tb_emp where entrydate \u0026lt;= \u0026#39;2015-01-01\u0026#39; -- 分组前条件 group by job -- 按照job字段分组 having count(*) \u0026gt;= 2; -- 分组后条件 注意事项:\n​\t• 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义\n​\t• 执行顺序：where \u0026gt; 聚合函数 \u0026gt; having\nwhere与having区别（面试题）\n执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。 1.7 排序查询 排序在日常开发中是非常常见的一个操作，有升序排序，也有降序排序。\n语法：\n1 2 3 4 5 select 字段列表 from 表名 [where 条件列表] [group by 分组字段 ] order by 字段1 排序方式1 , 字段2 排序方式2 … ; 排序方式：\nASC ：升序（默认值）\nDESC：降序\n案例1：根据入职时间, 对员工进行升序排序\n1 2 3 4 5 6 7 select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp order by entrydate ASC; -- 按照entrydate字段下的数据进行升序排序 select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp order by entrydate; -- 默认就是ASC（升序） 注意事项：如果是升序, 可以不指定排序方式ASC\n案例2：根据入职时间，对员工进行降序排序\n1 2 3 select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp order by entrydate DESC; -- 按照entrydate字段下的数据进行降序排序 案例3：根据入职时间对公司的员工进行升序排序，入职时间相同，再按照更新时间进行降序排序\n1 2 3 select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp order by entrydate ASC , update_time DESC; 注意事项：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序\n1.8 分页查询 分页操作在业务系统开发时，也是非常常见的一个功能，日常我们在网站中看到的各种各样的分页条，后台也都需要借助于数据库的分页操作。\n分页查询语法：\n1 select 字段列表 from 表名 limit 起始索引, 查询记录数 ; 案例1：从起始索引0开始查询员工数据, 每页展示5条记录\n1 2 3 select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp limit 0 , 5; -- 从索引0开始，向后取5条记录 案例2：查询 第1页 员工数据, 每页展示5条记录\n1 2 3 select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp limit 5; -- 如果查询的是第1页数据，起始索引可以省略，直接简写为：limit 条数 案例3：查询 第2页 员工数据, 每页展示5条记录\n1 2 3 select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp limit 5 , 5; -- 从索引5开始，向后取5条记录 案例4：查询 第3页 员工数据, 每页展示5条记录\n1 2 3 select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp limit 10 , 5; -- 从索引10开始，向后取5条记录 注意事项:\n起始索引从0开始。 计算公式 ： 起始索引 = （查询页码 - 1）* 每页显示记录数\n分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT\n如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 条数\n1.9 案例 DQL的基本语法我们学习结束了，接下来我们就运用所掌握的DQL语句的语法来完成两个案例。\n1.9.1 案例一 案例：根据需求完成员工管理的条件分页查询\n分析：根据输入的条件，查询第1页数据\n在员工管理的列表上方有一些查询条件：员工姓名、员工性别，员工入职时间(开始时间~结束时间)\n姓名：张 性别：男 入职时间：2000-01-01 ~ 2015-12-31 除了查询条件外，在列表的下面还有一个分页条，这就涉及到了分页查询\n查询第1页数据（每页显示10条数据） 基于查询的结果，按照修改时间进行降序排序\n结论：条件查询 + 分页查询 + 排序查询\nSQL语句代码：\n1 2 3 4 5 6 7 8 9 10 11 12 -- 根据输入条件查询第1页数据（每页展示10条记录） -- 输入条件： -- 姓名：张 （模糊查询） -- 性别：男 -- 入职时间：2000-01-01 ~ 2015-12-31 -- 分页： 0 , 10 -- 排序： 修改时间 DESC select id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp where name like \u0026#39;张%\u0026#39; and gender = 1 and entrydate between \u0026#39;2000-01-01\u0026#39; and \u0026#39;2015-12-31\u0026#39; order by update_time desc limit 0 , 10; 1.9.2 案例二 案例：根据需求完成员工信息的统计\n分析：以上信息统计在开发中也叫图形报表(将统计好的数据以可视化的形式展示出来)\n员工性别统计：以饼状图的形式展示出企业男性员人数和女性员工人数 只要查询出男性员工和女性员工各自有多少人就可以了 员工职位统计：以柱状图的形式展示各职位的在岗人数 只要查询出各个职位有多少人就可以了 员工性别统计：\n1 2 3 4 -- if(条件表达式, true取值 , false取值) select if(gender=1,\u0026#39;男性员工\u0026#39;,\u0026#39;女性员工\u0026#39;) AS 性别, count(*) AS 人数 from tb_emp group by gender; if(表达式, tvalue, fvalue) ：当表达式为true时，取值tvalue；当表达式为false时，取值fvalue\n员工职位统计：\n1 2 3 4 5 6 7 8 9 10 11 -- case 表达式 when 值1 then 结果1 when 值2 then 结果2 ... else result end select (case job when 1 then \u0026#39;班主任\u0026#39; when 2 then \u0026#39;讲师\u0026#39; when 3 then \u0026#39;学工主管\u0026#39; when 4 then \u0026#39;教研主管\u0026#39; else \u0026#39;未分配职位\u0026#39; end) AS 职位 , count(*) AS 人数 from tb_emp group by job; case 表达式 when 值1 then 结果1 [when 值2 then 结果2 \u0026hellip;] [else result] end\n2. 多表设计 关于单表的操作(单表的设计、单表的增删改查)我们就已经学习完了。接下来我们就要来学习多表的操作，首先来学习多表的设计。\n项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：\n一对多(多对一)\n多对多\n一对一\n2.1 一对多 2.1.1 表设计 需求：根据页面原型及需求文档 ，完成部门及员工的表结构设计\n员工管理页面原型：（前面已完成tb_emp表结构设计） 部门管理页面原型： 经过上述分析，现已明确的部门表结构：\n业务字段 ： 部门名称 基础字段 ： id(主键)、创建时间、修改时间 部门表 - SQL语句：\n1 2 3 4 5 6 7 8 9 10 11 12 # 建议：创建新的数据库（多表设计存放在新数据库下） create database db03; use db03; -- 部门表 create table tb_dept ( id int unsigned primary key auto_increment comment \u0026#39;主键ID\u0026#39;, name varchar(10) not null unique comment \u0026#39;部门名称\u0026#39;, create_time datetime not null comment \u0026#39;创建时间\u0026#39;, update_time datetime not null comment \u0026#39;修改时间\u0026#39; ) comment \u0026#39;部门表\u0026#39;; 部门表创建好之后，我们还需要再修改下员工表。为什么要修改员工表呢？是因为我们之前设计员工表(单表)的时候，并没有考虑员工的归属部门。\n员工表：添加归属部门字段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- 员工表 create table tb_emp ( id int unsigned primary key auto_increment comment \u0026#39;ID\u0026#39;, username varchar(20) not null unique comment \u0026#39;用户名\u0026#39;, password varchar(32) default \u0026#39;123456\u0026#39; comment \u0026#39;密码\u0026#39;, name varchar(10) not null comment \u0026#39;姓名\u0026#39;, gender tinyint unsigned not null comment \u0026#39;性别, 说明: 1 男, 2 女\u0026#39;, image varchar(300) comment \u0026#39;图像\u0026#39;, job tinyint unsigned comment \u0026#39;职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管\u0026#39;, entrydate date comment \u0026#39;入职时间\u0026#39;, dept_id int unsigned comment \u0026#39;部门ID\u0026#39;, -- 员工的归属部门 create_time datetime not null comment \u0026#39;创建时间\u0026#39;, update_time datetime not null comment \u0026#39;修改时间\u0026#39; ) comment \u0026#39;员工表\u0026#39;; 测试数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 -- 部门表测试数据 insert into tb_dept (id, name, create_time, update_time) values (1,\u0026#39;学工部\u0026#39;,now(),now()), (2,\u0026#39;教研部\u0026#39;,now(),now()), (3,\u0026#39;咨询部\u0026#39;,now(),now()), (4,\u0026#39;就业部\u0026#39;,now(),now()), (5,\u0026#39;人事部\u0026#39;,now(),now()); -- 员工表测试数据 INSERT INTO tb_emp (id, username, password, name, gender, image, job, entrydate,dept_id, create_time, update_time) VALUES (1,\u0026#39;jinyong\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;金庸\u0026#39;,1,\u0026#39;1.jpg\u0026#39;,4,\u0026#39;2000-01-01\u0026#39;,2,now(),now()), (2,\u0026#39;zhangwuji\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;张无忌\u0026#39;,1,\u0026#39;2.jpg\u0026#39;,2,\u0026#39;2015-01-01\u0026#39;,2,now(),now()), (3,\u0026#39;yangxiao\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;杨逍\u0026#39;,1,\u0026#39;3.jpg\u0026#39;,2,\u0026#39;2008-05-01\u0026#39;,2,now(),now()), (4,\u0026#39;weiyixiao\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;韦一笑\u0026#39;,1,\u0026#39;4.jpg\u0026#39;,2,\u0026#39;2007-01-01\u0026#39;,2,now(),now()), (5,\u0026#39;changyuchun\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;常遇春\u0026#39;,1,\u0026#39;5.jpg\u0026#39;,2,\u0026#39;2012-12-05\u0026#39;,2,now(),now()), (6,\u0026#39;xiaozhao\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;小昭\u0026#39;,2,\u0026#39;6.jpg\u0026#39;,3,\u0026#39;2013-09-05\u0026#39;,1,now(),now()), (7,\u0026#39;jixiaofu\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;纪晓芙\u0026#39;,2,\u0026#39;7.jpg\u0026#39;,1,\u0026#39;2005-08-01\u0026#39;,1,now(),now()), (8,\u0026#39;zhouzhiruo\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;周芷若\u0026#39;,2,\u0026#39;8.jpg\u0026#39;,1,\u0026#39;2014-11-09\u0026#39;,1,now(),now()), (9,\u0026#39;dingminjun\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;丁敏君\u0026#39;,2,\u0026#39;9.jpg\u0026#39;,1,\u0026#39;2011-03-11\u0026#39;,1,now(),now()), (10,\u0026#39;zhaomin\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;赵敏\u0026#39;,2,\u0026#39;10.jpg\u0026#39;,1,\u0026#39;2013-09-05\u0026#39;,1,now(),now()), (11,\u0026#39;luzhangke\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;鹿杖客\u0026#39;,1,\u0026#39;11.jpg\u0026#39;,1,\u0026#39;2007-02-01\u0026#39;,1,now(),now()), (12,\u0026#39;hebiweng\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;鹤笔翁\u0026#39;,1,\u0026#39;12.jpg\u0026#39;,1,\u0026#39;2008-08-18\u0026#39;,1,now(),now()), (13,\u0026#39;fangdongbai\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;方东白\u0026#39;,1,\u0026#39;13.jpg\u0026#39;,2,\u0026#39;2012-11-01\u0026#39;,2,now(),now()), (14,\u0026#39;zhangsanfeng\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;张三丰\u0026#39;,1,\u0026#39;14.jpg\u0026#39;,2,\u0026#39;2002-08-01\u0026#39;,2,now(),now()), (15,\u0026#39;yulianzhou\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;俞莲舟\u0026#39;,1,\u0026#39;15.jpg\u0026#39;,2,\u0026#39;2011-05-01\u0026#39;,2,now(),now()), (16,\u0026#39;songyuanqiao\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;宋远桥\u0026#39;,1,\u0026#39;16.jpg\u0026#39;,2,\u0026#39;2010-01-01\u0026#39;,2,now(),now()), (17,\u0026#39;chenyouliang\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;陈友谅\u0026#39;,1,\u0026#39;17.jpg\u0026#39;,NULL,\u0026#39;2015-03-21\u0026#39;,NULL,now(),now()); 员工表 - 部门表之间的关系：\n一对多关系实现：在数据库表中多的一方，添加字段，来关联属于一这方的主键。\n2.1.2 外键约束 问题\n表结构创建完毕后，我们看到两张表的数据分别为： 现在员工表中有五个员工都归属于1号部门(学工部)，当删除了1号部门后，数据变为：\n1号部门被删除了，但是依然还有5个员工是属于1号部门的。 此时：就出现数据的不完整、不一致了。\n问题分析\n目前上述的两张表(员工表、部门表)，在数据库层面，并未建立关联，所以是无法保证数据的一致性和完整性的\n问题解决\n想解决上述的问题呢，我们就可以通过数据库中的 外键约束 来解决。\n外键约束：让两张表的数据建立连接，保证数据的一致性和完整性。\n对应的关键字：foreign key\n外键约束的语法：\n1 2 3 4 5 6 7 8 9 10 -- 创建表时指定 create table 表名( 字段名 数据类型, ... [constraint] [外键名称] foreign key (外键字段名) references 主表 (主表列名)\t); -- 建完表后，添加外键 alter table 表名 add constraint 外键名称 foreign key(外键字段名) references 主表(主表列名); 那接下来，我们就为员工表的dept_id 建立外键约束，来关联部门表的主键。\n方式1：通过SQL语句操作\n1 2 3 -- 修改表： 添加外键约束 alter table tb_emp add constraint fk_dept_id foreign key (dept_id) references tb_dept(id); 方式2：图形化界面操作\n当我们添加外键约束时，我们得保证当前数据库表中的数据是完整的。 所以，我们需要将之前删除掉的数据再添加回来。\n当我们添加了外键之后，再删除ID为1的部门，就会发现，此时数据库报错了，不允许删除。\n外键约束（foreign key）：保证了数据的完整性和一致性。\n物理外键和逻辑外键\n物理外键\n概念：使用foreign key定义外键关联另外一张表。 缺点： 影响增、删、改的效率（需要检查外键关系）。 仅用于单节点数据库，不适用与分布式、集群场景。 容易引发数据库的死锁问题，消耗性能。 逻辑外键\n概念：在业务层逻辑中，解决外键关联。 通过逻辑外键，就可以很方便的解决上述问题。 **在现在的企业开发中，很少会使用物理外键，都是使用逻辑外键。 甚至在一些数据库开发规范中，会明确指出禁止使用物理外键 foreign key **\n2.2 一对一 一对一关系表在实际开发中应用起来比较简单，通常是用来做单表的拆分，也就是将一张大表拆分成两张小表，将大表中的一些基础字段放在一张表当中，将其他的字段放在另外一张表当中，以此来提高数据的操作效率。\n一对一的应用场景： 用户表(基本信息+身份信息)\n基本信息：用户的ID、姓名、性别、手机号、学历 身份信息：民族、生日、身份证号、身份证签发机关，身份证的有效期(开始时间、结束时间) 如果在业务系统当中，对用户的基本信息查询频率特别的高，但是对于用户的身份信息查询频率很低，此时出于提高查询效率的考虑，我就可以将这张大表拆分成两张小表，第一张表存放的是用户的基本信息，而第二张表存放的就是用户的身份信息。他们两者之间一对一的关系，一个用户只能对应一个身份证，而一个身份证也只能关联一个用户。\n那么在数据库层面怎么去体现上述两者之间是一对一的关系呢？\n其实一对一我们可以看成一种特殊的一对多。一对多我们是怎么设计表关系的？是不是在多的一方添加外键。同样我们也可以通过外键来体现一对一之间的关系，我们只需要在任意一方来添加一个外键就可以了。\n一对一 ：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)\nSQL脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 -- 用户基本信息表 create table tb_user( id int unsigned primary key auto_increment comment \u0026#39;ID\u0026#39;, name varchar(10) not null comment \u0026#39;姓名\u0026#39;, gender tinyint unsigned not null comment \u0026#39;性别, 1 男 2 女\u0026#39;, phone char(11) comment \u0026#39;手机号\u0026#39;, degree varchar(10) comment \u0026#39;学历\u0026#39; ) comment \u0026#39;用户基本信息表\u0026#39;; -- 测试数据 insert into tb_user values (1,\u0026#39;白眉鹰王\u0026#39;,1,\u0026#39;18812340001\u0026#39;,\u0026#39;初中\u0026#39;), (2,\u0026#39;青翼蝠王\u0026#39;,1,\u0026#39;18812340002\u0026#39;,\u0026#39;大专\u0026#39;), (3,\u0026#39;金毛狮王\u0026#39;,1,\u0026#39;18812340003\u0026#39;,\u0026#39;初中\u0026#39;), (4,\u0026#39;紫衫龙王\u0026#39;,2,\u0026#39;18812340004\u0026#39;,\u0026#39;硕士\u0026#39;); -- 用户身份信息表 create table tb_user_card( id int unsigned primary key auto_increment comment \u0026#39;ID\u0026#39;, nationality varchar(10) not null comment \u0026#39;民族\u0026#39;, birthday date not null comment \u0026#39;生日\u0026#39;, idcard char(18) not null comment \u0026#39;身份证号\u0026#39;, issued varchar(20) not null comment \u0026#39;签发机关\u0026#39;, expire_begin date not null comment \u0026#39;有效期限-开始\u0026#39;, expire_end date comment \u0026#39;有效期限-结束\u0026#39;, user_id int unsigned not null unique comment \u0026#39;用户ID\u0026#39;, constraint fk_user_id foreign key (user_id) references tb_user(id) ) comment \u0026#39;用户身份信息表\u0026#39;; -- 测试数据 insert into tb_user_card values (1,\u0026#39;汉\u0026#39;,\u0026#39;1960-11-06\u0026#39;,\u0026#39;100000100000100001\u0026#39;,\u0026#39;朝阳区公安局\u0026#39;,\u0026#39;2000-06-10\u0026#39;,null,1), (2,\u0026#39;汉\u0026#39;,\u0026#39;1971-11-06\u0026#39;,\u0026#39;100000100000100002\u0026#39;,\u0026#39;静安区公安局\u0026#39;,\u0026#39;2005-06-10\u0026#39;,\u0026#39;2025-06-10\u0026#39;,2), (3,\u0026#39;汉\u0026#39;,\u0026#39;1963-11-06\u0026#39;,\u0026#39;100000100000100003\u0026#39;,\u0026#39;昌平区公安局\u0026#39;,\u0026#39;2006-06-10\u0026#39;,null,3), (4,\u0026#39;回\u0026#39;,\u0026#39;1980-11-06\u0026#39;,\u0026#39;100000100000100004\u0026#39;,\u0026#39;海淀区公安局\u0026#39;,\u0026#39;2008-06-10\u0026#39;,\u0026#39;2028-06-10\u0026#39;,4); 2.3 多对多 多对多的关系在开发中属于也比较常见的。比如：学生和老师的关系，一个学生可以有多个授课老师，一个授课老师也可以有多个学生。在比如：学生和课程的关系，一个学生可以选修多门课程，一个课程也可以供多个学生选修。\n案例：学生与课程的关系\n关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择\n实现关系：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\nSQL脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 -- 学生表 create table tb_student( id int auto_increment primary key comment \u0026#39;主键ID\u0026#39;, name varchar(10) comment \u0026#39;姓名\u0026#39;, no varchar(10) comment \u0026#39;学号\u0026#39; ) comment \u0026#39;学生表\u0026#39;; -- 学生表测试数据 insert into tb_student(name, no) values (\u0026#39;黛绮丝\u0026#39;, \u0026#39;2000100101\u0026#39;),(\u0026#39;谢逊\u0026#39;, \u0026#39;2000100102\u0026#39;),(\u0026#39;殷天正\u0026#39;, \u0026#39;2000100103\u0026#39;),(\u0026#39;韦一笑\u0026#39;, \u0026#39;2000100104\u0026#39;); -- 课程表 create table tb_course( id int auto_increment primary key comment \u0026#39;主键ID\u0026#39;, name varchar(10) comment \u0026#39;课程名称\u0026#39; ) comment \u0026#39;课程表\u0026#39;; -- 课程表测试数据 insert into tb_course (name) values (\u0026#39;Java\u0026#39;), (\u0026#39;PHP\u0026#39;), (\u0026#39;MySQL\u0026#39;) , (\u0026#39;Hadoop\u0026#39;); -- 学生课程表（中间表） create table tb_student_course( id int auto_increment comment \u0026#39;主键\u0026#39; primary key, student_id int not null comment \u0026#39;学生ID\u0026#39;, course_id int not null comment \u0026#39;课程ID\u0026#39;, constraint fk_courseid foreign key (course_id) references tb_course (id), constraint fk_studentid foreign key (student_id) references tb_student (id) )comment \u0026#39;学生课程中间表\u0026#39;; -- 学生课程表测试数据 insert into tb_student_course(student_id, course_id) values (1,1),(1,2),(1,3),(2,2),(2,3),(3,4); 2.4 案例 下面通过一个综合案例加深对于多表关系的理解，并掌握多表设计的流程。\n需求\n根据参考资料中提供的《苍穹外卖_管理后台》页面原型，设计分类管理、菜品管理、套餐管理模块的表结构。 步骤\n阅读页面原型及需求文档，分析各个模块涉及到的表结构，及表结构之间的关系。\n根据页面原型及需求文档，分析各个表结构中具体的字段及约束。\n分析\n页面原型-分类管理 分类的信息：分类名称、分类类型[菜品/套餐]、分类排序、分类状态[禁用/启用]、分类的操作时间(修改时间)。\n页面原型-菜品管理 菜品的信息：菜品名称、菜品图片、菜品分类、菜品售价、菜品售卖状态、菜品的操作时间(修改时间)。\n思考：分类与菜品之间是什么关系？\n思考逻辑：一个分类下可以有多个菜品吗？反过来再想一想，一个菜品会对应多个分类吗？ 答案：一对多关系。一个分类下会有多个菜品，而一个菜品只能归属一个分类。\n设计表原则：在多的一方，添加字段，关联属于一这方的主键。\n页面原型-套餐管理 套餐的信息：套餐名称、套餐图片、套餐分类、套餐价格、套餐售卖状态、套餐的操作时间。\n思考：套餐与菜品之间是什么关系？\n思考逻辑：一个套餐下可以有多个菜品吗？反过来再想一想，一个菜品可以出现在多个套餐中吗？ 答案：多对多关系。一个套餐下会有多个菜品，而一个菜品也可以出现在多个套餐中。\n设计表原则：创建第三张中间表，建立两个字段分别关联菜品表的主键和套餐表的主键。\n分析页面原型及需求文档后，我们获得：\n分类表 业务字段：分类名称、分类类型、分类排序、分类状态 基础字段：id(主键)、分类的创建时间、分类的修改时间 菜品表 业务字段：菜品名称、菜品图片、菜品分类、菜品售价、菜品售卖状态 基础字段：id(主键)、分类的创建时间、分类的修改时间 套餐表 业务字段：套餐名称、套餐图片、套餐分类、套餐价格、套餐售卖状态 基础字段：id(主键)、分类的创建时间、分类的修改时间 表结构之间的关系：\n分类表 - 菜品表 ： 一对多 在菜品表中添加字段(菜品分类)，关联分类表 菜品表 - 套餐表 ： 多对多 创建第三张中间表(套餐菜品关联表)，在中间表上添加两个字段(菜品id、套餐id)，分别关联菜品表和分类表 表结构\n分类表：category\n业务字段：分类名称、分类类型、分类排序、分类状态 基础字段：id(主键)、创建时间、修改时间 1 2 3 4 5 6 7 8 9 10 11 -- 分类表 create table category ( id int unsigned primary key auto_increment comment \u0026#39;主键ID\u0026#39;, name varchar(20) not null unique comment \u0026#39;分类名称\u0026#39;, type tinyint unsigned not null comment \u0026#39;类型 1 菜品分类 2 套餐分类\u0026#39;, sort tinyint unsigned not null comment \u0026#39;顺序\u0026#39;, status tinyint unsigned not null default 0 comment \u0026#39;状态 0 禁用，1 启用\u0026#39;, create_time datetime not null comment \u0026#39;创建时间\u0026#39;, update_time datetime not null comment \u0026#39;更新时间\u0026#39; ) comment \u0026#39;菜品及套餐分类\u0026#39;; 菜品表：dish\n业务字段：菜品名称、菜品图片、菜品分类、菜品售价、菜品售卖状态 基础字段：id(主键)、分类的创建时间、分类的修改时间 1 2 3 4 5 6 7 8 9 10 11 12 13 -- 菜品表 create table dish ( id int unsigned primary key auto_increment comment \u0026#39;主键ID\u0026#39;, name varchar(20) not null unique comment \u0026#39;菜品名称\u0026#39;, category_id int unsigned not null comment \u0026#39;菜品分类ID\u0026#39;, -- 逻辑外键 price decimal(8, 2) not null comment \u0026#39;菜品价格\u0026#39;, image varchar(300) not null comment \u0026#39;菜品图片\u0026#39;, description varchar(200) comment \u0026#39;描述信息\u0026#39;, status tinyint unsigned not null default 0 comment \u0026#39;状态, 0 停售 1 起售\u0026#39;, create_time datetime not null comment \u0026#39;创建时间\u0026#39;, update_time datetime not null comment \u0026#39;更新时间\u0026#39; ) comment \u0026#39;菜品\u0026#39;; 套餐表：setmeal\n业务字段：套餐名称、套餐图片、套餐分类、套餐价格、套餐售卖状态 基础字段：id(主键)、分类的创建时间、分类的修改时间 1 2 3 4 5 6 7 8 9 10 11 12 13 -- 套餐表 create table setmeal ( id int unsigned primary key auto_increment comment \u0026#39;主键ID\u0026#39;, name varchar(20) not null unique comment \u0026#39;套餐名称\u0026#39;, category_id int unsigned not null comment \u0026#39;分类id\u0026#39;, -- 逻辑外键 price decimal(8, 2) not null comment \u0026#39;套餐价格\u0026#39;, image varchar(300) not null comment \u0026#39;图片\u0026#39;, description varchar(200) comment \u0026#39;描述信息\u0026#39;, status tinyint unsigned not null default 0 comment \u0026#39;状态 0:停用 1:启用\u0026#39;, create_time datetime not null comment \u0026#39;创建时间\u0026#39;, update_time datetime not null comment \u0026#39;更新时间\u0026#39; ) comment \u0026#39;套餐\u0026#39;; 套餐菜品关联表：setmeal_dish\n1 2 3 4 5 6 7 8 -- 套餐菜品关联表 create table setmeal_dish ( id int unsigned primary key auto_increment comment \u0026#39;主键ID\u0026#39;, setmeal_id int unsigned not null comment \u0026#39;套餐id \u0026#39;, -- 逻辑外键 dish_id int unsigned not null comment \u0026#39;菜品id\u0026#39;, -- 逻辑外键 copies tinyint unsigned not null comment \u0026#39;份数\u0026#39; ) comment \u0026#39;套餐菜品关联表\u0026#39;; ","date":"2024-07-05T22:27:20+08:00","image":"https://picsum.photos/800/600 ","permalink":"https://4evergreat.github.io/2024/mysql-blog-3/","title":"mysql中级2"},{"content":"数据库开发-MySQL 1. 多表查询 1.1 概述 1.1.1 数据准备 SQL脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #建议：创建新的数据库 create database db04; use db04; -- 部门表 create table tb_dept ( id int unsigned primary key auto_increment comment \u0026#39;主键ID\u0026#39;, name varchar(10) not null unique comment \u0026#39;部门名称\u0026#39;, create_time datetime not null comment \u0026#39;创建时间\u0026#39;, update_time datetime not null comment \u0026#39;修改时间\u0026#39; ) comment \u0026#39;部门表\u0026#39;; -- 部门表测试 insert into tb_dept (id, name, create_time, update_time) values (1, \u0026#39;学工部\u0026#39;, now(), now()), (2, \u0026#39;教研部\u0026#39;, now(), now()), (3, \u0026#39;咨询部\u0026#39;, now(), now()), (4, \u0026#39;就业部\u0026#39;, now(), now()), (5, \u0026#39;人事部\u0026#39;, now(), now()); -- 员工表 create table tb_emp ( id int unsigned primary key auto_increment comment \u0026#39;ID\u0026#39;, username varchar(20) not null unique comment \u0026#39;用户名\u0026#39;, password varchar(32) default \u0026#39;123456\u0026#39; comment \u0026#39;密码\u0026#39;, name varchar(10) not null comment \u0026#39;姓名\u0026#39;, gender tinyint unsigned not null comment \u0026#39;性别, 说明: 1 男, 2 女\u0026#39;, image varchar(300) comment \u0026#39;图像\u0026#39;, job tinyint unsigned comment \u0026#39;职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管, 5 咨询师\u0026#39;, entrydate date comment \u0026#39;入职时间\u0026#39;, dept_id int unsigned comment \u0026#39;部门ID\u0026#39;, create_time datetime not null comment \u0026#39;创建时间\u0026#39;, update_time datetime not null comment \u0026#39;修改时间\u0026#39; ) comment \u0026#39;员工表\u0026#39;; -- 员工表测试数据 INSERT INTO tb_emp(id, username, password, name, gender, image, job, entrydate,dept_id, create_time, update_time) VALUES (1,\u0026#39;jinyong\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;金庸\u0026#39;,1,\u0026#39;1.jpg\u0026#39;,4,\u0026#39;2000-01-01\u0026#39;,2,now(),now()), (2,\u0026#39;zhangwuji\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;张无忌\u0026#39;,1,\u0026#39;2.jpg\u0026#39;,2,\u0026#39;2015-01-01\u0026#39;,2,now(),now()), (3,\u0026#39;yangxiao\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;杨逍\u0026#39;,1,\u0026#39;3.jpg\u0026#39;,2,\u0026#39;2008-05-01\u0026#39;,2,now(),now()), (4,\u0026#39;weiyixiao\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;韦一笑\u0026#39;,1,\u0026#39;4.jpg\u0026#39;,2,\u0026#39;2007-01-01\u0026#39;,2,now(),now()), (5,\u0026#39;changyuchun\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;常遇春\u0026#39;,1,\u0026#39;5.jpg\u0026#39;,2,\u0026#39;2012-12-05\u0026#39;,2,now(),now()), (6,\u0026#39;xiaozhao\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;小昭\u0026#39;,2,\u0026#39;6.jpg\u0026#39;,3,\u0026#39;2013-09-05\u0026#39;,1,now(),now()), (7,\u0026#39;jixiaofu\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;纪晓芙\u0026#39;,2,\u0026#39;7.jpg\u0026#39;,1,\u0026#39;2005-08-01\u0026#39;,1,now(),now()), (8,\u0026#39;zhouzhiruo\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;周芷若\u0026#39;,2,\u0026#39;8.jpg\u0026#39;,1,\u0026#39;2014-11-09\u0026#39;,1,now(),now()), (9,\u0026#39;dingminjun\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;丁敏君\u0026#39;,2,\u0026#39;9.jpg\u0026#39;,1,\u0026#39;2011-03-11\u0026#39;,1,now(),now()), (10,\u0026#39;zhaomin\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;赵敏\u0026#39;,2,\u0026#39;10.jpg\u0026#39;,1,\u0026#39;2013-09-05\u0026#39;,1,now(),now()), (11,\u0026#39;luzhangke\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;鹿杖客\u0026#39;,1,\u0026#39;11.jpg\u0026#39;,5,\u0026#39;2007-02-01\u0026#39;,3,now(),now()), (12,\u0026#39;hebiweng\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;鹤笔翁\u0026#39;,1,\u0026#39;12.jpg\u0026#39;,5,\u0026#39;2008-08-18\u0026#39;,3,now(),now()), (13,\u0026#39;fangdongbai\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;方东白\u0026#39;,1,\u0026#39;13.jpg\u0026#39;,5,\u0026#39;2012-11-01\u0026#39;,3,now(),now()), (14,\u0026#39;zhangsanfeng\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;张三丰\u0026#39;,1,\u0026#39;14.jpg\u0026#39;,2,\u0026#39;2002-08-01\u0026#39;,2,now(),now()), (15,\u0026#39;yulianzhou\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;俞莲舟\u0026#39;,1,\u0026#39;15.jpg\u0026#39;,2,\u0026#39;2011-05-01\u0026#39;,2,now(),now()), (16,\u0026#39;songyuanqiao\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;宋远桥\u0026#39;,1,\u0026#39;16.jpg\u0026#39;,2,\u0026#39;2007-01-01\u0026#39;,2,now(),now()), (17,\u0026#39;chenyouliang\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;陈友谅\u0026#39;,1,\u0026#39;17.jpg\u0026#39;,NULL,\u0026#39;2015-03-21\u0026#39;,NULL,now(),now()); 1.1.2 介绍 多表查询：查询时从多张表中获取所需数据\n单表查询的SQL语句：select 字段列表 from 表名;\n那么要执行多表查询，只需要使用逗号分隔多张表即可，如： select 字段列表 from 表1, 表2;\n查询用户表和部门表中的数据：\n1 select * from tb_emp , tb_dept; 此时,我们看到查询结果中包含了大量的结果集，总共85条记录，而这其实就是员工表所有的记录(17行)与部门表所有记录(5行)的所有组合情况，这种现象称之为笛卡尔积。\n笛卡尔积：笛卡尔乘积是指在数学中，两个集合(A集合和B集合)的所有组合情况。\n在多表查询时，需要消除无效的笛卡尔积，只保留表关联部分的数据\n在SQL语句中，如何去除无效的笛卡尔积呢？只需要给多表查询加上连接查询的条件即可。\n1 select * from tb_emp , tb_dept where tb_emp.dept_id = tb_dept.id ; 由于id为17的员工，没有dept_id字段值，所以在多表查询时，根据连接查询的条件并没有查询到。\n1.1.3 分类 多表查询可以分为：\n连接查询\n内连接：相当于查询A、B交集部分数据 外连接\n左外连接：查询左表所有数据(包括两张表交集部分数据)\n右外连接：查询右表所有数据(包括两张表交集部分数据)\n子查询\n1.2 内连接 内连接查询：查询两表或多表中交集部分数据。\n内连接从语法上可以分为：\n隐式内连接\n显式内连接\n隐式内连接语法：\n1 select 字段列表 from 表1 , 表2 where 条件 ... ; 显式内连接语法：\n1 select 字段列表 from 表1 [ inner ] join 表2 on 连接条件 ... ; 案例：查询员工的姓名及所属的部门名称\n隐式内连接实现 1 2 3 select tb_emp.name , tb_dept.name -- 分别查询两张表中的数据 from tb_emp , tb_dept -- 关联两张表 where tb_emp.dept_id = tb_dept.id; -- 消除笛卡尔积 显式内连接实现 1 2 3 select tb_emp.name , tb_dept.name from tb_emp inner join tb_dept on tb_emp.dept_id = tb_dept.id; 多表查询时给表起别名：\ntableA as 别名1 , tableB as 别名2 ;\ntableA 别名1 , tableB 别名2 ;\n使用了别名的多表查询：\n1 2 3 select emp.name , dept.name from tb_emp emp inner join tb_dept dept on emp.dept_id = dept.id; 注意事项:\n一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字段。\n1.3 外连接 外连接分为两种：左外连接 和 右外连接。\n左外连接语法结构：\n1 select 字段列表 from 表1 left [ outer ] join 表2 on 连接条件 ... ; 左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。\n右外连接语法结构：\n1 select 字段列表 from 表1 right [ outer ] join 表2 on 连接条件 ... ; 右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。\n案例：查询员工表中所有员工的姓名, 和对应的部门名称\n1 2 3 4 -- 左外连接：以left join关键字左边的表为主表，查询主表中所有数据，以及和主表匹配的右边表中的数据 select emp.name , dept.name from tb_emp AS emp left join tb_dept AS dept on emp.dept_id = dept.id; 案例：查询部门表中所有部门的名称, 和对应的员工名称\n1 2 3 4 -- 右外连接 select dept.name , emp.name from tb_emp AS emp right join tb_dept AS dept on emp.dept_id = dept.id; 注意事项：\n左外连接和右外连接是可以相互替换的，只需要调整连接查询时SQL语句中表的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接。\n1.4 子查询 1.4.1 介绍 SQL语句中嵌套select语句，称为嵌套查询，又称子查询。\n1 SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 ... ); 子查询外部的语句可以是insert / update / delete / select 的任何一个，最常见的是 select。\n根据子查询结果的不同分为：\n标量子查询（子查询结果为单个值[一行一列]）\n列子查询（子查询结果为一列，但可以是多行）\n行子查询（子查询结果为一行，但可以是多列）\n表子查询（子查询结果为多行多列[相当于子查询结果是一张表]）\n子查询可以书写的位置：\nwhere之后 from之后 select之后 1.4.2 标量子查询 子查询返回的结果是单个值(数字、字符串、日期等)，最简单的形式，这种子查询称为标量子查询。\n常用的操作符： = \u0026lt;\u0026gt; \u0026gt; \u0026gt;= \u0026lt; \u0026lt;=\n案例1：查询\u0026quot;教研部\u0026quot;的所有员工信息\n可以将需求分解为两步：\n查询 \u0026ldquo;教研部\u0026rdquo; 部门ID 根据 \u0026ldquo;教研部\u0026rdquo; 部门ID，查询员工信息 1 2 3 4 5 6 7 -- 1.查询\u0026#34;教研部\u0026#34;部门ID select id from tb_dept where name = \u0026#39;教研部\u0026#39;; #查询结果：2 -- 2.根据\u0026#34;教研部\u0026#34;部门ID, 查询员工信息 select * from tb_emp where dept_id = 2; -- 合并出上两条SQL语句 select * from tb_emp where dept_id = (select id from tb_dept where name = \u0026#39;教研部\u0026#39;); 案例2：查询在 \u0026ldquo;方东白\u0026rdquo; 入职之后的员工信息\n可以将需求分解为两步：\n查询 方东白 的入职日期 查询 指定入职日期之后入职的员工信息 1 2 3 4 5 6 7 -- 1.查询\u0026#34;方东白\u0026#34;的入职日期 select entrydate from tb_emp where name = \u0026#39;方东白\u0026#39;; #查询结果：2012-11-01 -- 2.查询指定入职日期之后入职的员工信息 select * from tb_emp where entrydate \u0026gt; \u0026#39;2012-11-01\u0026#39;; -- 合并以上两条SQL语句 select * from tb_emp where entrydate \u0026gt; (select entrydate from tb_emp where name = \u0026#39;方东白\u0026#39;); 1.4.3 列子查询 子查询返回的结果是一列(可以是多行)，这种子查询称为列子查询。\n常用的操作符：\n操作符 描述 IN 在指定的集合范围之内，多选一 NOT IN 不在指定的集合范围之内 案例：查询\u0026quot;教研部\u0026quot;和\u0026quot;咨询部\u0026quot;的所有员工信息\n分解为以下两步：\n查询 \u0026ldquo;销售部\u0026rdquo; 和 \u0026ldquo;市场部\u0026rdquo; 的部门ID 根据部门ID, 查询员工信息 1 2 3 4 5 6 7 -- 1.查询\u0026#34;销售部\u0026#34;和\u0026#34;市场部\u0026#34;的部门ID select id from tb_dept where name = \u0026#39;教研部\u0026#39; or name = \u0026#39;咨询部\u0026#39;; #查询结果：3,2 -- 2.根据部门ID, 查询员工信息 select * from tb_emp where dept_id in (3,2); -- 合并以上两条SQL语句 select * from tb_emp where dept_id in (select id from tb_dept where name = \u0026#39;教研部\u0026#39; or name = \u0026#39;咨询部\u0026#39;); 1.4.4 行子查询 子查询返回的结果是一行(可以是多列)，这种子查询称为行子查询。\n常用的操作符：= 、\u0026lt;\u0026gt; 、IN 、NOT IN\n案例：查询与\u0026quot;韦一笑\u0026quot;的入职日期及职位都相同的员工信息\n可以拆解为两步进行：\n查询 \u0026ldquo;韦一笑\u0026rdquo; 的入职日期 及 职位 查询与\u0026quot;韦一笑\u0026quot;的入职日期及职位相同的员工信息 1 2 3 4 5 6 7 -- 查询\u0026#34;韦一笑\u0026#34;的入职日期 及 职位 select entrydate , job from tb_emp where name = \u0026#39;韦一笑\u0026#39;; #查询结果： 2007-01-01 , 2 -- 查询与\u0026#34;韦一笑\u0026#34;的入职日期及职位相同的员工信息 select * from tb_emp where (entrydate,job) = (\u0026#39;2007-01-01\u0026#39;,2); -- 合并以上两条SQL语句 select * from tb_emp where (entrydate,job) = (select entrydate , job from tb_emp where name = \u0026#39;韦一笑\u0026#39;); 1.4.5 表子查询 子查询返回的结果是多行多列，常作为临时表，这种子查询称为表子查询。\n案例：查询入职日期是 \u0026ldquo;2006-01-01\u0026rdquo; 之后的员工信息 , 及其部门信息\n分解为两步执行：\n查询入职日期是 \u0026ldquo;2006-01-01\u0026rdquo; 之后的员工信息 基于查询到的员工信息，在查询对应的部门信息 1 2 3 select * from emp where entrydate \u0026gt; \u0026#39;2006-01-01\u0026#39;; select e.*, d.* from (select * from emp where entrydate \u0026gt; \u0026#39;2006-01-01\u0026#39;) e left join dept d on e.dept_id = d.id ; 1.5 案例 基于之前设计的多表案例的表结构，我们来完成今天的多表查询案例需求。\n准备环境\n将资料中准备好的多表查询的数据准备的SQL脚本导入数据库中。\n分类表：category 菜品表：dish 套餐表：setmeal 套餐菜品关系表：setmeal_dish 需求实现\n查询价格低于 10元 的菜品的名称 、价格 及其 菜品的分类名称 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /*查询技巧： 明确1：查询需要用到哪些字段 菜品名称、菜品价格 、 菜品分类名 明确2：查询的字段分别归属于哪张表 菜品表：[菜品名称、菜品价格] 分类表：[分类名] 明确3：如查多表，建立表与表之间的关联 菜品表.caategory_id = 分类表.id 其他：（其他条件、其他要求） 价格 \u0026lt; 10 */ select d.name , d.price , c.name from dish AS d , category AS c where d.category_id = c.id and d.price \u0026lt; 10; 查询所有价格在 10元(含)到50元(含)之间 且 状态为\u0026quot;起售\u0026quot;的菜品名称、价格及其分类名称 (即使菜品没有分类 , 也要将菜品查询出来) 1 2 3 4 select d.name , d.price, c.name from dish AS d left join category AS c on d.category_id = c.id where d.price between 10 and 50 and d.status = 1; 查询每个分类下最贵的菜品, 展示出分类的名称、最贵的菜品的价格 1 2 3 4 select c.name , max(d.price) from dish AS d , category AS c where d.category_id = c.id group by c.name; 查询各个分类下 菜品状态为 \u0026ldquo;起售\u0026rdquo; , 并且 该分类下菜品总数量大于等于3 的 分类名称 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /*查询技巧： 明确1：查询需要用到哪些字段 分类名称、菜品总数量 明确2：查询用到的字段分别归属于哪张表 分类表：[分类名] 菜品表：[菜品状态] 明确3：如查多表，建立表与表之间的关联 菜品表.caategory_id = 分类表.id 其他：（其他条件、其他要求） 条件：菜品状态 = 1 (1表示起售) 分组：分类名 分组后条件： 总数量 \u0026gt;= 3 */ select c.name , count(*) from dish AS d , category AS c where d.category_id = c.id and d.status = 1 -- 起售状态 group by c.name -- 按照分类名分组 having count(*)\u0026gt;=3; -- 各组后筛选菜品总数据\u0026gt;=3 查询出 \u0026ldquo;商务套餐A\u0026rdquo; 中包含了哪些菜品 （展示出套餐名称、价格, 包含的菜品名称、价格、份数） 1 2 3 4 select s.name, s.price, d.name, d.price, sd.copies from setmeal AS s , setmeal_dish AS sd , dish AS d where s.id = sd.setmeal_id and sd.dish_id = d.id and s.name=\u0026#39;商务套餐A\u0026#39;; 查询出低于菜品平均价格的菜品信息 (展示出菜品名称、菜品价格) 1 2 3 4 5 6 7 -- 1.计算菜品平均价格 select avg(price) from dish; -- 查询结果：37.736842 -- 2.查询出低于菜品平均价格的菜品信息 select * from dish where price \u0026lt; 37.736842; -- 合并以上两条SQL语句 select * from dish where price \u0026lt; (select avg(price) from dish); 2. 事务 场景：学工部整个部门解散了，该部门及部门下的员工都需要删除了。\n操作：\n1 2 3 4 5 -- 删除学工部 delete from dept where id = 1; -- 删除成功 -- 删除学工部的员工 delete from emp where dept_id = 1; -- 删除失败（操作过程中出现错误：造成删除没有成功） 问题：如果删除部门成功了，而删除该部门的员工时失败了，此时就造成了数据的不一致。\n​\t要解决上述的问题，就需要通过数据库中的事务来解决。\n2.1 介绍 在实际的业务开发中，有些业务操作要多次访问数据库。一个业务要发送多条SQL语句给数据库执行。需要将多次访问数据库的操作视为一个整体来执行，要么所有的SQL语句全部执行成功。如果其中有一条SQL语句失败，就进行事务的回滚，所有的SQL语句全部执行失败。\n简而言之：事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。\n事务作用：保证在一个事务中多次操作数据库表中数据时，要么全都成功,要么全都失败。\n2.2 操作 MYSQL中有两种方式进行事务的操作：\n自动提交事务：即执行一条sql语句提交一次事务。（默认MySQL的事务是自动提交） 手动提交事务：先开启，再提交 事务操作有关的SQL语句：\nSQL语句 描述 start transaction; / begin ; 开启手动控制事务 commit; 提交事务 rollback; 回滚事务 手动提交事务使用步骤：\n第1种情况：开启事务 =\u0026gt; 执行SQL语句 =\u0026gt; 成功 =\u0026gt; 提交事务 第2种情况：开启事务 =\u0026gt; 执行SQL语句 =\u0026gt; 失败 =\u0026gt; 回滚事务 使用事务控制删除部门和删除该部门下的员工的操作：\n1 2 3 4 5 6 7 8 -- 开启事务 start transaction ; -- 删除学工部 delete from tb_dept where id = 1; -- 删除学工部的员工 delete from tb_emp where dept_id = 1; 上述的这组SQL语句，如果如果执行成功，则提交事务 1 2 -- 提交事务 (成功时执行) commit ; 上述的这组SQL语句，如果如果执行失败，则回滚事务 1 2 -- 回滚事务 (出错时执行) rollback ; 2.3 四大特性 面试题：事务有哪些特性？\n原子性（Atomicity）：事务是不可分割的最小单元，要么全部成功，要么全部失败。 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。 事务的四大特性简称为：ACID\n原子性（Atomicity） ：原子性是指事务包装的一组sql是一个不可分割的工作单元，事务中的操作要么全部成功，要么全部失败。\n一致性（Consistency）：一个事务完成之后数据都必须处于一致性状态。\n​\t如果事务成功的完成，那么数据库的所有变化将生效。\n​\t如果事务执行出现错误，那么数据库的所有变化将会被回滚(撤销)，返回到原始状态。\n隔离性（Isolation）：多个用户并发的访问数据库时，一个用户的事务不能被其他用户的事务干扰，多个并发的事务之间要相互隔离。 ​\t一个事务的成功或者失败对于其他的事务是没有影响。\n持久性（Durability）：一个事务一旦被提交或回滚，它对数据库的改变将是永久性的，哪怕数据库发生异常，重启之后数据亦然存在。 3. 索引 3.1 介绍 索引(index)：是帮助数据库高效获取数据的数据结构 。\n简单来讲，就是使用索引可以提高查询的效率。 测试没有使用索引的查询：\n添加索引后查询：\n1 2 3 4 5 -- 添加索引 create index idx_sku_sn on tb_sku (sn); #在添加索引时，也需要消耗时间 -- 查询数据（使用了索引） select * from tb_sku where sn = \u0026#39;100000003145008\u0026#39;; 优点：\n提高数据查询的效率，降低数据库的IO成本。 通过索引列对数据进行排序，降低数据排序的成本，降低CPU消耗。 缺点：\n索引会占用存储空间。 索引大大提高了查询效率，同时却也降低了insert、update、delete的效率。 3.2 结构 MySQL数据库支持的索引结构有很多，如：Hash索引、B+Tree索引、Full-Text索引等。\n我们平常所说的索引，如果没有特别指明，都是指默认的 B+Tree 结构组织的索引。\n在没有了解B+Tree结构前，我们先回顾下之前所学习的树结构：\n二叉查找树：左边的子节点比父节点小，右边的子节点比父节点大\n当我们向二叉查找树保存数据时，是按照从大到小(或从小到大)的顺序保存的，此时就会形成一个单向链表，搜索性能会打折扣。\n可以选择平衡二叉树或者是红黑树来解决上述问题。（红黑树也是一棵平衡的二叉树）\n但是在Mysql数据库中并没有使用二叉搜索数或二叉平衡数或红黑树来作为索引的结构。\n思考：采用二叉搜索树或者是红黑树来作为索引的结构有什么问题？\n答案\r最大的问题就是在数据量大的情况下，树的层级比较深，会影响检索速度。因为不管是二叉搜索数还是红黑数，一个节点下面只能有两个子节点。此时在数据量大的情况下，就会造成数的高度比较高，树的高度一旦高了，检索速度就会降低。\r说明：如果数据结构是红黑树，那么查询1000万条数据，根据计算树的高度大概是23左右，这样确实比之前的方式快了很多，但是如果高并发访问，那么一个用户有可能需要23次磁盘IO，那么100万用户，那么会造成效率极其低下。所以为了减少红黑树的高度，那么就得增加树的宽度，就是不再像红黑树一样每个节点只能保存一个数据，可以引入另外一种数据结构，一个节点可以保存多个数据，这样宽度就会增加从而降低树的高度。这种数据结构例如BTree就满足。\n下面我们来看看B+Tree(多路平衡搜索树)结构中如何避免这个问题：\nB+Tree结构：\n每一个节点，可以存储多个key（有n个key，就有n个指针） 节点分为：叶子节点、非叶子节点 叶子节点，就是最后一层子节点，所有的数据都存储在叶子节点上 非叶子节点，不是树结构最下面的节点，用于索引数据，存储的的是：key+指针 为了提高范围查询效率，叶子节点形成了一个双向链表，便于数据的排序及区间范围查询 拓展：\n非叶子节点都是由key+指针域组成的，一个key占8字节，一个指针占6字节，而一个节点总共容量是16KB，那么可以计算出一个节点可以存储的元素个数：16*1024字节 / (8+6)=1170个元素。\n查看mysql索引节点大小：show global status like \u0026lsquo;innodb_page_size\u0026rsquo;; \u0026ndash; 节点大小：16384 当根节点中可以存储1170个元素，那么根据每个元素的地址值又会找到下面的子节点，每个子节点也会存储1170个元素，那么第二层即第二次IO的时候就会找到数据大概是：1170*1170=135W。也就是说B+Tree数据结构中只需要经历两次磁盘IO就可以找到135W条数据。\n对于第二层每个元素有指针，那么会找到第三层，第三层由key+数据组成，假设key+数据总大小是1KB，而每个节点一共能存储16KB，所以一个第三层一个节点大概可以存储16个元素(即16条记录)。那么结合第二层每个元素通过指针域找到第三层的节点，第二层一共是135W个元素，那么第三层总元素大小就是：135W*16结果就是2000W+的元素个数。\n结合上述分析B+Tree有如下优点：\n千万条数据，B+Tree可以控制在小于等于3的高度 所有的数据都存储在叶子节点上，并且底层已经实现了按照索引进行排序，还可以支持范围查询，叶子节点是一个双向链表，支持从小到大或者从大到小查找 3.3 语法 创建索引\n1 create [ unique ] index 索引名 on 表名 (字段名,... ) ; 案例：为tb_emp表的name字段建立一个索引\n1 create index idx_emp_name on tb_emp(name); 在创建表时，如果添加了主键和唯一约束，就会默认创建：主键索引、唯一约束\n查看索引\n1 show index from 表名; 案例：查询 tb_emp 表的索引信息\n1 show index from tb_emp; 删除索引\n1 drop index 索引名 on 表名; 案例：删除 tb_emp 表中name字段的索引\n1 drop index idx_emp_name on tb_emp; 注意事项：\n主键字段，在建表时，会自动创建主键索引\n添加唯一约束时，数据库实际上会添加唯一索引\n","date":"2024-07-05T22:27:20+08:00","image":"https://picsum.photos/800/600 ","permalink":"https://4evergreat.github.io/2024/mysql-blog-4/","title":"mysql中级4"},{"content":"SpringBoot基础 课程内容 SpringBootWeb入门\nHTTP协议\nWeb服务器-Tomcat\n前言 下面我们将进入SpringBoot基础阶段的学习。\n在没有正式的学习SpringBoot之前，我们要先来了解下什么是Spring。\n我们可以打开Spring的官网(https://spring.io)，去看一下Spring的简介：Spring makes Java simple。\nSpring的官方提供很多开源的项目，我们可以点击上面的projects，看到spring家族旗下的项目，按照流行程度排序为：\nSpring发展到今天已经形成了一种开发生态圈，Spring提供了若干个子项目，每个项目用于完成特定的功能。而我们在项目开发时，一般会偏向于选择这一套spring家族的技术，来解决对应领域的问题，那我们称这一套技术为spring全家桶。\n而Spring家族旗下这么多的技术，最基础、最核心的是 SpringFramework。其他的spring家族的技术，都是基于SpringFramework的，SpringFramework中提供很多实用功能，如：依赖注入、事务管理、web开发支持、数据访问、消息服务等等。\n而如果我们在项目中，直接基于SpringFramework进行开发，存在两个问题：配置繁琐、入门难度大。\n所以基于此呢，spring官方推荐我们从另外一个项目开始学习，那就是目前最火爆的SpringBoot。\n通过springboot就可以快速的帮我们构建应用程序，所以springboot呢，最大的特点有两个 ：\n简化配置 快速开发 Spring Boot 可以帮助我们非常快速的构建应用程序、简化开发、提高效率 。\n接下来，我们就直接通过一个SpringBoot的web入门程序，让大家快速感受一下，基于SpringBoot进行Web开发的便捷性。\n1. SpringBootWeb快速入门 1.1 需求 需求：基于SpringBoot的方式开发一个web应用，浏览器发起请求/hello后，给浏览器返回字符串 “Hello World ~”。\n1.2 开发步骤 第1步：创建SpringBoot工程项目\n第2步：定义HelloController类，添加方法hello，并添加注解\n第3步：测试运行\n1.2.1 创建SpringBoot工程（需要联网） 基于Spring官方骨架，创建SpringBoot工程。\n基本信息描述完毕之后，勾选web开发相关依赖。\n点击Finish之后，就会联网创建这个SpringBoot工程，创建好之后，结构如下：\n==注意：在联网创建过程中，会下载相关资源(请耐心等待)== 1.2.2 定义请求处理类 在com.itheima这个包下创建一个子包controller\n然后在controller包下新建一个类：HelloController\n1 2 3 4 5 6 7 8 9 10 11 12 13 package com.itheima.controller; import org.springframework.web.bind.annotation.*; @RestController public class HelloController { @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(){ System.out.println(\u0026#34;Hello World ~\u0026#34;); return \u0026#34;Hello World ~\u0026#34;; } } 1.2.3 运行测试 运行SpringBoot自动生成的引导类\n打开浏览器，输入 http://localhost:8080/hello\n1.3 Web分析 浏览器：\n输入网址：http://192.168.100.11:8080/hello\n通过IP地址192.168.100.11定位到网络上的一台计算机\n我们之前在浏览器中输入的localhost，就是127.0.0.1（本机）\n通过端口号8080找到计算机上运行的程序\nlocalhost:8080 , 意思是在本地计算机中找到正在运行的8080端口的程序\n/hello是请求资源位置\n资源：对计算机而言资源就是数据 web资源：通过网络可以访问到的资源（通常是指存放在服务器上的数据） localhost:8080/hello ，意思是向本地计算机中的8080端口程序，获取资源位置是/hello的数据\n8080端口程序，在服务器找/hello位置的资源数据，发给浏览器 服务器：（可以理解为ServerSocket）\n接收到浏览器发送的信息（如：/hello） 在服务器上找到/hello的资源 把资源发送给浏览器 我们在JavaSE阶段学习网络编程时，有讲过网络三要素：\nIP ：网络中计算机的唯一标识 端口 ：计算机中运行程序的唯一标识 协议 ：网络中计算机之间交互的规则 问题：浏览器和服务器两端进行数据交互，使用什么协议？\n答案：http协议\n2. HTTP协议 2.1 HTTP-概述 2.1.1 介绍 HTTP：Hyper Text Transfer Protocol(超文本传输协议)，规定了浏览器与服务器之间数据传输的规则。\nhttp是互联网上应用最为广泛的一种网络协议 http协议要求：浏览器在向服务器发送请求数据时，或是服务器在向浏览器发送响应数据时，都必须按照固定的格式进行数据传输 如果想知道http协议的数据传输格式有哪些，可以打开浏览器，点击F12打开开发者工具，点击Network来查看\n浏览器向服务器进行请求时：\n服务器按照固定的格式进行解析 服务器向浏览器进行响应时：\n浏览器按照固定的格式进行解析 所以，我们学习HTTP主要就是学习请求和响应数据的具体格式内容。\n2.2.2 特点 我们刚才初步认识了HTTP协议，那么我们在看看HTTP协议有哪些特点：\n**基于TCP协议: ** 面向连接，安全\nTCP是一种面向连接的(建立连接之前是需要经过三次握手)、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全\n基于请求-响应模型: 一次请求对应一次响应（先请求后响应）\n请求和响应是一一对应关系，没有请求，就没有响应\nHTTP协议是无状态协议: 对于数据没有记忆能力。每次请求-响应都是独立的\n无状态指的是客户端发送HTTP请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。\n缺点: 多次请求间不能共享数据 优点: 速度快 请求之间无法共享数据会引发的问题：\n如：京东购物。加入购物车和去购物车结算是两次请求 由于HTTP协议的无状态特性，加入购物车请求响应结束后，并未记录加入购物车是何商品 发起去购物车结算的请求后，因为无法获取哪些商品加入了购物车，会导致此次请求无法正确展示数据 具体使用的时候，我们发现京东是可以正常展示数据的，原因是Java早已考虑到这个问题，并提出了使用会话技术(Cookie、Session)来解决这个问题。具体如何来做，我们后面课程中会讲到。\n刚才提到HTTP协议是规定了请求和响应数据的格式，那具体的格式是什么呢?\n2.2 HTTP-请求协议 浏览器和服务器是按照HTTP协议进行数据通信的。\nHTTP协议又分为：请求协议和响应协议\n请求协议：浏览器将数据以请求格式发送到服务器 包括：请求行、请求头 、请求体 响应协议：服务器将数据以响应格式返回给浏览器 包括：响应行 、响应头 、响应体 在HTTP1.1版本中，浏览器访问服务器的几种方式：\n请求方式 请求说明 GET 获取资源。向特定的资源发出请求。例：http://www.baidu.com/s?wd=itheima POST 传输实体主体。向指定资源提交数据进行处理请求（例：上传文件），数据被包含在请求体中。 OPTIONS 返回服务器针对特定资源所支持的HTTP请求方式。因为并不是所有的服务器都支持规定的方法，为了安全有些服务器可能会禁止掉一些方法，例如：DELETE、PUT等。那么OPTIONS就是用来询问服务器支持的方法。 HEAD 获得报文首部。HEAD方法类似GET方法，但是不同的是HEAD方法不要求返回数据。通常用于确认URI的有效性及资源更新时间等。 PUT 传输文件。PUT方法用来传输文件。类似FTP协议，文件内容包含在请求报文的实体中，然后请求保存到URL指定的服务器位置。 DELETE 删除文件。请求服务器删除Request-URI所标识的资源 TRACE 追踪路径。回显服务器收到的请求，主要用于测试或诊断 CONNECT 要求用隧道协议连接代理。HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器 在我们实际应用中常用的也就是 ：GET、POST\nGET方式的请求协议：\n请求行 ：HTTP请求中的第一行数据。由：请求方式、资源路径、协议/版本组成（之间使用空格分隔）\n请求方式：GET 资源路径：/brand/findAll?name=OPPO\u0026amp;status=1 请求路径：/brand/findAll 请求参数：name=OPPO\u0026amp;status=1 请求参数是以key=value形式出现 多个请求参数之间使用\u0026amp;连接 请求路径和请求参数之间使用?连接 协议/版本：HTTP/1.1 请求头 ：第二行开始，上图黄色部分内容就是请求头。格式为key: value形式\nhttp是个无状态的协议，所以在请求头设置浏览器的一些自身信息和想要响应的形式。这样服务器在收到信息后，就可以知道是谁，想干什么了 常见的HTTP请求头有:\n1 2 3 4 5 6 7 8 9 10 11 12 13 Host: 表示请求的主机名 User-Agent: 浏览器版本。 例如：Chrome浏览器的标识类似Mozilla/5.0 ...Chrome/79 ，IE浏览器的标识类似Mozilla/5.0 (Windows NT ...)like Gecko Accept：表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有； Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页； Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。 Content-Type：请求主体的数据类型 Content-Length：数据主体的大小（单位：字节） 举例说明：服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求。\n比如:\n不同浏览器解析HTML和CSS标签的结果会有不一致，所以就会导致相同的代码在不同的浏览器会出现不同的效果 服务端根据客户端请求头中的数据获取到客户端的浏览器类型，就可以根据不同的浏览器设置不同的代码来达到一致的效果（这就是我们常说的浏览器兼容问题） 请求体 ：存储请求参数 GET请求的请求参数在请求行中，故不需要设置请求体 POST方式的请求协议：\n请求行(以上图中红色部分)：包含请求方式、资源路径、协议/版本 请求方式：POST 资源路径：/brand 协议/版本：HTTP/1.1 请求头(以上图中黄色部分) 请求体(以上图中绿色部分) ：存储请求参数 请求体和请求头之间是有一个空行隔开（作用：用于标记请求头结束） GET请求和POST请求的区别：\n区别方式 GET请求 POST请求 请求参数 请求参数在请求行中。例：/brand/findAll?name=OPPO\u0026amp;status=1 请求参数在请求体中 请求参数长度 请求参数长度有限制(浏览器不同限制也不同) 请求参数长度没有限制 安全性 安全性低。原因：请求参数暴露在浏览器地址栏中。 安全性相对高 2.3 HTTP-响应协议 2.3.1 格式介绍 与HTTP的请求一样，HTTP响应的数据也分为3部分：响应行、响应头 、响应体\n响应行(以上图中红色部分)：响应数据的第一行。响应行由协议及版本、响应状态码、状态码描述组成\n协议/版本：HTTP/1.1 响应状态码：200 状态码描述：OK 响应头(以上图中黄色部分)：响应数据的第二行开始。格式为key：value形式\nhttp是个无状态的协议，所以可以在请求头和响应头中设置一些信息和想要执行的动作，这样，对方在收到信息后，就可以知道你是谁，你想干什么 常见的HTTP响应头有:\n1 2 3 4 5 6 7 8 9 Content-Type：表示该响应内容的类型，例如text/html，image/jpeg ； Content-Length：表示该响应内容的长度（字节数）； Content-Encoding：表示该响应压缩算法，例如gzip ； Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒 ; Set-Cookie: 告诉浏览器为当前页面所在的域设置cookie ; 响应体(以上图中绿色部分)： 响应数据的最后一部分。存储响应的数据 响应体和响应头之间有一个空行隔开（作用：用于标记响应头结束） 2.3.2 响应状态码 状态码分类 说明 1xx 响应中 \u0026mdash; 临时状态码。表示请求已经接受，告诉客户端应该继续请求或者如果已经完成则忽略 2xx 成功 \u0026mdash; 表示请求已经被成功接收，处理已完成 3xx 重定向 \u0026mdash; 重定向到其它地方，让客户端再发起一个请求以完成整个处理 4xx 客户端错误 \u0026mdash; 处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等 5xx 服务器端错误 \u0026mdash; 处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等 2.3.3 常见的响应状态码 状态码 英文描述 解释 ==200== OK 客户端请求成功，即处理成功，这是我们最想看到的状态码 302 Found 指示所请求的资源已移动到由Location响应头给定的 URL，浏览器会自动重新访问到这个页面 304 Not Modified 告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 403 Forbidden 服务器收到请求，但是拒绝提供服务，比如：没有权限访问相关资源 ==404== Not Found 请求资源不存在，一般是URL输入有误，或者网站资源被删除了 405 Method Not Allowed 请求方式有误，比如应该用GET请求方式的资源，用了POST 428 Precondition Required 服务器要求有条件的请求，告诉客户端要想访问该资源，必须携带特定的请求头 429 Too Many Requests 指示用户在给定时间内发送了太多请求（“限速”），配合 Retry-After(多长时间后可以请求)响应头一起使用 431 Request Header Fields Too Large 请求头太大，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。 ==500== Internal Server Error 服务器发生不可预期的错误。服务器出异常了，赶紧看日志去吧 503 Service Unavailable 服务器尚未准备好处理请求，服务器刚刚启动，还未初始化好 状态码大全：https://cloud.tencent.com/developer/chapter/13553\n关于响应状态码，我们先主要认识三个状态码，其余的等后期用到了再去掌握：\n200 ok 客户端请求成功 404 Not Found 请求资源不存在 500 Internal Server Error 服务端发生不可预期的错误 2.4 HTTP-协议解析 将资料中准备好的Demo工程，导入到我们的IDEA中，有一个Server.java类，这里面就是自定义的一个服务器代码，主要使用到的是ServerSocket和Socket\n==说明：以下代码大家不需要自己写，我们主要是通过代码，让大家了解到服务器针对HTTP协议的解析机制==\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 package com.itheima; import java.io.*; import java.net.ServerSocket; import java.net.Socket; import java.nio.charset.StandardCharsets; /* * 自定义web服务器 */ public class Server { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(8080); // 监听指定端口 System.out.println(\u0026#34;server is running...\u0026#34;); while (true){ Socket sock = ss.accept(); System.out.println(\u0026#34;connected from \u0026#34; + sock.getRemoteSocketAddress()); Thread t = new Handler(sock); t.start(); } } } class Handler extends Thread { Socket sock; public Handler(Socket sock) { this.sock = sock; } public void run() { try (InputStream input = this.sock.getInputStream(); OutputStream output = this.sock.getOutputStream()) { handle(input, output); } catch (Exception e) { try { this.sock.close(); } catch (IOException ioe) { } System.out.println(\u0026#34;client disconnected.\u0026#34;); } } private void handle(InputStream input, OutputStream output) throws IOException { BufferedReader reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8)); BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8)); // 读取HTTP请求: boolean requestOk = false; String first = reader.readLine(); if (first.startsWith(\u0026#34;GET / HTTP/1.\u0026#34;)) { requestOk = true; } for (;;) { String header = reader.readLine(); if (header.isEmpty()) { // 读取到空行时, HTTP Header读取完毕 break; } System.out.println(header); } System.out.println(requestOk ? \u0026#34;Response OK\u0026#34; : \u0026#34;Response Error\u0026#34;); if (!requestOk) {// 发送错误响应: writer.write(\u0026#34;HTTP/1.0 404 Not Found\\r\\n\u0026#34;); writer.write(\u0026#34;Content-Length: 0\\r\\n\u0026#34;); writer.write(\u0026#34;\\r\\n\u0026#34;); writer.flush(); } else {// 发送成功响应: //读取html文件，转换为字符串 InputStream is = Server.class.getClassLoader().getResourceAsStream(\u0026#34;html/a.html\u0026#34;); BufferedReader br = new BufferedReader(new InputStreamReader(is)); StringBuilder data = new StringBuilder(); String line = null; while ((line = br.readLine()) != null){ data.append(line); } br.close(); int length = data.toString().getBytes(StandardCharsets.UTF_8).length; writer.write(\u0026#34;HTTP/1.1 200 OK\\r\\n\u0026#34;); writer.write(\u0026#34;Connection: keep-alive\\r\\n\u0026#34;); writer.write(\u0026#34;Content-Type: text/html\\r\\n\u0026#34;); writer.write(\u0026#34;Content-Length: \u0026#34; + length + \u0026#34;\\r\\n\u0026#34;); writer.write(\u0026#34;\\r\\n\u0026#34;); // 空行标识Header和Body的分隔 writer.write(data.toString()); writer.flush(); } } } 启动ServerSocket程序：\n浏览器输入：http://localhost:8080 就会访问到ServerSocket程序\nServerSocket程序，会读取服务器上html/a.html文件，并把文件数据发送给浏览器 浏览器接收到a.html文件中的数据后进行解析，显示以下内容 现在大家知道了服务器是可以使用java完成编写，是可以接受页面发送的请求和响应数据给前端浏览器的，而在开发中真正用到的Web服务器，我们不会自己写的，都是使用目前比较流行的web服务器。如：Tomcat\n3. WEB服务器-Tomcat 3.1 简介 3.1.1 服务器概述 服务器硬件\n指的也是计算机，只不过服务器要比我们日常使用的计算机大很多。 服务器，也称伺服器。是提供计算服务的设备。由于服务器需要响应服务请求，并进行处理，因此一般来说服务器应具备承担服务并且保障服务的能力。\n服务器的构成包括处理器、硬盘、内存、系统总线等，和通用的计算机架构类似，但是由于需要提供高可靠的服务，因此在处理能力、稳定性、可靠性、安全性、可扩展性、可管理性等方面要求较高。\n在网络环境下，根据服务器提供的服务类型不同，可分为：文件服务器，数据库服务器，应用程序服务器，WEB服务器等。\n服务器只是一台设备，必须安装服务器软件才能提供相应的服务。\n服务器软件\n服务器软件：基于ServerSocket编写的程序\n服务器软件本质是一个运行在服务器设备上的应用程序 能够接收客户端请求，并根据请求给客户端响应数据 3.1.2 Web服务器 Web服务器是一个应用程序(软件)，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作(不用程序员自己写代码去解析http协议规则)，让Web开发更加便捷。主要功能是\u0026quot;提供网上信息浏览服务\u0026quot;。\nWeb服务器是安装在服务器端的一款软件，将来我们把自己写的Web项目部署到Tomcat服务器软件中，当Web服务器软件启动后，部署在Web服务器软件中的页面就可以直接通过浏览器来访问了。\nWeb服务器软件使用步骤\n准备静态资源 下载安装Web服务器软件 将静态资源部署到Web服务器上 启动Web服务器使用浏览器访问对应的资源 第1步：准备静态资源\n在提供的资料中找到静态资源文件 第2步：下载安装Web服务器软件\n第3步：将静态资源部署到Web服务器上\n第4步：启动Web服务器使用浏览器访问对应的资源\n浏览器输入：http://localhost:8080/demo/index.html\n上述内容在演示的时候，使用的是Apache下的Tomcat软件，至于Tomcat软件如何使用，后面会详细的讲到。而对于Web服务器来说，实现的方案有很多，Tomcat只是其中的一种，而除了Tomcat以外，还有很多优秀的Web服务器，比如:\nTomcat就是一款软件，我们主要是以学习如何去使用为主。具体我们会从以下这些方向去学习:\n简介：初步认识下Tomcat\n基本使用: 安装、卸载、启动、关闭、配置和项目部署，这些都是对Tomcat的基本操作\nIDEA中如何创建Maven Web项目\nIDEA中如何使用Tomcat,后面这两个都是我们以后开发经常会用到的方式\n首选我们来认识下Tomcat。\n3.1.3 Tomcat Tomcat服务器软件是一个免费的开源的web应用服务器。是Apache软件基金会的一个核心项目。由Apache，Sun和其他一些公司及个人共同开发而成。\n由于Tomcat只支持Servlet/JSP少量JavaEE规范，所以是一个开源免费的轻量级Web服务器。\nJavaEE规范： JavaEE =\u0026gt; Java Enterprise Edition(Java企业版)\navaEE规范就是指Java企业级开发的技术规范总和。包含13项技术规范：JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、Java IDL、JTS、JTA、JavaMail、JAF\n因为Tomcat支持Servlet/JSP规范，所以Tomcat也被称为Web容器、Servlet容器。JavaWeb程序需要依赖Tomcat才能运行。\nTomcat的官网: https://tomcat.apache.org/\n3.2 基本使用 3.2.1 下载 直接从官方网站下载：https://tomcat.apache.org/download-90.cgi\nTomcat软件类型说明：\ntar.gz文件，是linux和mac操作系统下的压缩版本 zip文件，是window操作系统下压缩版本（我们选择zip文件） 大家可以自行下载，也可以直接使用资料中已经下载好的资源，\nTomcat的软件程序 ：/资料/SpringbootWeb/apache-tomcat-9.0.27-windows-x64.zip\n3.2.2 安装与卸载 安装: Tomcat是绿色版，直接解压即安装\n在E盘的develop目录下，将apache-tomcat-9.0.27-windows-x64.zip进行解压缩，会得到一个apache-tomcat-9.0.27的目录，Tomcat就已经安装成功。\n==注意，Tomcat在解压缩的时候，解压所在的目录可以任意，但最好解压到一个不包含中文和空格的目录，因为后期在部署项目的时候，如果路径有中文或者空格可能会导致程序部署失败。==\n打开apache-tomcat-9.0.27目录就能看到如下目录结构，每个目录中包含的内容需要认识下\nbin：目录下有两类文件，一种是以.bat结尾的，是Windows系统的可执行文件，一种是以.sh结尾的，是Linux系统的可执行文件。\nwebapps：就是以后项目部署的目录\n**卸载：**卸载比较简单，可以直接删除目录即可\n3.2.3 启动与关闭 启动Tomcat\n双击tomcat解压目录/bin/startup.bat文件即可启动tomcat ==注意: tomcat服务器启动后,黑窗口不会关闭,只要黑窗口不关闭,就证明tomcat服务器正在运行==\nTomcat的默认端口为8080，所以在浏览器的地址栏输入：http://127.0.0.1:8080 即可访问tomcat服务器\n127.0.0.1 也可以使用localhost代替。如：http://localhost:8080\n能看到以上图片中Apache Tomcat的内容就说明Tomcat已经启动成功 ==注意事项== ：Tomcat启动的过程中，遇到控制台有中文乱码时，可以通常修改conf/logging.prooperties文件解决\n关闭: 关闭有三种方式\n1、强制关闭：直接x掉Tomcat窗口（不建议）\n2、正常关闭：bin\\shutdown.bat\n3、正常关闭：在Tomcat启动窗口中按下 Ctrl+C\n说明：如果按下Ctrl+C没有反映，可以多按几次 3.2.4 常见问题 问题1：Tomcat启动时，窗口一闪而过\n检查JAVA_HOME环境变量是否正确配置 问题2：端口号冲突\n发生问题的原因：Tomcat使用的端口被占用了。\n解决方案：换Tomcat端口号\n要想修改Tomcat启动的端口号，需要修改 conf/server.xml文件 注: HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，将不用输入端口号。\n3.3 入门程序解析 关于web开发的基础知识，我们可以告一段落了。下面呢，我们在基于今天的核心技术点SpringBoot快速入门案例进行分析。\n3.3.1 Spring官方骨架 之前我们创建的SpringBoot入门案例，是基于Spring官方提供的骨架实现的。\nSpring官方骨架，可以理解为Spring官方为程序员提供一个搭建项目的模板。\n我们可以通过访问：https://start.spring.io/ ，进入到官方骨架页面\nSpring官方生成的SpringBoot项目，怎么使用呢？\n解压缩后，就会得到一个SpringBoot项目工程 打开pom.xml文件，我们可以看到springboot项目中引入了web依赖和test依赖\n结论：不论使用IDEA创建SpringBoot项目，还是直接在官方网站利用骨架生成SpringBoot项目，项目的结构和pom.xml文件中内容是相似的。\n3.3.2 起步依赖 在我们之前讲解的SpringBoot快速入门案例中，同样也引用了：web依赖和test依赖\nspring-boot-starter-web和spring-boot-starter-test，在SpringBoot中又称为：起步依赖\n而在SpringBoot的项目中，有很多的起步依赖，他们有一个共同的特征：就是以spring-boot-starter-作为开头。在以后大家遇到spring-boot-starter-xxx这类的依赖，都为起步依赖。\n起步依赖有什么特殊之处呢，这里我们以入门案例中引入的起步依赖做为讲解：\nspring-boot-starter-web：包含了web应用开发所需要的常见依赖 spring-boot-starter-test：包含了单元测试所需要的常见依赖 spring-boot-starter-web内部把关于Web开发所有的依赖都已经导入并且指定了版本，只需引入 spring-boot-starter-web 依赖就可以实现Web开发的需要的功能\nSpring的官方提供了很多现成的starter(起步依赖)，我们在开发相关应用时，只需要引入对应的starter即可。\n官方地址：https://docs.spring.io/spring-boot/docs/2.7.2/reference/htmlsingle/#using.build-systems.starters\n每一个起步依赖，都用于开发一个特定的功能。\n举例：当我们开发中需要使用redis数据库时，只需要在SpringBoot项目中，引入：spring-boot-starter-redis ，即可导入redis开发所需要的依赖。\n3.3.2 SpringBoot父工程 在我们之前开发的SpringBoot入门案例中，我们通过maven引入的依赖，是没有指定具体的依赖版本号的。\n为什么没有指定版本号，可以正常使用呢？\n因为每一个SpringBoot工程，都有一个父工程。依赖的版本号，在父工程中统一管理。 3.3.3 内嵌Tomcat 问题：为什么我们之前书写的SpringBoot入门程序中，并没有把程序部署到Tomcat的webapps目录下，也可以运行呢？\n原因呢，是因为在我们的SpringBoot中，引入了web运行环境(也就是引入spring-boot-starter-web起步依赖)，其内部已经集成了内置的Tomcat服务器。\n我们可以通过IDEA开发工具右侧的maven面板中，就可以看到当前工程引入的依赖。其中已经将Tomcat的相关依赖传递下来了，也就是说在SpringBoot中可以直接使用Tomcat服务器。\n当我们运行SpringBoot的引导类时(运行main方法)，就会看到命令行输出的日志，其中占用8080端口的就是Tomcat。\n","date":"2024-07-05T22:27:20+08:00","image":"https://picsum.photos/800/600 ","permalink":"https://4evergreat.github.io/2024/springboot-blog-0/","title":"springboot-blog-0 初级入门篇"},{"content":"SpingBoot原理 在前面十多天的课程当中，我们学习的都是web开发的技术使用，都是面向应用层面的，我们学会了怎么样去用。而我们今天所要学习的是web后端开发的最后一个篇章springboot原理篇，主要偏向于底层原理。\n我们今天的课程安排包括这么三个部分：\n配置优先级：Springboot项目当中属性配置的常见方式以及配置的优先级 Bean的管理 剖析Springboot的底层原理 1. 配置优先级 在我们前面的课程当中，我们已经讲解了SpringBoot项目当中支持的三类配置文件：\napplication.properties application.yml application.yaml 在SpringBoot项目当中，我们要想配置一个属性，可以通过这三种方式当中的任意一种来配置都可以，那么如果项目中同时存在这三种配置文件，且都配置了同一个属性，如：Tomcat端口号，到底哪一份配置文件生效呢？\napplication.properties 1 server.port=8081 application.yml 1 2 server: port: 8082 application.yaml 1 2 server: port: 8082 我们启动SpringBoot程序，测试下三个配置文件中哪个Tomcat端口号生效：\nproperties、yaml、yml三种配置文件同时存在 properties、yaml、yml三种配置文件，优先级最高的是properties\nyaml、yml两种配置文件同时存在 配置文件优先级排名（从高到低）：\nproperties配置文件 yml配置文件 yaml配置文件 注意事项：虽然springboot支持多种格式配置文件，但是在项目开发时，推荐统一使用一种格式的配置。（yml是主流）\n在SpringBoot项目当中除了以上3种配置文件外，SpringBoot为了增强程序的扩展性，除了支持配置文件的配置方式以外，还支持另外两种常见的配置方式：\nJava系统属性配置 （格式： -Dkey=value）\n1 -Dserver.port=9000 命令行参数 （格式：\u0026ndash;key=value）\n1 --server.port=10010 那在idea当中运行程序时，如何来指定Java系统属性和命令行参数呢？\n编辑启动程序的配置信息 重启服务，同时配置Tomcat端口(三种配置文件、系统属性、命令行参数)，测试哪个Tomcat端口号生效：\n删除命令行参数配置，重启SpringBoot服务：\n优先级： 命令行参数 \u0026gt; 系统属性参数 \u0026gt; properties参数 \u0026gt; yml参数 \u0026gt; yaml参数\n思考：如果项目已经打包上线了，这个时候我们又如何来设置Java系统属性和命令行参数呢？\n1 java -Dserver.port=9000 -jar XXXXX.jar --server.port=10010 下面我们来演示下打包程序运行时指定Java系统属性和命令行参数：\n执行maven打包指令package，把项目打成jar文件 使用命令：java -jar 方式运行jar文件程序 项目打包：\n运行jar程序：\n同时设置Java系统属性和命令行参数 仅设置Java系统属性 注意事项：\nSpringboot项目进行打包时，需要引入插件 spring-boot-maven-plugin (基于官网骨架创建项目，会自动添加该插件) 在SpringBoot项目当中，常见的属性配置方式有5种， 3种配置文件，加上2种外部属性的配置(Java系统属性、命令行参数)。通过以上的测试，我们也得出了优先级(从低到高)：\napplication.yaml（忽略） application.yml application.properties java系统属性（-Dxxx=xxx） 命令行参数（\u0026ndash;xxx=xxx） 2. Bean管理 在前面的课程当中，我们已经讲过了我们可以通过Spring当中提供的注解@Component以及它的三个衍生注解（@Controller、@Service、@Repository）来声明IOC容器中的bean对象，同时我们也学习了如何为应用程序注入运行时所需要依赖的bean对象，也就是依赖注入DI。\n我们今天主要学习IOC容器中Bean的其他使用细节，主要学习以下三方面：\n如何从IOC容器中手动的获取到bean对象 bean的作用域配置 管理第三方的bean对象 接下来我们先来学习第一方面，从IOC容器中获取bean对象。\n2.1 获取Bean 默认情况下，SpringBoot项目在启动的时候会自动的创建IOC容器(也称为Spring容器)，并且在启动的过程当中会自动的将bean对象都创建好，存放在IOC容器当中。应用程序在运行时需要依赖什么bean对象，就直接进行依赖注入就可以了。\n而在Spring容器中提供了一些方法，可以主动从IOC容器中获取到bean对象，下面介绍3种常用方式：\n根据name获取bean\n1 Object getBean(String name) 根据类型获取bean\n1 \u0026lt;T\u0026gt; T getBean(Class\u0026lt;T\u0026gt; requiredType) 根据name获取bean（带类型转换）\n1 \u0026lt;T\u0026gt; T getBean(String name, Class\u0026lt;T\u0026gt; requiredType) 思考：要从IOC容器当中来获取到bean对象，需要先拿到IOC容器对象，怎么样才能拿到IOC容器呢？\n想获取到IOC容器，直接将IOC容器对象注入进来就可以了 控制器：DeptController\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @RestController @RequestMapping(\u0026#34;/depts\u0026#34;) public class DeptController { @Autowired private DeptService deptService; public DeptController(){ System.out.println(\u0026#34;DeptController constructor ....\u0026#34;); } @GetMapping public Result list(){ List\u0026lt;Dept\u0026gt; deptList = deptService.list(); return Result.success(deptList); } @DeleteMapping(\u0026#34;/{id}\u0026#34;) public Result delete(@PathVariable Integer id) { deptService.delete(id); return Result.success(); } @PostMapping public Result save(@RequestBody Dept dept){ deptService.save(dept); return Result.success(); } } 业务实现类：DeptServiceImpl\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Slf4j @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Override public List\u0026lt;Dept\u0026gt; list() { List\u0026lt;Dept\u0026gt; deptList = deptMapper.list(); return deptList; } @Override public void delete(Integer id) { deptMapper.delete(id); } @Override public void save(Dept dept) { dept.setCreateTime(LocalDateTime.now()); dept.setUpdateTime(LocalDateTime.now()); deptMapper.save(dept); } } Mapper接口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Mapper public interface DeptMapper { //查询全部部门数据 @Select(\u0026#34;select * from dept\u0026#34;) List\u0026lt;Dept\u0026gt; list(); //删除部门 @Delete(\u0026#34;delete from dept where id = #{id}\u0026#34;) void delete(Integer id); //新增部门 @Insert(\u0026#34;insert into dept(name, create_time, update_time) values (#{name},#{createTime},#{updateTime})\u0026#34;) void save(Dept dept); } 测试类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @SpringBootTest class SpringbootWebConfig2ApplicationTests { @Autowired private ApplicationContext applicationContext; //IOC容器对象 //获取bean对象 @Test public void testGetBean(){ //根据bean的名称获取 DeptController bean1 = (DeptController) applicationContext.getBean(\u0026#34;deptController\u0026#34;); System.out.println(bean1); //根据bean的类型获取 DeptController bean2 = applicationContext.getBean(DeptController.class); System.out.println(bean2); //根据bean的名称 及 类型获取 DeptController bean3 = applicationContext.getBean(\u0026#34;deptController\u0026#34;, DeptController.class); System.out.println(bean3); } } 程序运行后控制台日志：\n问题：输出的bean对象地址值是一样的，说明IOC容器当中的bean对象有几个？\n答案：只有一个。 （默认情况下，IOC中的bean对象是单例）\n那么能不能将bean对象设置为非单例的(每次获取的bean都是一个新对象)？\n可以，在下一个知识点(bean作用域)中讲解。\n注意事项：\n上述所说的 【Spring项目启动时，会把其中的bean都创建好】还会受到作用域及延迟初始化影响，这里主要针对于默认的单例非延迟加载的bean而言。 2.2 Bean作用域 在前面我们提到的IOC容器当中，默认bean对象是单例模式(只有一个实例对象)。那么如何设置bean对象为非单例呢？需要设置bean的作用域。\n在Spring中支持五种作用域，后三种在web环境才生效：\n作用域 说明 singleton 容器内同名称的bean只有一个实例（单例）（默认） prototype 每次使用该bean时会创建新的实例（非单例） request 每个请求范围内会创建新的实例（web环境中，了解） session 每个会话范围内会创建新的实例（web环境中，了解） application 每个应用范围内会创建新的实例（web环境中，了解） 知道了bean的5种作用域了，我们要怎么去设置一个bean的作用域呢？\n可以借助Spring中的@Scope注解来进行配置作用域 1). 测试一\n控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //默认bean的作用域为：singleton (单例) @Lazy //延迟加载（第一次使用bean对象时，才会创建bean对象并交给ioc容器管理） @RestController @RequestMapping(\u0026#34;/depts\u0026#34;) public class DeptController { @Autowired private DeptService deptService; public DeptController(){ System.out.println(\u0026#34;DeptController constructor ....\u0026#34;); } //省略其他代码... } 测试类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @SpringBootTest class SpringbootWebConfig2ApplicationTests { @Autowired private ApplicationContext applicationContext; //IOC容器对象 //bean的作用域 @Test public void testScope(){ for (int i = 0; i \u0026lt; 10; i++) { DeptController deptController = applicationContext.getBean(DeptController.class); System.out.println(deptController); } } } 重启SpringBoot服务，运行测试方法，查看控制台打印的日志：\n注意事项：\nIOC容器中的bean默认使用的作用域：singleton (单例)\n默认singleton的bean，在容器启动时被创建，可以使用@Lazy注解来延迟初始化(延迟到第一次使用时)\n2). 测试二\n修改控制器DeptController代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Scope(\u0026#34;prototype\u0026#34;) //bean作用域为非单例 @Lazy //延迟加载 @RestController @RequestMapping(\u0026#34;/depts\u0026#34;) public class DeptController { @Autowired private DeptService deptService; public DeptController(){ System.out.println(\u0026#34;DeptController constructor ....\u0026#34;); } //省略其他代码... } 重启SpringBoot服务，再次执行测试方法，查看控制吧打印的日志：\n注意事项：\nprototype的bean，每一次使用该bean的时候都会创建一个新的实例 实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性 2.3 第三方Bean 学习完bean的获取、bean的作用域之后，接下来我们再来学习第三方bean的配置。\n之前我们所配置的bean，像controller、service，dao三层体系下编写的类，这些类都是我们在项目当中自己定义的类(自定义类)。当我们要声明这些bean，也非常简单，我们只需要在类上加上@Component以及它的这三个衍生注解（@Controller、@Service、@Repository），就可以来声明这个bean对象了。 但是在我们项目开发当中，还有一种情况就是这个类它不是我们自己编写的，而是我们引入的第三方依赖当中提供的。\n在pom.xml文件中，引入dom4j：\n1 2 3 4 5 6 \u0026lt;!--Dom4j--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dom4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dom4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; dom4j就是第三方组织提供的。 dom4j中的SAXReader类就是第三方编写的。\n当我们需要使用到SAXReader对象时，直接进行依赖注入是不是就可以了呢？\n按照我们之前的做法，需要在SAXReader类上添加一个注解@Component（将当前类交给IOC容器管理） 结论：第三方提供的类是只读的。无法在第三方类上添加@Component注解或衍生注解。\n那么我们应该怎样使用并定义第三方的bean呢？\n如果要管理的bean对象来自于第三方（不是自定义的），是无法用@Component 及衍生注解声明bean的，就需要用到**@Bean**注解。 解决方案1：在启动类上添加@Bean标识的方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 @SpringBootApplication public class SpringbootWebConfig2Application { public static void main(String[] args) { SpringApplication.run(SpringbootWebConfig2Application.class, args); } //声明第三方bean @Bean //将当前方法的返回值对象交给IOC容器管理, 成为IOC容器bean public SAXReader saxReader(){ return new SAXReader(); } } xml文件：\n1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;emp\u0026gt; \u0026lt;name\u0026gt;Tom\u0026lt;/name\u0026gt; \u0026lt;age\u0026gt;18\u0026lt;/age\u0026gt; \u0026lt;/emp\u0026gt; 测试类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @SpringBootTest class SpringbootWebConfig2ApplicationTests { @Autowired private SAXReader saxReader; //第三方bean的管理 @Test public void testThirdBean() throws Exception { Document document = saxReader.read(this.getClass().getClassLoader().getResource(\u0026#34;1.xml\u0026#34;)); Element rootElement = document.getRootElement(); String name = rootElement.element(\u0026#34;name\u0026#34;).getText(); String age = rootElement.element(\u0026#34;age\u0026#34;).getText(); System.out.println(name + \u0026#34; : \u0026#34; + age); } //省略其他代码... } 重启SpringBoot服务，执行测试方法后，控制台输出日志：\n1 Tom : 18 说明：以上在启动类中声明第三方Bean的作法，不建议使用（项目中要保证启动类的纯粹性）\n解决方案2：在配置类中定义@Bean标识的方法\n如果需要定义第三方Bean时， 通常会单独定义一个配置类 1 2 3 4 5 6 7 8 9 10 11 12 @Configuration //配置类 (在配置类当中对第三方bean进行集中的配置管理) public class CommonConfig { //声明第三方bean @Bean //将当前方法的返回值对象交给IOC容器管理, 成为IOC容器bean //通过@Bean注解的name/value属性指定bean名称, 如果未指定, 默认是方法名 public SAXReader reader(DeptService deptService){ System.out.println(deptService); return new SAXReader(); } } 注释掉SpringBoot启动类中创建第三方bean对象的代码，重启服务，执行测试方法，查看控制台日志：\n1 Tom : 18 在方法上加上一个@Bean注解，Spring 容器在启动的时候，它会自动的调用这个方法，并将方法的返回值声明为Spring容器当中的Bean对象。\n注意事项 ：\n通过@Bean注解的name或value属性可以声明bean的名称，如果不指定，默认bean的名称就是方法名。\n如果第三方bean需要依赖其它bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配。\n关于Bean大家只需要保持一个原则：\n如果是在项目当中我们自己定义的类，想将这些类交给IOC容器管理，我们直接使用@Component以及它的衍生注解来声明就可以。 如果这个类它不是我们自己定义的，而是引入的第三方依赖当中提供的类，而且我们还想将这个类交给IOC容器管理。此时我们就需要在配置类中定义一个方法，在方法上加上一个@Bean注解，通过这种方式来声明第三方的bean对象。 3. SpringBoot原理 经过前面10多天课程的学习，大家也会发现基于SpringBoot进行web程序的开发是非常简单、非常高效的。\nSpringBoot使我们能够集中精力地去关注业务功能的开发，而不用过多地关注框架本身的配置使用。而我们前面所讲解的都是面向应用层面的技术，接下来我们开始学习SpringBoot的原理，这部分内容偏向于底层的原理分析。\n在剖析SpringBoot的原理之前，我们先来快速回顾一下我们前面所讲解的Spring家族的框架。\nSpring是目前世界上最流行的Java框架，它可以帮助我们更加快速、更加容易的来构建Java项目。而在Spring家族当中提供了很多优秀的框架，而所有的框架都是基于一个基础框架的SpringFramework(也就是Spring框架)。而前面我们也提到，如果我们直接基于Spring框架进行项目的开发，会比较繁琐。\n这个繁琐主要体现在两个地方：\n在pom.xml中依赖配置比较繁琐，在项目开发时，需要自己去找到对应的依赖，还需要找到依赖它所配套的依赖以及对应版本，否则就会出现版本冲突问题。 在使用Spring框架进行项目开发时，需要在Spring的配置文件中做大量的配置，这就造成Spring框架入门难度较大，学习成本较高。 基于Spring存在的问题，官方在Spring框架4.0版本之后，又推出了一个全新的框架：SpringBoot。\n通过 SpringBoot来简化Spring框架的开发(是简化不是替代)。我们直接基于SpringBoot来构建Java项目，会让我们的项目开发更加简单，更加快捷。\nSpringBoot框架之所以使用起来更简单更快捷，是因为SpringBoot框架底层提供了两个非常重要的功能：一个是起步依赖，一个是自动配置。\n通过SpringBoot所提供的起步依赖，就可以大大的简化pom文件当中依赖的配置，从而解决了Spring框架当中依赖配置繁琐的问题。\n通过自动配置的功能就可以大大的简化框架在使用时bean的声明以及bean的配置。我们只需要引入程序开发时所需要的起步依赖，项目开发时所用到常见的配置都已经有了，我们直接使用就可以了。\n简单回顾之后，接下来我们来学习下SpringBoot的原理。其实学习SpringBoot的原理就是来解析SpringBoot当中的起步依赖与自动配置的原理。我们首先来学习SpringBoot当中起步依赖的原理。\n3.1 起步依赖 假如我们没有使用SpringBoot，用的是Spring框架进行web程序的开发，此时我们就需要引入web程序开发所需要的一些依赖。\nspring-webmvc依赖：这是Spring框架进行web程序开发所需要的依赖\nservlet-api依赖：Servlet基础依赖\njackson-databind依赖：JSON处理工具包\n如果要使用AOP，还需要引入aop依赖、aspect依赖\n项目中所引入的这些依赖，还需要保证版本匹配，否则就可能会出现版本冲突问题。\n如果我们使用了SpringBoot，就不需要像上面这么繁琐的引入依赖了。我们只需要引入一个依赖就可以了，那就是web开发的起步依赖：springboot-starter-web。\n为什么我们只需要引入一个web开发的起步依赖，web开发所需要的所有的依赖都有了呢？\n因为Maven的依赖传递。 在SpringBoot给我们提供的这些起步依赖当中，已提供了当前程序开发所需要的所有的常见依赖(官网地址：https://docs.spring.io/spring-boot/docs/2.7.7/reference/htmlsingle/#using.build-systems.starters)。\n比如：springboot-starter-web，这是web开发的起步依赖，在web开发的起步依赖当中，就集成了web开发中常见的依赖：json、web、webmvc、tomcat等。我们只需要引入这一个起步依赖，其他的依赖都会自动的通过Maven的依赖传递进来。\n结论：起步依赖的原理就是Maven的依赖传递。\n3.2 自动配置 我们讲解了SpringBoot当中起步依赖的原理，就是Maven的依赖传递。接下来我们解析下自动配置的原理，我们要分析自动配置的原理，首先要知道什么是自动配置。\n3.2.1 概述 SpringBoot的自动配置就是当Spring容器启动后，一些配置类、bean对象就自动存入到了IOC容器中，不需要我们手动去声明，从而简化了开发，省去了繁琐的配置操作。\n比如：我们要进行事务管理、要进行AOP程序的开发，此时就不需要我们再去手动的声明这些bean对象了，我们直接使用就可以从而大大的简化程序的开发，省去了繁琐的配置操作。\n下面我们打开idea，一起来看下自动配置的效果：\n运行SpringBoot启动类 大家会看到有两个CommonConfig，在第一个CommonConfig类中定义了一个bean对象，bean对象的名字叫reader。\n在第二个CommonConfig中它的bean名字叫commonConfig，为什么还会有这样一个bean对象呢？原因是在CommonConfig配置类上添加了一个注解@Configuration，而@Configuration底层就是@Component\n所以配置类最终也是SpringIOC容器当中的一个bean对象\n在IOC容器中除了我们自己定义的bean以外，还有很多配置类，这些配置类都是SpringBoot在启动的时候加载进来的配置类。这些配置类加载进来之后，它也会生成很多的bean对象。\n比如：配置类GsonAutoConfiguration里面有一个bean，bean的名字叫gson，它的类型是Gson。\ncom.google.gson.Gson是谷歌包中提供的用来处理JSON格式数据的。\n当我们想要使用这些配置类中生成的bean对象时，可以使用@Autowired就自动注入了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import com.google.gson.Gson; import com.itheima.pojo.Result; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest public class AutoConfigurationTests { @Autowired private Gson gson; @Test public void testJson(){ String json = gson.toJson(Result.success()); System.out.println(json); } } 添加断点，使用debug模式运行测试类程序：\n问题：在当前项目中我们并没有声明谷歌提供的Gson这么一个bean对象，然后我们却可以通过@Autowired从Spring容器中注入bean对象，那么这个bean对象怎么来的？\n答案：SpringBoot项目在启动时通过自动配置完成了bean对象的创建。\n体验了SpringBoot的自动配置了，下面我们就来分析自动配置的原理。其实分析自动配置原理就是来解析在SpringBoot项目中，在引入依赖之后是如何将依赖jar包当中所定义的配置类以及bean加载到SpringIOC容器中的。\n3.2.2 常见方案 3.2.2.1 概述 我们知道了什么是自动配置之后，接下来我们就要来剖析自动配置的原理。解析自动配置的原理就是分析在 SpringBoot项目当中，我们引入对应的依赖之后，是如何将依赖jar包当中所提供的bean以及配置类直接加载到当前项目的SpringIOC容器当中的。\n接下来，我们就直接通过代码来分析自动配置原理。\n准备工作：在Idea中导入\u0026quot;资料\\03. 自动配置原理\u0026quot;下的itheima-utils工程\n1、在SpringBoot项目 spring-boot-web-config2 工程中，通过坐标引入itheima-utils依赖\n1 2 3 4 5 6 @Component public class TokenParser { public void parse(){ System.out.println(\u0026#34;TokenParser ... parse ...\u0026#34;); } } 2、在测试类中，添加测试方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @SpringBootTest public class AutoConfigurationTests { @Autowired private ApplicationContext applicationContext; @Test public void testTokenParse(){ System.out.println(applicationContext.getBean(TokenParser.class)); } //省略其他代码... } 3、执行测试方法\n异常信息描述： 没有com.example.TokenParse类型的bean\n说明：在Spring容器中没有找到com.example.TokenParse类型的bean对象\n思考：引入进来的第三方依赖当中的bean以及配置类为什么没有生效？\n原因在我们之前讲解IOC的时候有提到过，在类上添加@Component注解来声明bean对象时，还需要保证@Component注解能被Spring的组件扫描到。 SpringBoot项目中的@SpringBootApplication注解，具有包扫描的作用，但是它只会扫描启动类所在的当前包以及子包。 当前包：com.itheima， 第三方依赖中提供的包：com.example（扫描不到） 那么如何解决以上问题的呢？\n方案1：@ComponentScan 组件扫描 方案2：@Import 导入（使用@Import导入的类会被Spring加载到IOC容器中） 3.2.2.2 方案一 @ComponentScan组件扫描\n1 2 3 4 5 6 7 @SpringBootApplication @ComponentScan({\u0026#34;com.itheima\u0026#34;,\u0026#34;com.example\u0026#34;}) //指定要扫描的包 public class SpringbootWebConfig2Application { public static void main(String[] args) { SpringApplication.run(SpringbootWebConfig2Application.class, args); } } 重新执行测试方法，控制台日志输出：\n大家可以想象一下，如果采用以上这种方式来完成自动配置，那我们进行项目开发时，当需要引入大量的第三方的依赖，就需要在启动类上配置N多要扫描的包，这种方式会很繁琐。而且这种大面积的扫描性能也比较低。\n缺点：\n使用繁琐 性能低 结论：SpringBoot中并没有采用以上这种方案。\n3.2.2.3 方案二 @Import导入\n导入形式主要有以下几种： 导入普通类 导入配置类 导入ImportSelector接口实现类 1). 使用@Import导入普通类：\n1 2 3 4 5 6 7 @Import(TokenParser.class) //导入的类会被Spring加载到IOC容器中 @SpringBootApplication public class SpringbootWebConfig2Application { public static void main(String[] args) { SpringApplication.run(SpringbootWebConfig2Application.class, args); } } 重新执行测试方法，控制台日志输出：\n2). 使用@Import导入配置类：\n配置类 1 2 3 4 5 6 7 8 9 10 11 12 @Configuration public class HeaderConfig { @Bean public HeaderParser headerParser(){ return new HeaderParser(); } @Bean public HeaderGenerator headerGenerator(){ return new HeaderGenerator(); } } 启动类 1 2 3 4 5 6 7 @Import(HeaderConfig.class) //导入配置类 @SpringBootApplication public class SpringbootWebConfig2Application { public static void main(String[] args) { SpringApplication.run(SpringbootWebConfig2Application.class, args); } } 测试类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @SpringBootTest public class AutoConfigurationTests { @Autowired private ApplicationContext applicationContext; @Test public void testHeaderParser(){ System.out.println(applicationContext.getBean(HeaderParser.class)); } @Test public void testHeaderGenerator(){ System.out.println(applicationContext.getBean(HeaderGenerator.class)); } //省略其他代码... } 执行测试方法：\n3). 使用@Import导入ImportSelector接口实现类：\nImportSelector接口实现类 1 2 3 4 5 6 public class MyImportSelector implements ImportSelector { public String[] selectImports(AnnotationMetadata importingClassMetadata) { //返回值字符串数组（数组中封装了全限定名称的类） return new String[]{\u0026#34;com.example.HeaderConfig\u0026#34;}; } } 启动类 1 2 3 4 5 6 7 8 @Import(MyImportSelector.class) //导入ImportSelector接口实现类 @SpringBootApplication public class SpringbootWebConfig2Application { public static void main(String[] args) { SpringApplication.run(SpringbootWebConfig2Application.class, args); } } 执行测试方法：\n我们使用@Import注解通过这三种方式都可以导入第三方依赖中所提供的bean或者是配置类。\n思考：如果基于以上方式完成自动配置，当要引入一个第三方依赖时，是不是还要知道第三方依赖中有哪些配置类和哪些Bean对象？\n答案：是的。 （对程序员来讲，很不友好，而且比较繁琐） 思考：当我们要使用第三方依赖，依赖中到底有哪些bean和配置类，谁最清楚？\n答案：第三方依赖自身最清楚。 结论：我们不用自己指定要导入哪些bean对象和配置类了，让第三方依赖它自己来指定。\n怎么让第三方依赖自己指定bean对象和配置类？\n比较常见的方案就是第三方依赖给我们提供一个注解，这个注解一般都以@EnableXxxx开头的注解，注解中封装的就是@Import注解 4). 使用第三方依赖提供的 @EnableXxxxx注解\n第三方依赖中提供的注解 1 2 3 4 5 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Import(MyImportSelector.class)//指定要导入哪些bean对象或配置类 public @interface EnableHeaderConfig { } 在使用时只需在启动类上加上@EnableXxxxx注解即可 1 2 3 4 5 6 7 @EnableHeaderConfig //使用第三方依赖提供的Enable开头的注解 @SpringBootApplication public class SpringbootWebConfig2Application { public static void main(String[] args) { SpringApplication.run(SpringbootWebConfig2Application.class, args); } } 执行测试方法：\n以上四种方式都可以完成导入操作，但是第4种方式会更方便更优雅，而这种方式也是SpringBoot当中所采用的方式。\n3.2.3 原理分析 3.2.3.1 源码跟踪 前面我们讲解了在项目当中引入第三方依赖之后，如何加载第三方依赖中定义好的bean对象以及配置类，从而完成自动配置操作。那下面我们通过源码跟踪的形式来剖析下SpringBoot底层到底是如何完成自动配置的。\n源码跟踪技巧：\n在跟踪框架源码的时候，一定要抓住关键点，找到核心流程。一定不要从头到尾一行代码去看，一个方法的去研究，一定要找到关键流程，抓住关键点，先在宏观上对整个流程或者整个原理有一个认识，有精力再去研究其中的细节。\n要搞清楚SpringBoot的自动配置原理，要从SpringBoot启动类上使用的核心注解@SpringBootApplication开始分析：\n在@SpringBootApplication注解中包含了：\n元注解（不再解释） @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan 我们先来看第一个注解：@SpringBootConfiguration\n@SpringBootConfiguration注解上使用了@Configuration，表明SpringBoot启动类就是一个配置类。\n@Indexed注解，是用来加速应用启动的（不用关心）。\n接下来再先看@ComponentScan注解：\n@ComponentScan注解是用来进行组件扫描的，扫描启动类所在的包及其子包下所有被@Component及其衍生注解声明的类。\nSpringBoot启动类，之所以具备扫描包功能，就是因为包含了@ComponentScan注解。\n最后我们来看看@EnableAutoConfiguration注解（自动配置核心注解）：\n使用@Import注解，导入了实现ImportSelector接口的实现类。\nAutoConfigurationImportSelector类是ImportSelector接口的实现类。\nAutoConfigurationImportSelector类中重写了ImportSelector接口的selectImports()方法：\nselectImports()方法底层调用getAutoConfigurationEntry()方法，获取可自动配置的配置类信息集合\ngetAutoConfigurationEntry()方法通过调用getCandidateConfigurations(annotationMetadata, attributes)方法获取在配置文件中配置的所有自动配置类的集合\ngetCandidateConfigurations方法的功能：\n获取所有基于META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件、META-INF/spring.factories文件中配置类的集合\nMETA-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件和META-INF/spring.factories文件这两个文件在哪里呢？\n通常在引入的起步依赖中，都有包含以上两个文件 在前面在给大家演示自动配置的时候，我们直接在测试类当中注入了一个叫gson的bean对象，进行JSON格式转换。虽然我们没有配置bean对象，但是我们是可以直接注入使用的。原因就是因为在自动配置类当中做了自动配置。到底是在哪个自动配置类当中做的自动配置呢？我们通过搜索来查询一下。\n在META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports配置文件中指定了第三方依赖Gson的配置类：GsonAutoConfiguration\n第三方依赖中提供的GsonAutoConfiguration类：\n在GsonAutoConfiguration类上，添加了注解@AutoConfiguration，通过查看源码，可以明确：GsonAutoConfiguration类是一个配置。\n看到这里，大家就应该明白为什么可以完成自动配置了，原理就是在配置类中定义一个@Bean标识的方法，而Spring会自动调用配置类中使用@Bean标识的方法，并把方法的返回值注册到IOC容器中。\n自动配置源码小结\n自动配置原理源码入口就是@SpringBootApplication注解，在这个注解中封装了3个注解，分别是：\n@SpringBootConfiguration 声明当前类是一个配置类 @ComponentScan 进行组件扫描（SpringBoot中默认扫描的是启动类所在的当前包及其子包） @EnableAutoConfiguration 封装了@Import注解（Import注解中指定了一个ImportSelector接口的实现类） 在实现类重写的selectImports()方法，读取当前项目下所有依赖jar包中META-INF/spring.factories、META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports两个文件里面定义的配置类（配置类中定义了@Bean注解标识的方法）。 当SpringBoot程序启动时，就会加载配置文件当中所定义的配置类，并将这些配置类信息(类的全限定名)封装到String类型的数组中，最终通过@Import注解将这些配置类全部加载到Spring的IOC容器中，交给IOC容器管理。\n最后呢给大家抛出一个问题：在META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件中定义的配置类非常多，而且每个配置类中又可以定义很多的bean，那这些bean都会注册到Spring的IOC容器中吗？\n答案：并不是。 在声明bean对象时，上面有加一个以@Conditional开头的注解，这种注解的作用就是按照条件进行装配，只有满足条件之后，才会将bean注册到Spring的IOC容器中（下面会详细来讲解）\n3.2.3.2 @Conditional 我们在跟踪SpringBoot自动配置的源码的时候，在自动配置类声明bean的时候，除了在方法上加了一个@Bean注解以外，还会经常用到一个注解，就是以Conditional开头的这一类的注解。以Conditional开头的这些注解都是条件装配的注解。下面我们就来介绍下条件装配注解。\n@Conditional注解：\n作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到Spring的IOC容器中。 位置：方法、类 @Conditional本身是一个父注解，派生出大量的子注解： @ConditionalOnClass：判断环境中有对应字节码文件，才注册bean到IOC容器。 @ConditionalOnMissingBean：判断环境中没有对应的bean(类型或名称)，才注册bean到IOC容器。 @ConditionalOnProperty：判断配置文件中有对应属性和值，才注册bean到IOC容器。 下面我们通过代码来演示下Conditional注解的使用：\n@ConditionalOnClass注解 1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean @ConditionalOnClass(name=\u0026#34;io.jsonwebtoken.Jwts\u0026#34;)//环境中存在指定的这个类，才会将该bean加入IOC容器 public HeaderParser headerParser(){ return new HeaderParser(); } //省略其他代码... } pom.xml 1 2 3 4 5 6 \u0026lt;!--JWT令牌--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 测试类 1 2 3 4 5 6 7 8 9 10 11 12 @SpringBootTest public class AutoConfigurationTests { @Autowired private ApplicationContext applicationContext; @Test public void testHeaderParser(){ System.out.println(applicationContext.getBean(HeaderParser.class)); } //省略其他代码... } 执行testHeaderParser()测试方法：\n因为io.jsonwebtoken.Jwts字节码文件在启动SpringBoot程序时已存在，所以创建HeaderParser对象并注册到IOC容器中。\n@ConditionalOnMissingBean注解 1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean @ConditionalOnMissingBean //不存在该类型的bean，才会将该bean加入IOC容器 public HeaderParser headerParser(){ return new HeaderParser(); } //省略其他代码... } 执行testHeaderParser()测试方法：\nSpringBoot在调用@Bean标识的headerParser()前，IOC容器中是没有HeaderParser类型的bean，所以HeaderParser对象正常创建，并注册到IOC容器中。\n再次修改@ConditionalOnMissingBean注解：\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean @ConditionalOnMissingBean(name=\u0026#34;deptController2\u0026#34;)//不存在指定名称的bean，才会将该bean加入IOC容器 public HeaderParser headerParser(){ return new HeaderParser(); } //省略其他代码... } 执行testHeaderParser()测试方法：\n因为在SpringBoot环境中不存在名字叫deptController2的bean对象，所以创建HeaderParser对象并注册到IOC容器中。\n再次修改@ConditionalOnMissingBean注解：\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class HeaderConfig { @Bean @ConditionalOnMissingBean(HeaderConfig.class)//不存在指定类型的bean，才会将bean加入IOC容器 public HeaderParser headerParser(){ return new HeaderParser(); } //省略其他代码... } 1 2 3 4 5 6 7 8 9 10 11 12 @SpringBootTest public class AutoConfigurationTests { @Autowired private ApplicationContext applicationContext; @Test public void testHeaderParser(){ System.out.println(applicationContext.getBean(HeaderParser.class)); } //省略其他代码... } 执行testHeaderParser()测试方法：\n因为HeaderConfig类中添加@Configuration注解，而@Configuration注解中包含了@Component，所以SpringBoot启动时会创建HeaderConfig类对象，并注册到IOC容器中。\n当IOC容器中有HeaderConfig类型的bean存在时，不会把创建HeaderParser对象注册到IOC容器中。而IOC容器中没有HeaderParser类型的对象时，通过getBean(HeaderParser.class)方法获取bean对象时，引发异常：NoSuchBeanDefinitionException\n@ConditionalOnProperty注解（这个注解和配置文件当中配置的属性有关系） 先在application.yml配置文件中添加如下的键值对：\n1 name: itheima 在声明bean的时候就可以指定一个条件@ConditionalOnProperty\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration public class HeaderConfig { @Bean @ConditionalOnProperty(name =\u0026#34;name\u0026#34;,havingValue = \u0026#34;itheima\u0026#34;)//配置文件中存在指定属性名与值，才会将bean加入IOC容器 public HeaderParser headerParser(){ return new HeaderParser(); } @Bean public HeaderGenerator headerGenerator(){ return new HeaderGenerator(); } } 执行testHeaderParser()测试方法：\n修改@ConditionalOnProperty注解： havingValue的值修改为\u0026quot;itheima2\u0026quot;\n1 2 3 4 5 @Bean @ConditionalOnProperty(name =\u0026#34;name\u0026#34;,havingValue = \u0026#34;itheima2\u0026#34;)//配置文件中存在指定属性名与值，才会将bean加入IOC容器 public HeaderParser headerParser(){ return new HeaderParser(); } 再次执行testHeaderParser()测试方法：\n因为application.yml配置文件中，不存在： name: itheima2，所以HeaderParser对象在IOC容器中不存在\n我们再回头看看之前讲解SpringBoot源码时提到的一个配置类：GsonAutoConfiguration\n最后再给大家梳理一下自动配置原理：\n自动配置的核心就在@SpringBootApplication注解上，SpringBootApplication这个注解底层包含了3个注解，分别是：\n@SpringBootConfiguration\n@ComponentScan\n@EnableAutoConfiguration\n@EnableAutoConfiguration这个注解才是自动配置的核心。\n它封装了一个@Import注解，Import注解里面指定了一个ImportSelector接口的实现类。 在这个实现类中，重写了ImportSelector接口中的selectImports()方法。 而selectImports()方法中会去读取两份配置文件，并将配置文件中定义的配置类做为selectImports()方法的返回值返回，返回值代表的就是需要将哪些类交给Spring的IOC容器进行管理。 那么所有自动配置类的中声明的bean都会加载到Spring的IOC容器中吗? 其实并不会，因为这些配置类中在声明bean时，通常都会添加@Conditional开头的注解，这个注解就是进行条件装配。而Spring会根据Conditional注解有选择性的进行bean的创建。 @Enable 开头的注解底层，它就封装了一个注解 import 注解，它里面指定了一个类，是 ImportSelector 接口的实现类。在实现类当中，我们需要去实现 ImportSelector 接口当中的一个方法 selectImports 这个方法。这个方法的返回值代表的就是我需要将哪些类交给 spring 的 IOC容器进行管理。 此时它会去读取两份配置文件，一份儿是 spring.factories，另外一份儿是 autoConfiguration.imports。而在 autoConfiguration.imports 这份儿文件当中，它就会去配置大量的自动配置的类。 而前面我们也提到过这些所有的自动配置类当中，所有的 bean都会加载到 spring 的 IOC 容器当中吗？其实并不会，因为这些配置类当中，在声明 bean 的时候，通常会加上这么一类@Conditional 开头的注解。这个注解就是进行条件装配。所以SpringBoot非常的智能，它会根据 @Conditional 注解来进行条件装配。只有条件成立，它才会声明这个bean，才会将这个 bean 交给 IOC 容器管理。 3.2.4 案例 3.2.4.1 自定义starter分析 前面我们解析了SpringBoot中自动配置的原理，下面我们就通过一个自定义starter案例来加深大家对于自动配置原理的理解。首先介绍一下自定义starter的业务场景，再来分析一下具体的操作步骤。\n所谓starter指的就是SpringBoot当中的起步依赖。在SpringBoot当中已经给我们提供了很多的起步依赖了，我们为什么还需要自定义 starter 起步依赖？这是因为在实际的项目开发当中，我们可能会用到很多第三方的技术，并不是所有的第三方的技术官方都给我们提供了与SpringBoot整合的starter起步依赖，但是这些技术又非常的通用，在很多项目组当中都在使用。\n业务场景：\n我们前面案例当中所使用的阿里云OSS对象存储服务，现在阿里云的官方是没有给我们提供对应的起步依赖的，这个时候使用起来就会比较繁琐，我们需要引入对应的依赖。我们还需要在配置文件当中进行配置，还需要基于官方SDK示例来改造对应的工具类，我们在项目当中才可以进行使用。 大家想在我们当前项目当中使用了阿里云OSS，我们需要进行这么多步的操作。在别的项目组当中要想使用阿里云OSS，是不是也需要进行这么多步的操作，所以这个时候我们就可以自定义一些公共组件，在这些公共组件当中，我就可以提前把需要配置的bean都提前配置好。将来在项目当中，我要想使用这个技术，我直接将组件对应的坐标直接引入进来，就已经自动配置好了，就可以直接使用了。我们也可以把公共组件提供给别的项目组进行使用，这样就可以大大的简化我们的开发。 在SpringBoot项目中，一般都会将这些公共组件封装为SpringBoot当中的starter，也就是我们所说的起步依赖。\nSpringBoot官方starter命名： spring-boot-starter-xxxx\n第三组织提供的starter命名： xxxx-spring-boot-starter\nMybatis提供了配置类，并且也提供了springboot会自动读取的配置文件。当SpringBoot项目启动时，会读取到spring.factories配置文件中的配置类并加载配置类，生成相关bean对象注册到IOC容器中。\n结果：我们可以直接在SpringBoot程序中使用Mybatis自动配置的bean对象。\n在自定义一个起步依赖starter的时候，按照规范需要定义两个模块：\nstarter模块（进行依赖管理[把程序开发所需要的依赖都定义在starter起步依赖中]） autoconfigure模块（自动配置） 将来在项目当中进行相关功能开发时，只需要引入一个起步依赖就可以了，因为它会将autoconfigure自动配置的依赖给传递下来。\n上面我们简单介绍了自定义starter的场景，以及自定义starter时涉及到的模块之后，接下来我们就来完成一个自定义starter的案例。\n需求：自定义aliyun-oss-spring-boot-starter，完成阿里云OSS操作工具类AliyunOSSUtils的自动配置。\n目标：引入起步依赖引入之后，要想使用阿里云OSS，注入AliyunOSSUtils直接使用即可。\n之前阿里云OSS的使用：\n配置文件 1 2 3 4 5 6 7 #配置阿里云OSS参数 aliyun: oss: endpoint: https://oss-cn-shanghai.aliyuncs.com accessKeyId: LTAI5t9MZK8iq5T2Av5GLDxX accessKeySecret: C0IrHzKZGKqU8S7YQcevcotD3Zd5Tc bucketName: web-framework01 AliOSSProperties类 1 2 3 4 5 6 7 8 9 10 11 12 13 @Data @Component @ConfigurationProperties(prefix = \u0026#34;aliyun.oss\u0026#34;) public class AliOSSProperties { //区域 private String endpoint; //身份ID private String accessKeyId ; //身份密钥 private String accessKeySecret ; //存储空间 private String bucketName; } AliOSSUtils工具类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @Component //当前类对象由Spring创建和管理 public class AliOSSUtils { @Autowired private AliOSSProperties aliOSSProperties; /** * 实现上传图片到OSS */ public String upload(MultipartFile multipartFile) throws IOException { // 获取上传的文件的输入流 InputStream inputStream = multipartFile.getInputStream(); // 避免文件覆盖 String originalFilename = multipartFile.getOriginalFilename(); String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(\u0026#34;.\u0026#34;)); //上传文件到 OSS OSS ossClient = new OSSClientBuilder().build(aliOSSProperties.getEndpoint(), aliOSSProperties.getAccessKeyId(), aliOSSProperties.getAccessKeySecret()); ossClient.putObject(aliOSSProperties.getBucketName(), fileName, inputStream); //文件访问路径 String url =aliOSSProperties.getEndpoint().split(\u0026#34;//\u0026#34;)[0] + \u0026#34;//\u0026#34; + aliOSSProperties.getBucketName() + \u0026#34;.\u0026#34; + aliOSSProperties.getEndpoint().split(\u0026#34;//\u0026#34;)[1] + \u0026#34;/\u0026#34; + fileName; // 关闭ossClient ossClient.shutdown(); return url;// 把上传到oss的路径返回 } } 当我们在项目当中要使用阿里云OSS，就可以注入AliOSSUtils工具类来进行文件上传。但这种方式其实是比较繁琐的。\n大家再思考，现在我们使用阿里云OSS，需要做这么几步，将来大家在开发其他的项目的时候，你使用阿里云OSS，这几步你要不要做？当团队中其他小伙伴也在使用阿里云OSS的时候，步骤 不也是一样的。\n所以这个时候我们就可以制作一个公共组件(自定义starter)。starter定义好之后，将来要使用阿里云OSS进行文件上传，只需要将起步依赖引入进来之后，就可以直接注入AliOSSUtils使用了。\n需求明确了，接下来我们再来分析一下具体的实现步骤：\n第1步：创建自定义starter模块（进行依赖管理） 把阿里云OSS所有的依赖统一管理起来 第2步：创建autoconfigure模块 在starter中引入autoconfigure （我们使用时只需要引入starter起步依赖即可） 第3步：在autoconfigure中完成自动配置 定义一个自动配置类，在自动配置类中将所要配置的bean都提前配置好 定义配置文件，把自动配置类的全类名定义在配置文件中 我们分析完自定义阿里云OSS自动配置的操作步骤了，下面我们就按照分析的步骤来实现自定义starter。\n3.2.4.2 自定义starter实现 自定义starter的步骤我们刚才已经分析了，接下来我们就按照分析的步骤来完成自定义starter的开发。\n首先我们先来创建两个Maven模块：\n1). aliyun-oss-spring-boot-starter模块\n创建完starter模块后，删除多余的文件，最终保留内容如下：\n删除pom.xml文件中多余的内容后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;11\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 2). aliyun-oss-spring-boot-autoconfigure模块\n创建完starter模块后，删除多余的文件，最终保留内容如下：\n删除pom.xml文件中多余的内容后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;11\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 按照我们之前的分析，是需要在starter模块中来引入autoconfigure这个模块的。打开starter模块中的pom文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;11\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--引入autoconfigure模块--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 前两步已经完成了，接下来是最关键的就是第三步：\n在autoconfigure模块当中来完成自动配置操作。\n我们将之前案例中所使用的阿里云OSS部分的代码直接拷贝到autoconfigure模块下，然后进行改造就行了。\n拷贝过来后，还缺失一些相关的依赖，需要把相关依赖也拷贝过来：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;11\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--引入web起步依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Lombok--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--阿里云OSS--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-sdk-oss\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.15.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.xml.bind\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.activation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;activation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- no more than 2.3.3--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.glassfish.jaxb\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-runtime\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 现在大家思考下，在类上添加的@Component注解还有用吗？\n答案：没用了。 在SpringBoot项目中，并不会去扫描com.aliyun.oss这个包，不扫描这个包那类上的注解也就失去了作用。\n@Component注解不需要使用了，可以从类上删除了。\n删除后报红色错误，暂时不理会，后面再来处理。\n删除AliOSSUtils类中的@Component注解、@Autowired注解\n下面我们就要定义一个自动配置类了，在自动配置类当中来声明AliOSSUtils的bean对象。\nAliOSSAutoConfiguration类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Configuration//当前类为Spring配置类 @EnableConfigurationProperties(AliOSSProperties.class)//导入AliOSSProperties类，并交给SpringIOC管理 public class AliOSSAutoConfiguration { //创建AliOSSUtils对象，并交给SpringIOC容器 @Bean public AliOSSUtils aliOSSUtils(AliOSSProperties aliOSSProperties){ AliOSSUtils aliOSSUtils = new AliOSSUtils(); aliOSSUtils.setAliOSSProperties(aliOSSProperties); return aliOSSUtils; } } AliOSSProperties类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 /*阿里云OSS相关配置*/ @Data @ConfigurationProperties(prefix = \u0026#34;aliyun.oss\u0026#34;) public class AliOSSProperties { //区域 private String endpoint; //身份ID private String accessKeyId ; //身份密钥 private String accessKeySecret ; //存储空间 private String bucketName; } AliOSSUtils类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Data public class AliOSSUtils { private AliOSSProperties aliOSSProperties; /** * 实现上传图片到OSS */ public String upload(MultipartFile multipartFile) throws IOException { // 获取上传的文件的输入流 InputStream inputStream = multipartFile.getInputStream(); // 避免文件覆盖 String originalFilename = multipartFile.getOriginalFilename(); String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(\u0026#34;.\u0026#34;)); //上传文件到 OSS OSS ossClient = new OSSClientBuilder().build(aliOSSProperties.getEndpoint(), aliOSSProperties.getAccessKeyId(), aliOSSProperties.getAccessKeySecret()); ossClient.putObject(aliOSSProperties.getBucketName(), fileName, inputStream); //文件访问路径 String url =aliOSSProperties.getEndpoint().split(\u0026#34;//\u0026#34;)[0] + \u0026#34;//\u0026#34; + aliOSSProperties.getBucketName() + \u0026#34;.\u0026#34; + aliOSSProperties.getEndpoint().split(\u0026#34;//\u0026#34;)[1] + \u0026#34;/\u0026#34; + fileName; // 关闭ossClient ossClient.shutdown(); return url;// 把上传到oss的路径返回 } } 在aliyun-oss-spring-boot-autoconfigure模块中的resources下，新建自动配置文件：\nMETA-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports\n1 com.aliyun.oss.AliOSSAutoConfiguration 3.2.4.3 自定义starter测试 阿里云OSS的starter我们刚才已经定义好了，接下来我们就来做一个测试。\n今天的课程资料当中，提供了一个自定义starter的测试工程。我们直接打开文件夹，里面有一个测试工程。测试工程就是springboot-autoconfiguration-test，我们只需要将测试工程直接导入到Idea当中即可。\n测试前准备：\n在test工程中引入阿里云starter依赖\n通过依赖传递，会把autoconfigure依赖也引入了 1 2 3 4 5 6 \u0026lt;!--引入阿里云OSS起步依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-oss-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在test工程中的application.yml文件中，配置阿里云OSS配置参数信息（从以前的工程中拷贝即可）\n1 2 3 4 5 6 7 #配置阿里云OSS参数 aliyun: oss: endpoint: https://oss-cn-shanghai.aliyuncs.com accessKeyId: LTAI5t9MZK8iq5T2Av5GLDxX accessKeySecret: C0IrHzKZGKqU8S7YQcevcotD3Zd5Tc bucketName: web-framework01 在test工程中的UploadController类编写代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @RestController public class UploadController { @Autowired private AliOSSUtils aliOSSUtils; @PostMapping(\u0026#34;/upload\u0026#34;) public String upload(MultipartFile image) throws Exception { //上传文件到阿里云 OSS String url = aliOSSUtils.upload(image); return url; } } 编写完代码后，我们启动当前的SpringBoot测试工程：\n随着SpringBoot项目启动，自动配置会把AliOSSUtils的bean对象装配到IOC容器中 用postman工具进行文件上传：\n通过断点可以看到自动注入AliOSSUtils的bean对象：\n4. Web后端开发总结 到此基于SpringBoot进行web后端开发的相关知识我们已经学习完毕了。下面我们一起针对这段web课程做一个总结。\n我们来回顾一下关于web后端开发，我们都学习了哪些内容，以及每一块知识，具体是属于哪个框架的。\nweb后端开发现在基本上都是基于标准的三层架构进行开发的，在三层架构当中，Controller控制器层负责接收请求响应数据，Service业务层负责具体的业务逻辑处理，而Dao数据访问层也叫持久层，就是用来处理数据访问操作的，来完成数据库当中数据的增删改查操作。\n在三层架构当中，前端发起请求首先会到达Controller(不进行逻辑处理)，然后Controller会直接调用Service 进行逻辑处理， Service再调用Dao完成数据访问操作。\n如果我们在执行具体的业务处理之前，需要去做一些通用的业务处理，比如：我们要进行统一的登录校验，我们要进行统一的字符编码等这些操作时，我们就可以借助于Javaweb当中三大组件之一的过滤器Filter或者是Spring当中提供的拦截器Interceptor来实现。\n而为了实现三层架构层与层之间的解耦，我们学习了Spring框架当中的第一大核心：IOC控制反转与DI依赖注入。\n所谓控制反转，指的是将对象创建的控制权由应用程序自身交给外部容器，这个容器就是我们常说的IOC容器或Spring容器。\n而DI依赖注入指的是容器为程序提供运行时所需要的资源。\n除了IOC与DI我们还讲到了AOP面向切面编程，还有Spring中的事务管理、全局异常处理器，以及传递会话技术Cookie、Session以及新的会话跟踪解决方案JWT令牌，阿里云OSS对象存储服务，以及通过Mybatis持久层架构操作数据库等技术。\n我们在学习这些web后端开发技术的时候，我们都是基于主流的SpringBoot进行整合使用的。而SpringBoot又是用来简化开发，提高开发效率的。像过滤器、拦截器、IOC、DI、AOP、事务管理等这些技术到底是哪个框架提供的核心功能？\nFilter过滤器、Cookie、 Session这些都是传统的JavaWeb提供的技术。\nJWT令牌、阿里云OSS对象存储服务，是现在企业项目中常见的一些解决方案。\nIOC控制反转、DI依赖注入、AOP面向切面编程、事务管理、全局异常处理、拦截器等，这些技术都是 Spring Framework框架当中提供的核心功能。\nMybatis就是一个持久层的框架，是用来操作数据库的。\n在Spring框架的生态中，对web程序开发提供了很好的支持，如：全局异常处理器、拦截器这些都是Spring框架中web开发模块所提供的功能，而Spring框架的web开发模块，我们也称为：SpringMVC\nSpringMVC不是一个单独的框架，它是Spring框架的一部分，是Spring框架中的web开发模块，是用来简化原始的Servlet程序开发的。\n外界俗称的SSM，就是由：SpringMVC、Spring Framework、Mybatis三块组成。\n基于传统的SSM框架进行整合开发项目会比较繁琐，而且效率也比较低，所以在现在的企业项目开发当中，基本上都是直接基于SpringBoot整合SSM进行项目开发的。\n到此我们web后端开发的内容就已经全部讲解结束了。\n","date":"2024-07-05T22:27:20+08:00","image":"https://picsum.photos/800/600 ","permalink":"https://4evergreat.github.io/2024/springboot-blog-1/","title":"springboot-blog-1原理篇"},{"content":"事务\u0026amp;AOP 1. 事务管理 1.1 事务回顾 在数据库阶段我们已学习过事务了，我们讲到：\n事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体，一起向数据库提交或者是撤销操作请求。所以这组操作要么同时成功，要么同时失败。\n怎么样来控制这组操作，让这组操作同时成功或同时失败呢？此时就要涉及到事务的具体操作了。\n事务的操作主要有三步：\n开启事务（一组操作开始前，开启事务）：start transaction / begin ; 提交事务（这组操作全部成功后，提交事务）：commit ; 回滚事务（中间任何一个操作出现异常，回滚事务）：rollback ; 1.2 Spring事务管理 1.2.1 案例 简单的回顾了事务的概念以及事务的基本操作之后，接下来我们看一个事务管理案例：解散部门 （解散部门就是删除部门）\n需求：当部门解散了不仅需要把部门信息删除了，还需要把该部门下的员工数据也删除了。\n步骤：\n根据ID删除部门数据 根据部门ID删除该部门下的员工 代码实现：\nDeptServiceImpl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Slf4j @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; //根据部门id，删除部门信息及部门下的所有员工 @Override public void delete(Integer id){ //根据部门id删除部门信息 deptMapper.deleteById(id); //删除部门下的所有员工信息 empMapper.deleteByDeptId(id); } } DeptMapper 1 2 3 4 5 6 7 8 9 @Mapper public interface DeptMapper { /** * 根据id删除部门信息 * @param id 部门id */ @Delete(\u0026#34;delete from dept where id = #{id}\u0026#34;) void deleteById(Integer id); } EmpMapper 1 2 3 4 5 6 7 8 @Mapper public interface EmpMapper { //根据部门id删除部门下所有员工 @Delete(\u0026#34;delete from emp where dept_id=#{deptId}\u0026#34;) public int deleteByDeptId(Integer deptId); } 重启SpringBoot服务，使用postman测试部门删除：\n代码正常情况下，dept表和Em表中的数据已删除\n修改DeptServiceImpl类中代码，添加可能出现异常的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Slf4j @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; //根据部门id，删除部门信息及部门下的所有员工 @Override public void delete(Integer id){ //根据部门id删除部门信息 deptMapper.deleteById(id); //模拟：异常发生 int i = 1/0; //删除部门下的所有员工信息 empMapper.deleteByDeptId(id); } } 重启SpringBoot服务，使用postman测试部门删除：\n查看数据库表：\n删除了2号部门 2号部门下的员工数据没有删除 以上程序出现的问题：即使程序运行抛出了异常，部门依然删除了，但是部门下的员工却没有删除，造成了数据的不一致。\n1.2.2 原因分析 原因：\n先执行根据id删除部门的操作，这步执行完毕，数据库表 dept 中的数据就已经删除了。 执行 1/0 操作，抛出异常 抛出异常之前，下面所有的代码都不会执行了，根据部门ID删除该部门下的员工，这个操作也不会执行 。 此时就出现问题了，部门删除了，部门下的员工还在，业务操作前后数据不一致。\n而要想保证操作前后，数据的一致性，就需要让解散部门中涉及到的两个业务操作，要么全部成功，要么全部失败 。 那我们如何，让这两个操作要么全部成功，要么全部失败呢 ？\n那就可以通过事务来实现，因为一个事务中的多个业务操作，要么全部成功，要么全部失败。\n此时，我们就需要在delete删除业务功能中添加事务。\n在方法运行之前，开启事务，如果方法成功执行，就提交事务，如果方法执行的过程当中出现异常了，就回滚事务。\n思考：开发中所有的业务操作，一旦我们要进行控制事务，是不是都是这样的套路？\n答案：是的。\n所以在spring框架当中就已经把事务控制的代码都已经封装好了，并不需要我们手动实现。我们使用了spring框架，我们只需要通过一个简单的注解@Transactional就搞定了。\n1.2.3 Transactional注解 @Transactional作用：就是在当前这个方法执行开始之前来开启事务，方法执行完毕之后提交事务。如果在这个方法执行的过程当中出现了异常，就会进行事务的回滚操作。\n@Transactional注解：我们一般会在业务层当中来控制事务，因为在业务层当中，一个业务功能可能会包含多个数据访问的操作。在业务层来控制事务，我们就可以将多个数据访问操作控制在一个事务范围内。\n@Transactional注解书写位置：\n方法 当前方法交给spring进行事务管理 类 当前类中所有的方法都交由spring进行事务管理 接口 接口下所有的实现类当中所有的方法都交给spring 进行事务管理 接下来，我们就可以在业务方法delete上加上 @Transactional 来控制事务 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Slf4j @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; @Override @Transactional //当前方法添加了事务管理 public void delete(Integer id){ //根据部门id删除部门信息 deptMapper.deleteById(id); //模拟：异常发生 int i = 1/0; //删除部门下的所有员工信息 empMapper.deleteByDeptId(id); } } 在业务功能上添加@Transactional注解进行事务管理后，我们重启SpringBoot服务，使用postman测试：\n添加Spring事务管理后，由于服务端程序引发了异常，所以事务进行回滚。\n说明：可以在application.yml配置文件中开启事务管理日志，这样就可以在控制看到和事务相关的日志信息了\n1 2 3 4 #spring事务管理日志 logging: level: org.springframework.jdbc.support.JdbcTransactionManager: debug 1.3 事务进阶 前面我们通过spring事务管理注解@Transactional已经控制了业务层方法的事务。接下来我们要来详细的介绍一下@Transactional事务管理注解的使用细节。我们这里主要介绍@Transactional注解当中的两个常见的属性：\n异常回滚的属性：rollbackFor 事务传播行为：propagation 我们先来学习下rollbackFor属性。\n1.3.1 rollbackFor 我们在之前编写的业务方法上添加了@Transactional注解，来实现事务管理。\n1 2 3 4 5 6 7 8 9 10 11 @Transactional public void delete(Integer id){ //根据部门id删除部门信息 deptMapper.deleteById(id); //模拟：异常发生 int i = 1/0; //删除部门下的所有员工信息 empMapper.deleteByDeptId(id); } 以上业务功能delete()方法在运行时，会引发除0的算数运算异常(运行时异常)，出现异常之后，由于我们在方法上加了@Transactional注解进行事务管理，所以发生异常会执行rollback回滚操作，从而保证事务操作前后数据是一致的。\n下面我们在做一个测试，我们修改业务功能代码，在模拟异常的位置上直接抛出Exception异常（编译时异常）\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Transactional public void delete(Integer id) throws Exception { //根据部门id删除部门信息 deptMapper.deleteById(id); //模拟：异常发生 if(true){ throw new Exception(\u0026#34;出现异常了~~~\u0026#34;); } //删除部门下的所有员工信息 empMapper.deleteByDeptId(id); } 说明：在service中向上抛出一个Exception编译时异常之后，由于是controller调用service，所以在controller中要有异常处理代码，此时我们选择在controller中继续把异常向上抛。\n1 2 3 4 5 6 7 8 9 @DeleteMapping(\u0026#34;/depts/{id}\u0026#34;) public Result delete(@PathVariable Integer id) throws Exception { //日志记录 log.info(\u0026#34;根据id删除部门\u0026#34;); //调用service层功能 deptService.delete(id); //响应 return Result.success(); } 重新启动服务后测试：\n抛出异常之后事务会不会回滚\n现有表中数据：\n使用postman测试，删除5号部门\n发生了Exception异常，但事务依然提交了\ndept表中数据：\n通过以上测试可以得出一个结论：默认情况下，只有出现RuntimeException(运行时异常)才会回滚事务。\n假如我们想让所有的异常都回滚，需要来配置@Transactional注解当中的rollbackFor属性，通过rollbackFor这个属性可以指定出现何种异常类型回滚事务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Slf4j @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; @Override @Transactional(rollbackFor=Exception.class) public void delete(Integer id){ //根据部门id删除部门信息 deptMapper.deleteById(id); //模拟：异常发生 int num = id/0; //删除部门下的所有员工信息 empMapper.deleteByDeptId(id); } } 接下来我们重新启动服务，测试删除部门的操作：\n控制台日志：执行了删除3号部门的操作， 因为异常又进行了事务回滚\n数据表：3号部门没有删除\n结论：\n在Spring的事务管理中，默认只有运行时异常 RuntimeException才会回滚。 如果还需要回滚指定类型的异常，可以通过rollbackFor属性来指定。 1.3.3 propagation 1.3.3.1 介绍 我们接着继续学习@Transactional注解当中的第二个属性propagation，这个属性是用来配置事务的传播行为的。\n什么是事务的传播行为呢？\n就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制。 例如：两个事务方法，一个A方法，一个B方法。在这两个方法上都添加了@Transactional注解，就代表这两个方法都具有事务，而在A方法当中又去调用了B方法。\n所谓事务的传播行为，指的就是在A方法运行的时候，首先会开启一个事务，在A方法当中又调用了B方法， B方法自身也具有事务，那么B方法在运行的时候，到底是加入到A方法的事务当中来，还是B方法在运行的时候新建一个事务？这个就涉及到了事务的传播行为。\n我们要想控制事务的传播行为，在@Transactional注解的后面指定一个属性propagation，通过 propagation 属性来指定传播行为。接下来我们就来介绍一下常见的事务传播行为。\n属性值 含义 REQUIRED 【默认值】需要事务，有则加入，无则创建新事务 REQUIRES_NEW 需要新事务，无论有无，总是创建新事务 SUPPORTS 支持事务，有则加入，无则在无事务状态中运行 NOT_SUPPORTED 不支持事务，在无事务状态下运行,如果当前存在已有事务,则挂起当前事务 MANDATORY 必须有事务，否则抛异常 NEVER 必须没事务，否则抛异常 … 对于这些事务传播行为，我们只需要关注以下两个就可以了：\nREQUIRED（默认值） REQUIRES_NEW 1.3.3.2 案例 接下来我们就通过一个案例来演示下事务传播行为propagation属性的使用。\n**需求：**解散部门时需要记录操作日志\n​\t由于解散部门是一个非常重要而且非常危险的操作，所以在业务当中要求每一次执行解散部门的操作都需要留下痕迹，就是要记录操作日志。而且还要求无论是执行成功了还是执行失败了，都需要留下痕迹。\n步骤：\n执行解散部门的业务：先删除部门，再删除部门下的员工（前面已实现） 记录解散部门的日志，到日志表（未实现） 准备工作：\n创建数据库表 dept_log 日志表： 1 2 3 4 5 create table dept_log( id int auto_increment comment \u0026#39;主键ID\u0026#39; primary key, create_time datetime null comment \u0026#39;操作时间\u0026#39;, description varchar(300) null comment \u0026#39;操作描述\u0026#39; )comment \u0026#39;部门操作日志表\u0026#39;; 引入资料中提供的实体类：DeptLog 1 2 3 4 5 6 7 8 @Data @NoArgsConstructor @AllArgsConstructor public class DeptLog { private Integer id; private LocalDateTime createTime; private String description; } 引入资料中提供的Mapper接口：DeptLogMapper 1 2 3 4 5 6 7 @Mapper public interface DeptLogMapper { @Insert(\u0026#34;insert into dept_log(create_time,description) values(#{createTime},#{description})\u0026#34;) void insert(DeptLog log); } 引入资料中提供的业务接口：DeptLogService 1 2 3 public interface DeptLogService { void insert(DeptLog deptLog); } 引入资料中提供的业务实现类：DeptLogServiceImpl 1 2 3 4 5 6 7 8 9 10 11 12 @Service public class DeptLogServiceImpl implements DeptLogService { @Autowired private DeptLogMapper deptLogMapper; @Transactional //事务传播行为：有事务就加入、没有事务就新建事务 @Override public void insert(DeptLog deptLog) { deptLogMapper.insert(deptLog); } } 代码实现:\n业务实现类：DeptServiceImpl\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @Slf4j @Service //@Transactional //当前业务实现类中的所有的方法，都添加了spring事务管理机制 public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; @Autowired private DeptLogService deptLogService; //根据部门id，删除部门信息及部门下的所有员工 @Override @Log @Transactional(rollbackFor = Exception.class) public void delete(Integer id) throws Exception { try { //根据部门id删除部门信息 deptMapper.deleteById(id); //模拟：异常 if(true){ throw new Exception(\u0026#34;出现异常了~~~\u0026#34;); } //删除部门下的所有员工信息 empMapper.deleteByDeptId(id); }finally { //不论是否有异常，最终都要执行的代码：记录日志 DeptLog deptLog = new DeptLog(); deptLog.setCreateTime(LocalDateTime.now()); deptLog.setDescription(\u0026#34;执行了解散部门的操作，此时解散的是\u0026#34;+id+\u0026#34;号部门\u0026#34;); //调用其他业务类中的方法 deptLogService.insert(deptLog); } } //省略其他代码... } 测试:\n重新启动SpringBoot服务，测试删除3号部门后会发生什么？\n执行了删除3号部门操作 执行了插入部门日志操作 程序发生Exception异常 执行事务回滚（删除、插入操作因为在一个事务范围内，两个操作都会被回滚） 然后在dept_log表中没有记录日志数据\n原因分析:\n接下来我们就需要来分析一下具体是什么原因导致的日志没有成功的记录。\n在执行delete操作时开启了一个事务\n当执行insert操作时，insert设置的事务传播行是默认值REQUIRED，表示有事务就加入，没有则新建事务\n此时：delete和insert操作使用了同一个事务，同一个事务中的多个操作，要么同时成功，要么同时失败，所以当异常发生时进行事务回滚，就会回滚delete和insert操作\n解决方案：\n在DeptLogServiceImpl类中insert方法上，添加@Transactional(propagation = Propagation.REQUIRES_NEW)\nPropagation.REQUIRES_NEW ：不论是否有事务，都创建新事务 ，运行在一个独立的事务中。\n1 2 3 4 5 6 7 8 9 10 11 12 @Service public class DeptLogServiceImpl implements DeptLogService { @Autowired private DeptLogMapper deptLogMapper; @Transactional(propagation = Propagation.REQUIRES_NEW)//事务传播行为：不论是否有事务，都新建事务 @Override public void insert(DeptLog deptLog) { deptLogMapper.insert(deptLog); } } 重启SpringBoot服务，再次测试删除3号部门：\n那此时，DeptServiceImpl中的delete方法运行时，会开启一个事务。 当调用 deptLogService.insert(deptLog) 时，也会创建一个新的事务，那此时，当insert方法运行完毕之后，事务就已经提交了。 即使外部的事务出现异常，内部已经提交的事务，也不会回滚了，因为是两个独立的事务。\n到此事务传播行为已演示完成，事务的传播行为我们只需要掌握两个：REQUIRED、REQUIRES_NEW。\nREQUIRED ：大部分情况下都是用该传播行为即可。\nREQUIRES_NEW ：当我们不希望事务之间相互影响时，可以使用该传播行为。比如：下订单前需要记录日志，不论订单保存成功与否，都需要保证日志记录能够记录成功。\n2. AOP基础 学习完spring的事务管理之后，接下来我们进入到AOP的学习。 AOP也是spring框架的第二大核心，我们先来学习AOP的基础。\n在AOP基础这个阶段，我们首先介绍一下什么是AOP，再通过一个快速入门程序，让大家快速体验AOP程序的开发。最后再介绍AOP当中所涉及到的一些核心的概念。\n2.1 AOP概述 什么是AOP？\nAOP英文全称：Aspect Oriented Programming（面向切面编程、面向方面编程），其实说白了，面向切面编程就是面向特定方法编程。 那什么又是面向方法编程呢，为什么又需要面向方法编程呢？来我们举个例子做一个说明：\n比如，我们这里有一个项目，项目中开发了很多的业务功能。\n然而有一些业务功能执行效率比较低，执行耗时较长，我们需要针对于这些业务方法进行优化。 那首先第一步就需要定位出执行耗时比较长的业务方法，再针对于业务方法再来进行优化。\n此时我们就需要统计当前这个项目当中每一个业务方法的执行耗时。那么统计每一个业务方法的执行耗时该怎么实现？\n可能多数人首先想到的就是在每一个业务方法运行之前，记录这个方法运行的开始时间。在这个方法运行完毕之后，再来记录这个方法运行的结束时间。拿结束时间减去开始时间，不就是这个方法的执行耗时吗？\n以上分析的实现方式是可以解决需求问题的。但是对于一个项目来讲，里面会包含很多的业务模块，每个业务模块又包含很多增删改查的方法，如果我们要在每一个模块下的业务方法中，添加记录开始时间、结束时间、计算执行耗时的代码，就会让程序员的工作变得非常繁琐。\n而AOP面向方法编程，就可以做到在不改动这些原始方法的基础上，针对特定的方法进行功能的增强。\nAOP的作用：在程序运行期间在不修改源代码的基础上对已有方法进行增强（无侵入性: 解耦）\n我们要想完成统计各个业务方法执行耗时的需求，我们只需要定义一个模板方法，将记录方法执行耗时这一部分公共的逻辑代码，定义在模板方法当中，在这个方法开始运行之前，来记录这个方法运行的开始时间，在方法结束运行的时候，再来记录方法运行的结束时间，中间就来运行原始的业务方法。\n而中间运行的原始业务方法，可能是其中的一个业务方法，比如：我们只想通过 部门管理的 list 方法的执行耗时，那就只有这一个方法是原始业务方法。 而如果，我们是先想统计所有部门管理的业务方法执行耗时，那此时，所有的部门管理的业务方法都是 原始业务方法。 那面向这样的指定的一个或多个方法进行编程，我们就称之为 面向切面编程。\n那此时，当我们再调用部门管理的 list 业务方法时啊，并不会直接执行 list 方法的逻辑，而是会执行我们所定义的 模板方法 ， 然后再模板方法中：\n记录方法运行开始时间 运行原始的业务方法（那此时原始的业务方法，就是 list 方法） 记录方法运行结束时间，计算方法执行耗时 不论，我们运行的是那个业务方法，最后其实运行的就是我们定义的模板方法，而在模板方法中，就完成了原始方法执行耗时的统计操作 。(那这样呢，我们就通过一个模板方法就完成了指定的一个或多个业务方法执行耗时的统计)\n而大家会发现，这个流程，我们是不是似曾相识啊？\n对了，就是和我们之前所学习的动态代理技术是非常类似的。 我们所说的模板方法，其实就是代理对象中所定义的方法，那代理对象中的方法以及根据对应的业务需要， 完成了对应的业务功能，当运行原始业务方法时，就会运行代理对象中的方法，从而实现统计业务方法执行耗时的操作。\n其实，AOP面向切面编程和OOP面向对象编程一样，它们都仅仅是一种编程思想，而动态代理技术是这种思想最主流的实现方式。而Spring的AOP是Spring框架的高级技术，旨在管理bean对象的过程中底层使用动态代理机制，对特定的方法进行编程(功能增强)。\nAOP的优势：\n减少重复代码 提高开发效率 维护方便 2.2 AOP快速入门 在了解了什么是AOP后，我们下面通过一个快速入门程序，体验下AOP的开发，并掌握Spring中AOP的开发步骤。\n**需求：**统计各个业务层方法执行耗时。\n实现步骤：\n导入依赖：在pom.xml中导入AOP的依赖 编写AOP程序：针对于特定方法根据业务需要进行编程 为演示方便，可以自建新项目或导入提供的springboot-aop-quickstart项目工程\npom.xml\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-aop\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; AOP程序：TimeAspect\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Component @Aspect //当前类为切面类 @Slf4j public class TimeAspect { @Around(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) public Object recordTime(ProceedingJoinPoint pjp) throws Throwable { //记录方法执行开始时间 long begin = System.currentTimeMillis(); //执行原始方法 Object result = pjp.proceed(); //记录方法执行结束时间 long end = System.currentTimeMillis(); //计算方法执行耗时 log.info(pjp.getSignature()+\u0026#34;执行耗时: {}毫秒\u0026#34;,end-begin); return result; } } 重新启动SpringBoot服务测试程序：\n查询3号部门信息 我们可以再测试下：查询所有部门信息（同样执行AOP程序）\n我们通过AOP入门程序完成了业务方法执行耗时的统计，那其实AOP的功能远不止于此，常见的应用场景如下：\n记录系统的操作日志 权限控制 事务管理：我们前面所讲解的Spring事务管理，底层其实也是通过AOP来实现的，只要添加@Transactional注解之后，AOP程序自动会在原始方法运行前先来开启事务，在原始方法运行完毕之后提交或回滚事务 这些都是AOP应用的典型场景。\n通过入门程序，我们也应该感受到了AOP面向切面编程的一些优势：\n代码无侵入：没有修改原始的业务方法，就已经对原始的业务方法进行了功能的增强或者是功能的改变\n减少了重复代码\n提高开发效率\n维护方便\n2.3 AOP核心概念 通过SpringAOP的快速入门，感受了一下AOP面向切面编程的开发方式。下面我们再来学习AOP当中涉及到的一些核心概念。\n1. 连接点：JoinPoint，可以被AOP控制的方法（暗含方法执行时的相关信息）\n​\t连接点指的是可以被aop控制的方法。例如：入门程序当中所有的业务方法都是可以被aop控制的方法。\n​\t​\t在SpringAOP提供的JoinPoint当中，封装了连接点方法在执行时的相关信息。（后面会有具体的讲解）\n2. 通知：Advice，指哪些重复的逻辑，也就是共性功能（最终体现为一个方法）\n​\t在入门程序中是需要统计各个业务方法的执行耗时的，此时我们就需要在这些业务方法运行开始之前，先记录这个方法运行的开始时间，在每一个业务方法运行结束的时候，再来记录这个方法运行的结束时间。\n​\t但是在AOP面向切面编程当中，我们只需要将这部分重复的代码逻辑抽取出来单独定义。抽取出来的这一部分重复的逻辑，也就是共性的功能。\n​\t​\n3. 切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法执行时被应用\n​\t在通知当中，我们所定义的共性功能到底要应用在哪些方法上？此时就涉及到了切入点pointcut概念。切入点指的是匹配连接点的条件。通知仅会在切入点方法运行时才会被应用。\n​\t在aop的开发当中，我们通常会通过一个切入点表达式来描述切入点(后面会有详解)。\n​\t​\t假如：切入点表达式改为DeptServiceImpl.list()，此时就代表仅仅只有list这一个方法是切入点。只有list()方法在运行的时候才会应用通知。\n​\n4. 切面：Aspect，描述通知与切入点的对应关系（通知+切入点）\n​\t当通知和切入点结合在一起，就形成了一个切面。通过切面就能够描述当前aop程序需要针对于哪个原始方法，在什么时候执行什么样的操作。\n​\t​\t切面所在的类，我们一般称为切面类（被@Aspect注解标识的类）\n​\n5. 目标对象：Target，通知所应用的对象\n​\t目标对象指的就是通知所应用的对象，我们就称之为目标对象。\n​\tAOP的核心概念我们介绍完毕之后，接下来我们再来分析一下我们所定义的通知是如何与目标对象结合在一起，对目标对象当中的方法进行功能增强的。\nSpring的AOP底层是基于动态代理技术来实现的，也就是说在程序运行的时候，会自动的基于动态代理技术为目标对象生成一个对应的代理对象。在代理对象当中就会对目标对象当中的原始方法进行功能的增强。\n3. AOP进阶 AOP的基础知识学习完之后，下面我们对AOP当中的各个细节进行详细的学习。主要分为4个部分：\n通知类型 通知顺序 切入点表达式 连接点 我们先来学习第一部分通知类型。\n3.1 通知类型 在入门程序当中，我们已经使用了一种功能最为强大的通知类型：Around环绕通知。\n1 2 3 4 5 6 7 8 9 10 11 12 @Around(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) public Object recordTime(ProceedingJoinPoint pjp) throws Throwable { //记录方法执行开始时间 long begin = System.currentTimeMillis(); //执行原始方法 Object result = pjp.proceed(); //记录方法执行结束时间 long end = System.currentTimeMillis(); //计算方法执行耗时 log.info(pjp.getSignature()+\u0026#34;执行耗时: {}毫秒\u0026#34;,end-begin); return result; } 只要我们在通知方法上加上了@Around注解，就代表当前通知是一个环绕通知。\nSpring中AOP的通知类型：\n@Around：环绕通知，此注解标注的通知方法在目标方法前、后都被执行 @Before：前置通知，此注解标注的通知方法在目标方法前被执行 @After ：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行 @AfterReturning ： 返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行 @AfterThrowing ： 异常后通知，此注解标注的通知方法发生异常后执行 下面我们通过代码演示，来加深对于不同通知类型的理解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @Slf4j @Component @Aspect public class MyAspect1 { //前置通知 @Before(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) public void before(JoinPoint joinPoint){ log.info(\u0026#34;before ...\u0026#34;); } //环绕通知 @Around(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { log.info(\u0026#34;around before ...\u0026#34;); //调用目标对象的原始方法执行 Object result = proceedingJoinPoint.proceed(); //原始方法如果执行时有异常，环绕通知中的后置代码不会在执行了 log.info(\u0026#34;around after ...\u0026#34;); return result; } //后置通知 @After(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) public void after(JoinPoint joinPoint){ log.info(\u0026#34;after ...\u0026#34;); } //返回后通知（程序在正常执行的情况下，会执行的后置通知） @AfterReturning(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) public void afterReturning(JoinPoint joinPoint){ log.info(\u0026#34;afterReturning ...\u0026#34;); } //异常通知（程序在出现异常的情况下，执行的后置通知） @AfterThrowing(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) public void afterThrowing(JoinPoint joinPoint){ log.info(\u0026#34;afterThrowing ...\u0026#34;); } } 重新启动SpringBoot服务，进行测试：\n1. 没有异常情况下：\n使用postman测试查询所有部门数据 查看idea中控制台日志输出 程序没有发生异常的情况下，@AfterThrowing标识的通知方法不会执行。\n2. 出现异常情况下：\n修改DeptServiceImpl业务实现类中的代码： 添加异常\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Slf4j @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Override public List\u0026lt;Dept\u0026gt; list() { List\u0026lt;Dept\u0026gt; deptList = deptMapper.list(); //模拟异常 int num = 10/0; return deptList; } //省略其他代码... } 重新启动SpringBoot服务，测试发生异常情况下通知的执行：\n查看idea中控制台日志输出 程序发生异常的情况下：\n@AfterReturning标识的通知方法不会执行，@AfterThrowing标识的通知方法执行了\n@Around环绕通知中原始方法调用时有异常，通知中的环绕后的代码逻辑也不会在执行了 （因为原始方法调用已经出异常了）\n在使用通知时的注意事项：\n@Around环绕通知需要自己调用 ProceedingJoinPoint.proceed() 来让原始方法执行，其他通知不需要考虑目标方法执行 @Around环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值，否则原始方法执行完毕，是获取不到返回值的。 五种常见的通知类型，我们已经测试完毕了，此时我们再来看一下刚才所编写的代码，有什么问题吗？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //前置通知 @Before(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) //环绕通知 @Around(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) //后置通知 @After(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) //返回后通知（程序在正常执行的情况下，会执行的后置通知） @AfterReturning(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) //异常通知（程序在出现异常的情况下，执行的后置通知） @AfterThrowing(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) 我们发现啊，每一个注解里面都指定了切入点表达式，而且这些切入点表达式都一模一样。此时我们的代码当中就存在了大量的重复性的切入点表达式，假如此时切入点表达式需要变动，就需要将所有的切入点表达式一个一个的来改动，就变得非常繁琐了。\n怎么来解决这个切入点表达式重复的问题？ 答案就是：抽取\nSpring提供了@PointCut注解，该注解的作用是将公共的切入点表达式抽取出来，需要用到时引用该切入点表达式即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @Slf4j @Component @Aspect public class MyAspect1 { //切入点方法（公共的切入点表达式） @Pointcut(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) private void pt(){ } //前置通知（引用切入点） @Before(\u0026#34;pt()\u0026#34;) public void before(JoinPoint joinPoint){ log.info(\u0026#34;before ...\u0026#34;); } //环绕通知 @Around(\u0026#34;pt()\u0026#34;) public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { log.info(\u0026#34;around before ...\u0026#34;); //调用目标对象的原始方法执行 Object result = proceedingJoinPoint.proceed(); //原始方法在执行时：发生异常 //后续代码不在执行 log.info(\u0026#34;around after ...\u0026#34;); return result; } //后置通知 @After(\u0026#34;pt()\u0026#34;) public void after(JoinPoint joinPoint){ log.info(\u0026#34;after ...\u0026#34;); } //返回后通知（程序在正常执行的情况下，会执行的后置通知） @AfterReturning(\u0026#34;pt()\u0026#34;) public void afterReturning(JoinPoint joinPoint){ log.info(\u0026#34;afterReturning ...\u0026#34;); } //异常通知（程序在出现异常的情况下，执行的后置通知） @AfterThrowing(\u0026#34;pt()\u0026#34;) public void afterThrowing(JoinPoint joinPoint){ log.info(\u0026#34;afterThrowing ...\u0026#34;); } } 需要注意的是：当切入点方法使用private修饰时，仅能在当前切面类中引用该表达式， 当外部其他切面类中也要引用当前类中的切入点表达式，就需要把private改为public，而在引用的时候，具体的语法为：\n全类名.方法名()，具体形式如下：\n1 2 3 4 5 6 7 8 9 10 @Slf4j @Component @Aspect public class MyAspect2 { //引用MyAspect1切面类中的切入点表达式 @Before(\u0026#34;com.itheima.aspect.MyAspect1.pt()\u0026#34;) public void before(){ log.info(\u0026#34;MyAspect2 -\u0026gt; before ...\u0026#34;); } } 3.2 通知顺序 讲解完了Spring中AOP所支持的5种通知类型之后，接下来我们再来研究通知的执行顺序。\n当在项目开发当中，我们定义了多个切面类，而多个切面类中多个切入点都匹配到了同一个目标方法。此时当目标方法在运行的时候，这多个切面类当中的这些通知方法都会运行。\n此时我们就有一个疑问，这多个通知方法到底哪个先运行，哪个后运行？ 下面我们通过程序来验证（这里呢，我们就定义两种类型的通知进行测试，一种是前置通知@Before，一种是后置通知@After）\n定义多个切面类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Slf4j @Component @Aspect public class MyAspect2 { //前置通知 @Before(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) public void before(){ log.info(\u0026#34;MyAspect2 -\u0026gt; before ...\u0026#34;); } //后置通知 @After(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) public void after(){ log.info(\u0026#34;MyAspect2 -\u0026gt; after ...\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Slf4j @Component @Aspect public class MyAspect3 { //前置通知 @Before(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) public void before(){ log.info(\u0026#34;MyAspect3 -\u0026gt; before ...\u0026#34;); } //后置通知 @After(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) public void after(){ log.info(\u0026#34;MyAspect3 -\u0026gt; after ...\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Slf4j @Component @Aspect public class MyAspect4 { //前置通知 @Before(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) public void before(){ log.info(\u0026#34;MyAspect4 -\u0026gt; before ...\u0026#34;); } //后置通知 @After(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) public void after(){ log.info(\u0026#34;MyAspect4 -\u0026gt; after ...\u0026#34;); } } 重新启动SpringBoot服务，测试通知的执行顺序：\n备注：\n把DeptServiceImpl实现类中模拟异常的代码删除或注释掉。\n注释掉其他切面类(把@Aspect注释即可)，仅保留MyAspect2、MyAspect3、MyAspect4 ，这样就可以清晰看到执行的结果，而不被其他切面类干扰。\n使用postman测试查询所有部门数据 查看idea中控制台日志输出 通过以上程序运行可以看出在不同切面类中，默认按照切面类的类名字母排序：\n目标方法前的通知方法：字母排名靠前的先执行 目标方法后的通知方法：字母排名靠前的后执行 如果我们想控制通知的执行顺序有两种方式：\n修改切面类的类名（这种方式非常繁琐、而且不便管理） 使用Spring提供的@Order注解 使用@Order注解，控制通知的执行顺序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Slf4j @Component @Aspect @Order(2) //切面类的执行顺序（前置通知：数字越小先执行; 后置通知：数字越小越后执行） public class MyAspect2 { //前置通知 @Before(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) public void before(){ log.info(\u0026#34;MyAspect2 -\u0026gt; before ...\u0026#34;); } //后置通知 @After(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) public void after(){ log.info(\u0026#34;MyAspect2 -\u0026gt; after ...\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Slf4j @Component @Aspect @Order(3) //切面类的执行顺序（前置通知：数字越小先执行; 后置通知：数字越小越后执行） public class MyAspect3 { //前置通知 @Before(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) public void before(){ log.info(\u0026#34;MyAspect3 -\u0026gt; before ...\u0026#34;); } //后置通知 @After(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) public void after(){ log.info(\u0026#34;MyAspect3 -\u0026gt; after ...\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Slf4j @Component @Aspect @Order(1) //切面类的执行顺序（前置通知：数字越小先执行; 后置通知：数字越小越后执行） public class MyAspect4 { //前置通知 @Before(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) public void before(){ log.info(\u0026#34;MyAspect4 -\u0026gt; before ...\u0026#34;); } //后置通知 @After(\u0026#34;execution(* com.itheima.service.*.*(..))\u0026#34;) public void after(){ log.info(\u0026#34;MyAspect4 -\u0026gt; after ...\u0026#34;); } } 重新启动SpringBoot服务，测试通知执行顺序：\n通知的执行顺序大家主要知道两点即可：\n不同的切面类当中，默认情况下通知的执行顺序是与切面类的类名字母排序是有关系的 可以在切面类上面加上@Order注解，来控制不同的切面类通知的执行顺序 3.3 切入点表达式 从AOP的入门程序到现在，我们一直都在使用切入点表达式来描述切入点。下面我们就来详细的介绍一下切入点表达式的具体写法。\n切入点表达式：\n描述切入点方法的一种表达式\n作用：主要用来决定项目中的哪些方法需要加入通知\n常见形式：\nexecution(……)：根据方法的签名来匹配 @annotation(……) ：根据注解匹配 首先我们先学习第一种最为常见的execution切入点表达式。\n3.3.1 execution execution主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配，语法为：\n1 execution(访问修饰符? 返回值 包名.类名.?方法名(方法参数) throws 异常?) 其中带?的表示可以省略的部分\n访问修饰符：可省略（比如: public、protected）\n包名.类名： 可省略\nthrows 异常：可省略（注意是方法上声明抛出的异常，不是实际抛出的异常）\n示例：\n1 @Before(\u0026#34;execution(void com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer))\u0026#34;) 可以使用通配符描述切入点\n* ：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分\n.. ：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数\n切入点表达式的语法规则：\n方法的访问修饰符可以省略 返回值可以使用*号代替（任意返回值类型） 包名可以使用*号代替，代表任意包（一层包使用一个*） 使用..配置包名，标识此包以及此包下的所有子包 类名可以使用*号代替，标识任意类 方法名可以使用*号代替，表示任意方法 可以使用 * 配置参数，一个任意类型的参数 可以使用.. 配置参数，任意个任意类型的参数 切入点表达式示例\n省略方法的修饰符号\n1 execution(void com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer)) 使用*代替返回值类型\n1 execution(* com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer)) 使用*代替包名（一层包使用一个*）\n1 execution(* com.itheima.*.*.DeptServiceImpl.delete(java.lang.Integer)) 使用..省略包名\n1 execution(* com..DeptServiceImpl.delete(java.lang.Integer)) 使用*代替类名\n1 execution(* com..*.delete(java.lang.Integer)) 使用*代替方法名\n1 execution(* com..*.*(java.lang.Integer)) 使用 * 代替参数\n1 execution(* com.itheima.service.impl.DeptServiceImpl.delete(*)) 使用..省略参数\n1 execution(* com..*.*(..)) ​\n注意事项：\n根据业务需要，可以使用 且（\u0026amp;\u0026amp;）、或（||）、非（!） 来组合比较复杂的切入点表达式。\n1 execution(* com.itheima.service.DeptService.list(..)) || execution(* com.itheima.service.DeptService.delete(..)) 切入点表达式的书写建议：\n所有业务方法名在命名时尽量规范，方便切入点表达式快速匹配。如：查询类方法都是 find 开头，更新类方法都是update开头\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //业务类 @Service public class DeptServiceImpl implements DeptService { public List\u0026lt;Dept\u0026gt; findAllDept() { //省略代码... } public Dept findDeptById(Integer id) { //省略代码... } public void updateDeptById(Integer id) { //省略代码... } public void updateDeptByMoreCondition(Dept dept) { //省略代码... } //其他代码... } 1 2 //匹配DeptServiceImpl类中以find开头的方法 execution(* com.itheima.service.impl.DeptServiceImpl.find*(..)) 描述切入点方法通常基于接口描述，而不是直接描述实现类，增强拓展性\n1 execution(* com.itheima.service.DeptService.*(..)) 在满足业务需要的前提下，尽量缩小切入点的匹配范围。如：包名匹配尽量不使用 ..，使用 * 匹配单个包\n1 execution(* com.itheima.*.*.DeptServiceImpl.find*(..)) 3.3.2 @annotation 已经学习了execution切入点表达式的语法。那么如果我们要匹配多个无规则的方法，比如：list()和 delete()这两个方法。这个时候我们基于execution这种切入点表达式来描述就不是很方便了。而在之前我们是将两个切入点表达式组合在了一起完成的需求，这个是比较繁琐的。\n我们可以借助于另一种切入点表达式annotation来描述这一类的切入点，从而来简化切入点表达式的书写。\n实现步骤：\n编写自定义注解\n在业务类要做为连接点的方法上添加自定义注解\n自定义注解：MyLog\n1 2 3 4 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface MyLog { } 业务类：DeptServiceImpl\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @Slf4j @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Override @MyLog //自定义注解（表示：当前方法属于目标方法） public List\u0026lt;Dept\u0026gt; list() { List\u0026lt;Dept\u0026gt; deptList = deptMapper.list(); //模拟异常 //int num = 10/0; return deptList; } @Override @MyLog //自定义注解（表示：当前方法属于目标方法） public void delete(Integer id) { //1. 删除部门 deptMapper.delete(id); } @Override public void save(Dept dept) { dept.setCreateTime(LocalDateTime.now()); dept.setUpdateTime(LocalDateTime.now()); deptMapper.save(dept); } @Override public Dept getById(Integer id) { return deptMapper.getById(id); } @Override public void update(Dept dept) { dept.setUpdateTime(LocalDateTime.now()); deptMapper.update(dept); } } 切面类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Slf4j @Component @Aspect public class MyAspect6 { //针对list方法、delete方法进行前置通知和后置通知 //前置通知 @Before(\u0026#34;@annotation(com.itheima.anno.MyLog)\u0026#34;) public void before(){ log.info(\u0026#34;MyAspect6 -\u0026gt; before ...\u0026#34;); } //后置通知 @After(\u0026#34;@annotation(com.itheima.anno.MyLog)\u0026#34;) public void after(){ log.info(\u0026#34;MyAspect6 -\u0026gt; after ...\u0026#34;); } } 重启SpringBoot服务，测试查询所有部门数据，查看控制台日志：\n到此我们两种常见的切入点表达式我已经介绍完了。\nexecution切入点表达式 根据我们所指定的方法的描述信息来匹配切入点方法，这种方式也是最为常用的一种方式 如果我们要匹配的切入点方法的方法名不规则，或者有一些比较特殊的需求，通过execution切入点表达式描述比较繁琐 annotation 切入点表达式 基于注解的方式来匹配切入点方法。这种方式虽然多一步操作，我们需要自定义一个注解，但是相对来比较灵活。我们需要匹配哪个方法，就在方法上加上对应的注解就可以了 3.4 连接点 讲解完了切入点表达式之后，接下来我们再来讲解最后一个部分连接点。我们前面在讲解AOP核心概念的时候，我们提到过什么是连接点，连接点可以简单理解为可以被AOP控制的方法。\n我们目标对象当中所有的方法是不是都是可以被AOP控制的方法。而在SpringAOP当中，连接点又特指方法的执行。\n在Spring中用JoinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等。\n对于@Around通知，获取连接点信息只能使用ProceedingJoinPoint类型\n对于其他四种通知，获取连接点信息只能使用JoinPoint，它是ProceedingJoinPoint的父类型\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @Slf4j @Component @Aspect public class MyAspect7 { @Pointcut(\u0026#34;@annotation(com.itheima.anno.MyLog)\u0026#34;) private void pt(){} //前置通知 @Before(\u0026#34;pt()\u0026#34;) public void before(JoinPoint joinPoint){ log.info(joinPoint.getSignature().getName() + \u0026#34; MyAspect7 -\u0026gt; before ...\u0026#34;); } //后置通知 @Before(\u0026#34;pt()\u0026#34;) public void after(JoinPoint joinPoint){ log.info(joinPoint.getSignature().getName() + \u0026#34; MyAspect7 -\u0026gt; after ...\u0026#34;); } //环绕通知 @Around(\u0026#34;pt()\u0026#34;) public Object around(ProceedingJoinPoint pjp) throws Throwable { //获取目标类名 String name = pjp.getTarget().getClass().getName(); log.info(\u0026#34;目标类名：{}\u0026#34;,name); //目标方法名 String methodName = pjp.getSignature().getName(); log.info(\u0026#34;目标方法名：{}\u0026#34;,methodName); //获取方法执行时需要的参数 Object[] args = pjp.getArgs(); log.info(\u0026#34;目标方法参数：{}\u0026#34;, Arrays.toString(args)); //执行原始方法 Object returnValue = pjp.proceed(); return returnValue; } } 重新启动SpringBoot服务，执行查询部门数据的功能：\n4. AOP案例 SpringAOP的相关知识我们就已经全部学习完毕了。最后我们要通过一个案例来对AOP进行一个综合的应用。\n4.1 需求 需求：将案例中增、删、改相关接口的操作日志记录到数据库表中\n就是当访问部门管理和员工管理当中的增、删、改相关功能接口时，需要详细的操作日志，并保存在数据表中，便于后期数据追踪。 操作日志信息包含：\n操作人、操作时间、执行方法的全类名、执行方法名、方法运行时参数、返回值、方法执行时长 所记录的日志信息包括当前接口的操作人是谁操作的，什么时间点操作的，以及访问的是哪个类当中的哪个方法，在访问这个方法的时候传入进来的参数是什么，访问这个方法最终拿到的返回值是什么，以及整个接口方法的运行时长是多长时间。\n4.2 分析 问题1：项目当中增删改相关的方法是不是有很多？\n很多 问题2：我们需要针对每一个功能接口方法进行修改，在每一个功能接口当中都来记录这些操作日志吗？\n这种做法比较繁琐 以上两个问题的解决方案：可以使用AOP解决(每一个增删改功能接口中要实现的记录操作日志的逻辑代码是相同)。\n可以把这部分记录操作日志的通用的、重复性的逻辑代码抽取出来定义在一个通知方法当中，我们通过AOP面向切面编程的方式，在不改动原始功能的基础上来对原始的功能进行增强。目前我们所增强的功能就是来记录操作日志，所以也可以使用AOP的技术来实现。使用AOP的技术来实现也是最为简单，最为方便的。\n问题3：既然要基于AOP面向切面编程的方式来完成的功能，那么我们要使用 AOP五种通知类型当中的哪种通知类型？\n答案：环绕通知 所记录的操作日志当中包括：操作人、操作时间，访问的是哪个类、哪个方法、方法运行时参数、方法的返回值、方法的运行时长。\n方法返回值，是在原始方法执行后才能获取到的。\n方法的运行时长，需要原始方法运行之前记录开始时间，原始方法运行之后记录结束时间。通过计算获得方法的执行耗时。\n基于以上的分析我们确定要使用Around环绕通知。\n问题4：最后一个问题，切入点表达式我们该怎么写？\n答案：使用annotation来描述表达式 要匹配业务接口当中所有的增删改的方法，而增删改方法在命名上没有共同的前缀或后缀。此时如果使用execution切入点表达式也可以，但是会比较繁琐。 当遇到增删改的方法名没有规律时，就可以使用 annotation切入点表达式\n4.3 步骤 简单分析了一下大概的实现思路后，接下来我们就要来完成案例了。案例的实现步骤其实就两步：\n准备工作 引入AOP的起步依赖 导入资料中准备好的数据库表结构，并引入对应的实体类 编码实现 自定义注解@Log 定义切面类，完成记录操作日志的逻辑 4.4 实现 4.4.1 准备工作 AOP起步依赖 1 2 3 4 5 \u0026lt;!--AOP起步依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-aop\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 导入资料中准备好的数据库表结构，并引入对应的实体类 数据表\n1 2 3 4 5 6 7 8 9 10 11 -- 操作日志表 create table operate_log( id int unsigned primary key auto_increment comment \u0026#39;ID\u0026#39;, operate_user int unsigned comment \u0026#39;操作人\u0026#39;, operate_time datetime comment \u0026#39;操作时间\u0026#39;, class_name varchar(100) comment \u0026#39;操作的类名\u0026#39;, method_name varchar(100) comment \u0026#39;操作的方法名\u0026#39;, method_params varchar(1000) comment \u0026#39;方法参数\u0026#39;, return_value varchar(2000) comment \u0026#39;返回值\u0026#39;, cost_time bigint comment \u0026#39;方法执行耗时, 单位:ms\u0026#39; ) comment \u0026#39;操作日志表\u0026#39;; 实体类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //操作日志实体类 @Data @NoArgsConstructor @AllArgsConstructor public class OperateLog { private Integer id; //主键ID private Integer operateUser; //操作人ID private LocalDateTime operateTime; //操作时间 private String className; //操作类名 private String methodName; //操作方法名 private String methodParams; //操作方法参数 private String returnValue; //操作方法返回值 private Long costTime; //操作耗时 } Mapper接口\n1 2 3 4 5 6 7 8 9 @Mapper public interface OperateLogMapper { //插入日志数据 @Insert(\u0026#34;insert into operate_log (operate_user, operate_time, class_name, method_name, method_params, return_value, cost_time) \u0026#34; + \u0026#34;values (#{operateUser}, #{operateTime}, #{className}, #{methodName}, #{methodParams}, #{returnValue}, #{costTime});\u0026#34;) public void insert(OperateLog log); } 4.4.2 编码实现 自定义注解@Log 1 2 3 4 5 6 7 8 /** * 自定义Log注解 */ @Target({ElementType.METHOD}) @Documented @Retention(RetentionPolicy.RUNTIME) public @interface Log { } 修改业务实现类，在增删改业务方法上添加@Log注解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Slf4j @Service public class EmpServiceImpl implements EmpService { @Autowired private EmpMapper empMapper; @Override @Log public void update(Emp emp) { emp.setUpdateTime(LocalDateTime.now()); //更新修改时间为当前时间 empMapper.update(emp); } @Override @Log public void save(Emp emp) { //补全数据 emp.setCreateTime(LocalDateTime.now()); emp.setUpdateTime(LocalDateTime.now()); //调用添加方法 empMapper.insert(emp); } @Override @Log public void delete(List\u0026lt;Integer\u0026gt; ids) { empMapper.delete(ids); } //省略其他代码... } 以同样的方式，修改EmpServiceImpl业务类\n定义切面类，完成记录操作日志的逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @Slf4j @Component @Aspect //切面类 public class LogAspect { @Autowired private HttpServletRequest request; @Autowired private OperateLogMapper operateLogMapper; @Around(\u0026#34;@annotation(com.itheima.anno.Log)\u0026#34;) public Object recordLog(ProceedingJoinPoint joinPoint) throws Throwable { //操作人ID - 当前登录员工ID //获取请求头中的jwt令牌, 解析令牌 String jwt = request.getHeader(\u0026#34;token\u0026#34;); Claims claims = JwtUtils.parseJWT(jwt); Integer operateUser = (Integer) claims.get(\u0026#34;id\u0026#34;); //操作时间 LocalDateTime operateTime = LocalDateTime.now(); //操作类名 String className = joinPoint.getTarget().getClass().getName(); //操作方法名 String methodName = joinPoint.getSignature().getName(); //操作方法参数 Object[] args = joinPoint.getArgs(); String methodParams = Arrays.toString(args); long begin = System.currentTimeMillis(); //调用原始目标方法运行 Object result = joinPoint.proceed(); long end = System.currentTimeMillis(); //方法返回值 String returnValue = JSONObject.toJSONString(result); //操作耗时 Long costTime = end - begin; //记录操作日志 OperateLog operateLog = new OperateLog(null,operateUser,operateTime,className,methodName,methodParams,returnValue,costTime); operateLogMapper.insert(operateLog); log.info(\u0026#34;AOP记录操作日志: {}\u0026#34; , operateLog); return result; } } 代码实现细节： 获取request对象，从请求头中获取到jwt令牌，解析令牌获取出当前用户的id。\n重启SpringBoot服务，测试操作日志记录功能：\n添加一个新的部门 数据表 ","date":"2024-07-05T22:27:20+08:00","image":"https://picsum.photos/800/600 ","permalink":"https://4evergreat.github.io/2024/springboot-blog-2/","title":"springboot-blog-2 AOP篇"},{"content":"SpringBootWeb案例 前面我们已经讲解了Web前端开发的基础知识，也讲解了Web后端开发的基础(HTTP协议、请求响应)，并且也讲解了数据库MySQL，以及通过Mybatis框架如何来完成数据库的基本操作。 那接下来，我们就通过一个案例，来将前端开发、后端开发、数据库整合起来。 而这个案例呢，就是我们前面提到的Tlias智能学习辅助系统。\n在这个案例中，前端开发人员已经将前端工程开发完毕了。 我们需要做的，就是参考接口文档完成后端功能的开发，然后结合前端工程进行联调测试即可。\n完成后的成品效果展示：\n今天的主要内容如下：\n准备工作 部门管理 员工管理 下面我们就进入到今天的第1个内容准备工作的学习。\n1. 准备工作 准备工作的学习，我们先从\u0026quot;需求\u0026quot;和\u0026quot;环境搭建\u0026quot;开始入手。\n1.1 需求\u0026amp;环境搭建 1.1.1 需求说明 1、部门管理\n部门管理功能开发包括：\n查询部门列表 删除部门 新增部门 修改部门 2、员工管理\n员工管理功能开发包括：\n查询员工列表(分页、条件) 删除员工 新增员工 修改员工 1.1.2 环境搭建 步骤：\n准备数据库表(dept、emp) 创建springboot工程，引入对应的起步依赖（web、mybatis、mysql驱动、lombok） 配置文件application.properties中引入mybatis的配置信息，准备对应的实体类 准备对应的Mapper、Service(接口、实现类)、Controller基础结构 第1步：准备数据库表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 -- 部门管理 create table dept( id int unsigned primary key auto_increment comment \u0026#39;主键ID\u0026#39;, name varchar(10) not null unique comment \u0026#39;部门名称\u0026#39;, create_time datetime not null comment \u0026#39;创建时间\u0026#39;, update_time datetime not null comment \u0026#39;修改时间\u0026#39; ) comment \u0026#39;部门表\u0026#39;; -- 部门表测试数据 insert into dept (id, name, create_time, update_time) values(1,\u0026#39;学工部\u0026#39;,now(),now()),(2,\u0026#39;教研部\u0026#39;,now(),now()),(3,\u0026#39;咨询部\u0026#39;,now(),now()), (4,\u0026#39;就业部\u0026#39;,now(),now()),(5,\u0026#39;人事部\u0026#39;,now(),now()); -- 员工管理(带约束) create table emp ( id int unsigned primary key auto_increment comment \u0026#39;ID\u0026#39;, username varchar(20) not null unique comment \u0026#39;用户名\u0026#39;, password varchar(32) default \u0026#39;123456\u0026#39; comment \u0026#39;密码\u0026#39;, name varchar(10) not null comment \u0026#39;姓名\u0026#39;, gender tinyint unsigned not null comment \u0026#39;性别, 说明: 1 男, 2 女\u0026#39;, image varchar(300) comment \u0026#39;图像\u0026#39;, job tinyint unsigned comment \u0026#39;职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管, 5 咨询师\u0026#39;, entrydate date comment \u0026#39;入职时间\u0026#39;, dept_id int unsigned comment \u0026#39;部门ID\u0026#39;, create_time datetime not null comment \u0026#39;创建时间\u0026#39;, update_time datetime not null comment \u0026#39;修改时间\u0026#39; ) comment \u0026#39;员工表\u0026#39;; -- 员工表测试数据 INSERT INTO emp (id, username, password, name, gender, image, job, entrydate,dept_id, create_time, update_time) VALUES (1,\u0026#39;jinyong\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;金庸\u0026#39;,1,\u0026#39;1.jpg\u0026#39;,4,\u0026#39;2000-01-01\u0026#39;,2,now(),now()), (2,\u0026#39;zhangwuji\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;张无忌\u0026#39;,1,\u0026#39;2.jpg\u0026#39;,2,\u0026#39;2015-01-01\u0026#39;,2,now(),now()), (3,\u0026#39;yangxiao\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;杨逍\u0026#39;,1,\u0026#39;3.jpg\u0026#39;,2,\u0026#39;2008-05-01\u0026#39;,2,now(),now()), (4,\u0026#39;weiyixiao\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;韦一笑\u0026#39;,1,\u0026#39;4.jpg\u0026#39;,2,\u0026#39;2007-01-01\u0026#39;,2,now(),now()), (5,\u0026#39;changyuchun\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;常遇春\u0026#39;,1,\u0026#39;5.jpg\u0026#39;,2,\u0026#39;2012-12-05\u0026#39;,2,now(),now()), (6,\u0026#39;xiaozhao\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;小昭\u0026#39;,2,\u0026#39;6.jpg\u0026#39;,3,\u0026#39;2013-09-05\u0026#39;,1,now(),now()), (7,\u0026#39;jixiaofu\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;纪晓芙\u0026#39;,2,\u0026#39;7.jpg\u0026#39;,1,\u0026#39;2005-08-01\u0026#39;,1,now(),now()), (8,\u0026#39;zhouzhiruo\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;周芷若\u0026#39;,2,\u0026#39;8.jpg\u0026#39;,1,\u0026#39;2014-11-09\u0026#39;,1,now(),now()), (9,\u0026#39;dingminjun\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;丁敏君\u0026#39;,2,\u0026#39;9.jpg\u0026#39;,1,\u0026#39;2011-03-11\u0026#39;,1,now(),now()), (10,\u0026#39;zhaomin\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;赵敏\u0026#39;,2,\u0026#39;10.jpg\u0026#39;,1,\u0026#39;2013-09-05\u0026#39;,1,now(),now()), (11,\u0026#39;luzhangke\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;鹿杖客\u0026#39;,1,\u0026#39;11.jpg\u0026#39;,5,\u0026#39;2007-02-01\u0026#39;,3,now(),now()), (12,\u0026#39;hebiweng\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;鹤笔翁\u0026#39;,1,\u0026#39;12.jpg\u0026#39;,5,\u0026#39;2008-08-18\u0026#39;,3,now(),now()), (13,\u0026#39;fangdongbai\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;方东白\u0026#39;,1,\u0026#39;13.jpg\u0026#39;,5,\u0026#39;2012-11-01\u0026#39;,3,now(),now()), (14,\u0026#39;zhangsanfeng\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;张三丰\u0026#39;,1,\u0026#39;14.jpg\u0026#39;,2,\u0026#39;2002-08-01\u0026#39;,2,now(),now()), (15,\u0026#39;yulianzhou\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;俞莲舟\u0026#39;,1,\u0026#39;15.jpg\u0026#39;,2,\u0026#39;2011-05-01\u0026#39;,2,now(),now()), (16,\u0026#39;songyuanqiao\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;宋远桥\u0026#39;,1,\u0026#39;16.jpg\u0026#39;,2,\u0026#39;2007-01-01\u0026#39;,2,now(),now()), (17,\u0026#39;chenyouliang\u0026#39;,\u0026#39;123456\u0026#39;,\u0026#39;陈友谅\u0026#39;,1,\u0026#39;17.jpg\u0026#39;,NULL,\u0026#39;2015-03-21\u0026#39;,NULL,now(),now()); 第2步：创建一个SpringBoot工程，选择引入对应的起步依赖（web、mybatis、mysql驱动、lombok） (版本选择2.7.5版本，可以创建完毕之后，在pom.xml文件中更改版本号)\n生成的pom.xml文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.itheima\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-web-management\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;tlias-web-management\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;11\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-j\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;excludes\u0026gt; \u0026lt;exclude\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/exclude\u0026gt; \u0026lt;/excludes\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 创建项目工程目录结构：\n第3步：配置文件application.properties中引入mybatis的配置信息，准备对应的实体类\napplication.properties （直接把之前项目中的复制过来） 1 2 3 4 5 6 7 8 9 10 11 #数据库连接 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/tlias spring.datasource.username=root spring.datasource.password=1234 #开启mybatis的日志输出 mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl #开启数据库表字段 到 实体类属性的驼峰映射 mybatis.configuration.map-underscore-to-camel-case=true 实体类 1 2 3 4 5 6 7 8 9 10 /*部门类*/ @Data @NoArgsConstructor @AllArgsConstructor public class Dept { private Integer id; private String name; private LocalDateTime createTime; private LocalDateTime updateTime; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /*员工类*/ @Data @NoArgsConstructor @AllArgsConstructor public class Emp { private Integer id; private String username; private String password; private String name; private Short gender; private String image; private Short job; private LocalDate entrydate; private Integer deptId; private LocalDateTime createTime; private LocalDateTime updateTime; } 第4步：准备对应的Mapper、Service(接口、实现类)、Controller基础结构\n数据访问层：\nDeptMapper 1 2 3 4 5 6 package com.itheima.mapper; import org.apache.ibatis.annotations.Mapper; @Mapper public interface DeptMapper { } EmpMapper 1 2 3 4 5 6 package com.itheima.mapper; import org.apache.ibatis.annotations.Mapper; @Mapper public interface EmpMapper { } 业务层：\nDeptService 1 2 3 4 5 package com.itheima.service; //部门业务规则 public interface DeptService { } DeptServiceImpl 1 2 3 4 5 6 7 8 9 package com.itheima.service.impl; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Service; //部门业务实现类 @Slf4j @Service public class DeptServiceImpl implements DeptService { } EmpService 1 2 3 4 5 package com.itheima.service; //员工业务规则 public interface EmpService { } EmpServiceImpl 1 2 3 4 5 6 7 8 9 10 11 package com.itheima.service.impl; import com.itheima.service.EmpService; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Service; //员工业务实现类 @Slf4j @Service public class EmpServiceImpl implements EmpService { } 控制层：\nDeptController 1 2 3 4 5 6 7 package com.itheima.controller; import org.springframework.web.bind.annotation.RestController; //部门管理控制器 @RestController public class DeptController { } EmpController 1 2 3 4 5 6 7 package com.itheima.controller; import org.springframework.web.bind.annotation.RestController; //员工管理控制器 @RestController public class EmpController { } 项目工程结构：\n1.2 开发规范 了解完需求也完成了环境搭建了，我们下面开始学习开发的一些规范。\n开发规范我们主要从以下几方面介绍：\n1、开发规范-REST\n我们的案例是基于当前最为主流的前后端分离模式进行开发。\n在前后端分离的开发模式中，前后端开发人员都需要根据提前定义好的接口文档，来进行前后端功能的开发。\n后端开发人员：必须严格遵守提供的接口文档进行后端功能开发（保障开发的功能可以和前端对接）\n而在前后端进行交互的时候，我们需要基于当前主流的REST风格的API接口进行交互。\n什么是REST风格呢?\nREST（Representational State Transfer），表述性状态转换，它是一种软件架构风格。 传统URL风格如下：\n1 2 3 4 http://localhost:8080/user/getById?id=1 GET：查询id为1的用户 http://localhost:8080/user/saveUser POST：新增用户 http://localhost:8080/user/updateUser POST：修改用户 http://localhost:8080/user/deleteUser?id=1 GET：删除id为1的用户 我们看到，原始的传统URL呢，定义比较复杂，而且将资源的访问行为对外暴露出来了。\n基于REST风格URL如下：\n1 2 3 4 http://localhost:8080/users/1 GET：查询id为1的用户 http://localhost:8080/users POST：新增用户 http://localhost:8080/users PUT：修改用户 http://localhost:8080/users/1 DELETE：删除id为1的用户 其中总结起来，就一句话：通过URL定位要操作的资源，通过HTTP动词(请求方式)来描述具体的操作。\n在REST风格的URL中，通过四种请求方式，来操作数据的增删改查。\nGET ： 查询 POST ：新增 PUT ：修改 DELETE ：删除 我们看到如果是基于REST风格，定义URL，URL将会更加简洁、更加规范、更加优雅。\n注意事项：\nREST是风格，是约定方式，约定不是规定，可以打破 描述模块的功能通常使用复数，也就是加s的格式来描述，表示此类资源，而非单个资源。如：users、emps、books… 2、开发规范-统一响应结果\n前后端工程在进行交互时，使用统一响应结果 Result。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package com.itheima.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @NoArgsConstructor @AllArgsConstructor public class Result { private Integer code;//响应码，1 代表成功; 0 代表失败 private String msg; //响应信息 描述字符串 private Object data; //返回的数据 //增删改 成功响应 public static Result success(){ return new Result(1,\u0026#34;success\u0026#34;,null); } //查询 成功响应 public static Result success(Object data){ return new Result(1,\u0026#34;success\u0026#34;,data); } //失败响应 public static Result error(String msg){ return new Result(0,msg,null); } } 3、开发流程\n我们在进行功能开发时，都是根据如下流程进行：\n查看页面原型明确需求\n根据页面原型和需求，进行表结构设计、编写接口文档(已提供) 阅读接口文档\n思路分析\n功能接口开发\n就是开发后台的业务功能，一个业务功能，我们称为一个接口 功能接口测试\n功能开发完毕后，先通过Postman进行功能接口测试，测试通过后，再和前端进行联调测试 前后端联调测试\n和前端开发人员开发好的前端工程一起测试 2. 部门管理 我们按照前面学习的开发流程，开始完成功能开发。首先按照之前分析的需求，完成部门管理的功能开发。\n开发的部门管理功能包含：\n查询部门 删除部门 新增部门 更新部门（不讲解，自己独立完成） 2.1 查询部门 2.1.1 原型和需求 查询的部门的信息：部门ID、部门名称、修改时间\n通过页面原型以及需求描述，我们可以看到，部门查询，是不需要考虑分页操作的。\n2.1.2 接口文档 部门列表查询\n基本信息\n1 2 3 4 5 请求路径：/depts 请求方式：GET 接口描述：该接口用于部门列表数据查询 请求参数\n无\n响应数据\n参数格式：application/json\n参数说明：\n参数名 类型 是否必须 备注 code number 必须 响应码，1 代表成功，0 代表失败 msg string 非必须 提示信息 data object[ ] 非必须 返回的数据 |- id number 非必须 id |- name string 非必须 部门名称 |- createTime string 非必须 创建时间 |- updateTime string 非必须 修改时间 响应数据样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { \u0026#34;code\u0026#34;: 1, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;学工部\u0026#34;, \u0026#34;createTime\u0026#34;: \u0026#34;2022-09-01T23:06:29\u0026#34;, \u0026#34;updateTime\u0026#34;: \u0026#34;2022-09-01T23:06:29\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;教研部\u0026#34;, \u0026#34;createTime\u0026#34;: \u0026#34;2022-09-01T23:06:29\u0026#34;, \u0026#34;updateTime\u0026#34;: \u0026#34;2022-09-01T23:06:29\u0026#34; } ] } 2.1.3 思路分析 2.1.4 功能开发 通过查看接口文档：部门列表查询\n请求路径：/depts\n请求方式：GET\n请求参数：无\n响应数据：json格式\nDeptController\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Slf4j @RestController public class DeptController { @Autowired private DeptService deptService; //@RequestMapping(value = \u0026#34;/depts\u0026#34; , method = RequestMethod.GET) @GetMapping(\u0026#34;/depts\u0026#34;) public Result list(){ log.info(\u0026#34;查询所有部门数据\u0026#34;); List\u0026lt;Dept\u0026gt; deptList = deptService.list(); return Result.success(deptList); } } @Slf4j注解源码：\nDeptService（业务接口）\n1 2 3 4 5 6 7 public interface DeptService { /** * 查询所有的部门数据 * @return 存储Dept对象的集合 */ List\u0026lt;Dept\u0026gt; list(); } DeptServiceImpl（业务实现类）\n1 2 3 4 5 6 7 8 9 10 11 12 @Slf4j @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Override public List\u0026lt;Dept\u0026gt; list() { List\u0026lt;Dept\u0026gt; deptList = deptMapper.list(); return deptList; } } DeptMapper\n1 2 3 4 5 6 @Mapper public interface DeptMapper { //查询所有部门数据 @Select(\u0026#34;select id, name, create_time, update_time from dept\u0026#34;) List\u0026lt;Dept\u0026gt; list(); } 2.1.5 功能测试 功能开发完成后，我们就可以启动项目，然后打开postman，发起GET请求，访问 ：http://localhost:8080/depts\n2.2 前后端联调 完成了查询部门的功能，我们也通过postman工具测试通过了，下面我们再基于前后端分离的方式进行接口联调。具体操作如下：\n1、将资料中提供的\u0026quot;前端环境\u0026quot;文件夹中的压缩包，拷贝到一个没有中文不带空格的目录下\n2、拷贝到一个没有中文不带空格的目录后，进行解压（解压到当前目录）\n3、启动nginx\n4、打开浏览器，访问：http://localhost:90\n5、测试：部门管理 - 查询部门列表\n说明：只要按照接口文档开发功能接口，就能保证前后端程序交互\n后端：严格遵守接口文档进行功能接口开发 前端：严格遵守接口文档访问功能接口 2.3 删除部门 查询部门的功能我们搞定了，下面我们开始完成删除部门的功能开发。\n2.3.1 需求 点击部门列表后面操作栏的 \u0026ldquo;删除\u0026rdquo; 按钮，就可以删除该部门信息。 此时，前端只需要给服务端传递一个ID参数就可以了。 我们从接口文档中也可以看得出来。\n2.3.2 接口文档 删除部门\n基本信息\n1 2 3 4 5 请求路径：/depts/{id} 请求方式：DELETE 接口描述：该接口用于根据ID删除部门数据 请求参数 参数格式：路径参数\n参数说明：\n参数名 类型 是否必须 备注 id number 必须 部门ID 请求参数样例：\n1 /depts/1 响应数据 参数格式：application/json\n参数说明：\n参数名 类型 是否必须 备注 code number 必须 响应码，1 代表成功，0 代表失败 msg string 非必须 提示信息 data object 非必须 返回的数据 响应数据样例：\n1 2 3 4 5 { \u0026#34;code\u0026#34;:1, \u0026#34;msg\u0026#34;:\u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;:null } 2.3.3 思路分析 接口文档规定：\n前端请求路径：/depts/{id} 前端请求方式：DELETE 问题1：怎么在controller中接收请求路径中的路径参数？\n1 @PathVariable 问题2：如何限定请求方式是delete？\n1 @DeleteMapping 2.3.4 功能开发 通过查看接口文档：删除部门\n请求路径：/depts/{id}\n请求方式：DELETE\n请求参数：路径参数 {id}\n响应数据：json格式\nDeptController\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Slf4j @RestController public class DeptController { @Autowired private DeptService deptService; @DeleteMapping(\u0026#34;/depts/{id}\u0026#34;) public Result delete(@PathVariable Integer id) { //日志记录 log.info(\u0026#34;根据id删除部门\u0026#34;); //调用service层功能 deptService.delete(id); //响应 return Result.success(); } //省略... } DeptService\n1 2 3 4 5 6 7 8 9 10 public interface DeptService { /** * 根据id删除部门 * @param id 部门id */ void delete(Integer id); //省略... } DeptServiceImpl\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Slf4j @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Override public void delete(Integer id) { //调用持久层删除功能 deptMapper.deleteById(id); } //省略... } DeptMapper\n1 2 3 4 5 6 7 8 9 10 11 @Mapper public interface DeptMapper { /** * 根据id删除部门信息 * @param id 部门id */ @Delete(\u0026#34;delete from dept where id = #{id}\u0026#34;) void deleteById(Integer id); //省略... } 2.3.5 功能测试 删除功能开发完成后，重新启动项目，使用postman，发起DELETE请求：\n2.3.6 前后端联调 打开浏览器，测试后端功能接口：\n2.4 新增部门 我们前面已完成了查询部门、删除部门两个功能，也熟悉了开发的流程。下面我们继续完成新增部门功能。\n2.4.1 需求 点击 \u0026ldquo;新增部门\u0026rdquo; 按钮，弹出新增部门对话框，输入部门名称，点击 \u0026ldquo;保存\u0026rdquo; ，将部门信息保存到数据库。\n2.4.2 接口文档 添加部门\n基本信息\n1 2 3 4 5 请求路径：/depts 请求方式：POST 接口描述：该接口用于添加部门数据 请求参数\n格式：application/json\n参数说明：\n参数名 类型 是否必须 备注 name string 必须 部门名称 请求参数样例：\n1 2 3 { \u0026#34;name\u0026#34;: \u0026#34;教研部\u0026#34; } 响应数据\n参数格式：application/json\n参数说明：\n参数名 类型 是否必须 备注 code number 必须 响应码，1 代表成功，0 代表失败 msg string 非必须 提示信息 data object 非必须 返回的数据 响应数据样例：\n1 2 3 4 5 { \u0026#34;code\u0026#34;:1, \u0026#34;msg\u0026#34;:\u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;:null } 2.4.3 思路分析 接口文档规定：\n前端请求路径：/depts 前端请求方式：POST 前端请求参数 (Json格式)：{ \u0026ldquo;name\u0026rdquo;: \u0026ldquo;教研部\u0026rdquo; } 问题1：如何限定请求方式是POST？\n1 @PostMapping 问题2：怎么在controller中接收json格式的请求参数？\n1 @RequestBody //把前端传递的json数据填充到实体类中 2.4.4 功能开发 通过查看接口文档：新增部门\n请求路径：/depts\n请求方式：POST\n请求参数：json格式\n响应数据：json格式\nDeptController\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Slf4j @RestController public class DeptController { @Autowired private DeptService deptService; @PostMapping(\u0026#34;/depts\u0026#34;) public Result add(@RequestBody Dept dept){ //记录日志 log.info(\u0026#34;新增部门：{}\u0026#34;,dept); //调用service层添加功能 deptService.add(dept); //响应 return Result.success(); } //省略... } DeptService\n1 2 3 4 5 6 7 8 9 10 public interface DeptService { /** * 新增部门 * @param dept 部门对象 */ void add(Dept dept); //省略... } DeptServiceImpl\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Slf4j @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Override public void add(Dept dept) { //补全部门数据 dept.setCreateTime(LocalDateTime.now()); dept.setUpdateTime(LocalDateTime.now()); //调用持久层增加功能 deptMapper.inser(dept); } //省略... } DeptMapper\n1 2 3 4 5 6 7 8 @Mapper public interface DeptMapper { @Insert(\u0026#34;insert into dept (name, create_time, update_time) values (#{name},#{createTime},#{updateTime})\u0026#34;) void inser(Dept dept); //省略... } 2.4.5 功能测试 新增功能开发完成后，重新启动项目，使用postman，发起POST请求：\n2.4.6 前后端联调 打开浏览器，测试后端功能接口：\n2.4.7 请求路径 我们部门管理的查询、删除、新增功能全部完成了，接下来我们要对controller层的代码进行优化。\n首先我们先来看下目前controller层代码：\n以上三个方法上的请求路径，存在一个共同点：都是以/depts作为开头。（重复了）\n在Spring当中为了简化请求路径的定义，可以把公共的请求路径，直接抽取到类上，在类上加一个注解@RequestMapping，并指定请求路径\u0026quot;/depts\u0026quot;。代码参照如下：\n优化前后的对比：\n注意事项：一个完整的请求路径，应该是类上@RequestMapping的value属性 + 方法上的 @RequestMapping的value属性\n3. 员工管理 完成了部门管理的功能开发之后，我们进入到下一环节员工管理功能的开发。\n基于以上原型，我们可以把员工管理功能分为：\n分页查询（今天完成） 带条件的分页查询（今天完成） 删除员工（今天完成） 新增员工（后续完成） 修改员工（后续完成） 那下面我们就先从分页查询功能开始学习。\n3.1 分页查询 3.1.1 基础分页 3.1.1.1 需求分析 我们之前做的查询功能，是将数据库中所有的数据查询出来并展示到页面上，试想如果数据库中的数据有很多(假设有十几万条)的时候，将数据全部展示出来肯定不现实，那如何解决这个问题呢？\n使用分页解决这个问题。每次只展示一页的数据，比如：一页展示10条数据，如果还想看其他的数据，可以通过点击页码进行查询。\n要想从数据库中进行分页查询，我们要使用LIMIT关键字，格式为：limit 开始索引 每页显示的条数\n查询第1页数据的SQL语句是：\n1 select * from emp limit 0,10; 查询第2页数据的SQL语句是：\n1 select * from emp limit 10,10; 查询第3页的数据的SQL语句是：\n1 select * from emp limit 20,10; 观察以上SQL语句，发现： 开始索引一直在改变 ， 每页显示条数是固定的\n开始索引的计算公式： 开始索引 = (当前页码 - 1) * 每页显示条数\n我们继续基于页面原型，继续分析，得出以下结论：\n前端在请求服务端时，传递的参数 当前页码 page 每页显示条数 pageSize 后端需要响应什么数据给前端 所查询到的数据列表（存储到List 集合中） 总记录数 后台给前端返回的数据包含：List集合(数据列表)、total(总记录数)\n而这两部分我们通常封装到PageBean对象中，并将该对象转换为json格式的数据响应回给浏览器。\n1 2 3 4 5 6 7 @Data @NoArgsConstructor @AllArgsConstructor public class PageBean { private Long total; //总记录数 private List rows; //当前页数据列表 } 3.1.1.2 接口文档 员工列表查询\n基本信息\n1 2 3 4 5 请求路径：/emps 请求方式：GET 接口描述：该接口用于员工列表数据的条件分页查询 请求参数\n参数格式：queryString\n参数说明：\n参数名称 是否必须 示例 备注 name 否 张 姓名 gender 否 1 性别 , 1 男 , 2 女 begin 否 2010-01-01 范围匹配的开始时间(入职日期) end 否 2020-01-01 范围匹配的结束时间(入职日期) page 是 1 分页查询的页码，如果未指定，默认为1 pageSize 是 10 分页查询的每页记录数，如果未指定，默认为10 请求数据样例：\n1 /emps?name=张\u0026amp;gender=1\u0026amp;begin=2007-09-01\u0026amp;end=2022-09-01\u0026amp;page=1\u0026amp;pageSize=10 响应数据\n参数格式：application/json\n参数说明：\n名称 类型 是否必须 默认值 备注 其他信息 code number 必须 响应码, 1 成功 , 0 失败 msg string 非必须 提示信息 data object 必须 返回的数据 |- total number 必须 总记录数 |- rows object [] 必须 数据列表 item 类型: object |- id number 非必须 id |- username string 非必须 用户名 |- name string 非必须 姓名 |- password string 非必须 密码 |- entrydate string 非必须 入职日期 |- gender number 非必须 性别 , 1 男 ; 2 女 |- image string 非必须 图像 |- job number 非必须 职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管, 5 咨询师 |- deptId number 非必须 部门id |- createTime string 非必须 创建时间 |- updateTime string 非必须 更新时间 响应数据样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 { \u0026#34;code\u0026#34;: 1, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;total\u0026#34;: 2, \u0026#34;rows\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;username\u0026#34;: \u0026#34;jinyong\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;123456\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;金庸\u0026#34;, \u0026#34;gender\u0026#34;: 1, \u0026#34;image\u0026#34;: \u0026#34;https://web-framework.oss-cn-hangzhou.aliyuncs.com/2022-09-02-00-27-53B.jpg\u0026#34;, \u0026#34;job\u0026#34;: 2, \u0026#34;entrydate\u0026#34;: \u0026#34;2015-01-01\u0026#34;, \u0026#34;deptId\u0026#34;: 2, \u0026#34;createTime\u0026#34;: \u0026#34;2022-09-01T23:06:30\u0026#34;, \u0026#34;updateTime\u0026#34;: \u0026#34;2022-09-02T00:29:04\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;username\u0026#34;: \u0026#34;zhangwuji\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;123456\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;张无忌\u0026#34;, \u0026#34;gender\u0026#34;: 1, \u0026#34;image\u0026#34;: \u0026#34;https://web-framework.oss-cn-hangzhou.aliyuncs.com/2022-09-02-00-27-53B.jpg\u0026#34;, \u0026#34;job\u0026#34;: 2, \u0026#34;entrydate\u0026#34;: \u0026#34;2015-01-01\u0026#34;, \u0026#34;deptId\u0026#34;: 2, \u0026#34;createTime\u0026#34;: \u0026#34;2022-09-01T23:06:30\u0026#34;, \u0026#34;updateTime\u0026#34;: \u0026#34;2022-09-02T00:29:04\u0026#34; } ] } } 3.1.1.3 思路分析 分页查询需要的数据，封装在PageBean对象中：\n3.1.1.4 功能开发 通过查看接口文档：员工列表查询\n请求路径：/emps\n请求方式：GET\n请求参数：跟随在请求路径后的参数字符串。 例：/emps?page=1\u0026amp;pageSize=10\n响应数据：json格式\nEmpController\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import com.itheima.pojo.PageBean; import com.itheima.pojo.Result; import com.itheima.service.EmpService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @Slf4j @RestController @RequestMapping(\u0026#34;/emps\u0026#34;) public class EmpController { @Autowired private EmpService empService; //条件分页查询 @GetMapping public Result page(@RequestParam(defaultValue = \u0026#34;1\u0026#34;) Integer page, @RequestParam(defaultValue = \u0026#34;10\u0026#34;) Integer pageSize) { //记录日志 log.info(\u0026#34;分页查询，参数：{},{}\u0026#34;, page, pageSize); //调用业务层分页查询功能 PageBean pageBean = empService.page(page, pageSize); //响应 return Result.success(pageBean); } } @RequestParam(defaultValue=\u0026ldquo;默认值\u0026rdquo;) //设置请求参数默认值\nEmpService\n1 2 3 4 5 6 7 8 9 public interface EmpService { /** * 条件分页查询 * @param page 页码 * @param pageSize 每页展示记录数 * @return */ PageBean page(Integer page, Integer pageSize); } EmpServiceImpl\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import com.itheima.mapper.EmpMapper; import com.itheima.pojo.Emp; import com.itheima.pojo.PageBean; import com.itheima.service.EmpService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.time.LocalDate; import java.util.List; @Slf4j @Service public class EmpServiceImpl implements EmpService { @Autowired private EmpMapper empMapper; @Override public PageBean page(Integer page, Integer pageSize) { //1、获取总记录数 Long count = empMapper.count(); //2、获取分页查询结果列表 Integer start = (page - 1) * pageSize; //计算起始索引 , 公式: (页码-1)*页大小 List\u0026lt;Emp\u0026gt; empList = empMapper.list(start, pageSize); //3、封装PageBean对象 PageBean pageBean = new PageBean(count , empList); return pageBean; } } EmpMapper\n1 2 3 4 5 6 7 8 9 10 @Mapper public interface EmpMapper { //获取总记录数 @Select(\u0026#34;select count(*) from emp\u0026#34;) public Long count(); //获取当前页的结果列表 @Select(\u0026#34;select * from emp limit #{start}, #{pageSize}\u0026#34;) public List\u0026lt;Emp\u0026gt; list(Integer start, Integer pageSize); } 3.1.1.5 功能测试 功能开发完成后，重新启动项目，使用postman，发起POST请求：\n3.1.1.6 前后端联调 打开浏览器，测试后端功能接口：\n3.1.2 分页插件 3.1.2.1 介绍 前面我们已经完了基础的分页查询，大家会发现：分页查询功能编写起来比较繁琐。\n在Mapper接口中定义两个方法执行两条不同的SQL语句：\n查询总记录数 指定页码的数据列表 在Service当中，调用Mapper接口的两个方法，分别获取：总记录数、查询结果列表，然后在将获取的数据结果封装到PageBean对象中。\n大家思考下：在未来开发其他项目，只要涉及到分页查询功能(例：订单、用户、支付、商品)，都必须按照以上操作完成功能开发\n结论：原始方式的分页查询，存在着\u0026quot;步骤固定\u0026quot;、\u0026ldquo;代码频繁\u0026quot;的问题\n解决方案：可以使用一些现成的分页插件完成。对于Mybatis来讲现在最主流的就是PageHelper。\nPageHelper是Mybatis的一款功能强大、方便易用的分页插件，支持任何形式的单标、多表的分页查询。\n官网：https://pagehelper.github.io/\n在执行empMapper.list()方法时，就是执行：select * from emp 语句，怎么能够实现分页操作呢？\n分页插件帮我们完成了以下操作：\n先获取到要执行的SQL语句：select * from emp 把SQL语句中的字段列表，变为：count(*) 执行SQL语句：select count(*) from emp //获取到总记录数 再对要执行的SQL语句：select * from emp 进行改造，在末尾添加 limit ? , ? 执行改造后的SQL语句：select * from emp limit ? , ? 3.1.2.2 代码实现 当使用了PageHelper分页插件进行分页，就无需再Mapper中进行手动分页了。 在Mapper中我们只需要进行正常的列表查询即可。在Service层中，调用Mapper的方法之前设置分页参数，在调用Mapper方法执行查询之后，解析分页结果，并将结果封装到PageBean对象中返回。\n1、在pom.xml引入依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.pagehelper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pagehelper-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2、EmpMapper\n1 2 3 4 5 6 @Mapper public interface EmpMapper { //获取当前页的结果列表 @Select(\u0026#34;select * from emp\u0026#34;) public List\u0026lt;Emp\u0026gt; page(Integer start, Integer pageSize); } 3、EmpServiceImpl\n1 2 3 4 5 6 7 8 9 10 11 12 @Override public PageBean page(Integer page, Integer pageSize) { // 设置分页参数 PageHelper.startPage(page, pageSize); // 执行分页查询 List\u0026lt;Emp\u0026gt; empList = empMapper.list(name,gender,begin,end); // 获取分页结果 Page\u0026lt;Emp\u0026gt; p = (Page\u0026lt;Emp\u0026gt;) empList; //封装PageBean PageBean pageBean = new PageBean(p.getTotal(), p.getResult()); return pageBean; } 3.1.2.3 测试 功能开发完成后，我们重启项目工程，打开postman，发起GET请求，访问 ：http://localhost:8080/emps?page=1\u0026amp;pageSize=5\n后端程序SQL输出：\n3.2 分页查询(带条件) 完了分页查询后，下面我们需要在分页查询的基础上，添加条件。\n3.2.1 需求 通过员工管理的页面原型我们可以看到，员工列表页面的查询，不仅仅需要考虑分页，还需要考虑查询条件。 分页查询我们已经实现了，接下来，我们需要考虑在分页查询的基础上，再加上查询条件。\n我们看到页面原型及需求中描述，搜索栏的搜索条件有三个，分别是：\n姓名：模糊匹配 性别：精确匹配 入职日期：范围匹配 1 2 3 4 5 6 7 select * from emp where name like concat(\u0026#39;%\u0026#39;,\u0026#39;张\u0026#39;,\u0026#39;%\u0026#39;) -- 条件1：根据姓名模糊匹配 and gender = 1 -- 条件2：根据性别精确匹配 and entrydate = between \u0026#39;2000-01-01\u0026#39; and \u0026#39;2010-01-01\u0026#39; -- 条件3：根据入职日期范围匹配 order by update_time desc; 而且上述的三个条件，都是可以传递，也可以不传递的，也就是动态的。 我们需要使用前面学习的Mybatis中的动态SQL 。\n3.2.2 思路分析 3.2.3 功能开发 通过查看接口文档：员工列表查询\n请求路径：/emps\n请求方式：GET\n请求参数：\n参数名称 是否必须 示例 备注 name 否 张 姓名 gender 否 1 性别 , 1 男 , 2 女 begin 否 2010-01-01 范围匹配的开始时间(入职日期) end 否 2020-01-01 范围匹配的结束时间(入职日期) page 是 1 分页查询的页码，如果未指定，默认为1 pageSize 是 10 分页查询的每页记录数，如果未指定，默认为10 在原有分页查询的代码基础上进行改造：\nEmpController\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Slf4j @RestController @RequestMapping(\u0026#34;/emps\u0026#34;) public class EmpController { @Autowired private EmpService empService; //条件分页查询 @GetMapping public Result page(@RequestParam(defaultValue = \u0026#34;1\u0026#34;) Integer page, @RequestParam(defaultValue = \u0026#34;10\u0026#34;) Integer pageSize, String name, Short gender, @DateTimeFormat(pattern = \u0026#34;yyyy-MM-dd\u0026#34;) LocalDate begin, @DateTimeFormat(pattern = \u0026#34;yyyy-MM-dd\u0026#34;) LocalDate end) { //记录日志 log.info(\u0026#34;分页查询，参数：{},{},{},{},{},{}\u0026#34;, page, pageSize,name, gender, begin, end); //调用业务层分页查询功能 PageBean pageBean = empService.page(page, pageSize, name, gender, begin, end); //响应 return Result.success(pageBean); } } EmpService\n1 2 3 4 5 6 7 8 9 10 11 12 13 public interface EmpService { /** * 条件分页查询 * @param page 页码 * @param pageSize 每页展示记录数 * @param name 姓名 * @param gender 性别 * @param begin 开始时间 * @param end 结束时间 * @return */ PageBean page(Integer page, Integer pageSize, String name, Short gender, LocalDate begin, LocalDate end); } EmpServiceImpl\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Slf4j @Service public class EmpServiceImpl implements EmpService { @Autowired private EmpMapper empMapper; @Override public PageBean page(Integer page, Integer pageSize, String name, Short gender, LocalDate begin, LocalDate end) { //设置分页参数 PageHelper.startPage(page, pageSize); //执行条件分页查询 List\u0026lt;Emp\u0026gt; empList = empMapper.list(name, gender, begin, end); //获取查询结果 Page\u0026lt;Emp\u0026gt; p = (Page\u0026lt;Emp\u0026gt;) empList; //封装PageBean PageBean pageBean = new PageBean(p.getTotal(), p.getResult()); return pageBean; } } EmpMapper\n1 2 3 4 5 @Mapper public interface EmpMapper { //获取当前页的结果列表 public List\u0026lt;Emp\u0026gt; list(String name, Short gender, LocalDate begin, LocalDate end); } EmpMapper.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.itheima.mapper.EmpMapper\u0026#34;\u0026gt; \u0026lt;!-- 条件分页查询 --\u0026gt; \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.itheima.pojo.Emp\u0026#34;\u0026gt; select * from emp \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name != null and name != \u0026#39;\u0026#39;\u0026#34;\u0026gt; name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt; and gender = #{gender} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;begin != null and end != null\u0026#34;\u0026gt; and entrydate between #{begin} and #{end} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; order by update_time desc \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 3.2.4 功能测试 功能开发完成后，重启项目工程，打开postman，发起GET请求：\n控制台SQL语句：\n3.2.5 前后端联调 打开浏览器，测试后端功能接口：\n3.3 删除员工 查询员完成之后，我们继续开发新的功能：删除员工。\n3.3.1 需求 当我们勾选列表前面的复选框，然后点击 \u0026ldquo;批量删除\u0026rdquo; 按钮，就可以将这一批次的员工信息删除掉了。也可以只勾选一个复选框，仅删除一个员工信息。\n问题：我们需要开发两个功能接口吗？一个删除单个员工，一个删除多个员工\n答案：不需要。 只需要开发一个功能接口即可（删除多个员工包含只删除一个员工）\n3.3.2 接口文档 删除员工\n基本信息\n1 2 3 4 5 请求路径：/emps/{ids} 请求方式：DELETE 接口描述：该接口用于批量删除员工的数据信息 请求参数\n参数格式：路径参数\n参数说明：\n参数名 类型 示例 是否必须 备注 ids 数组 array 1,2,3 必须 员工的id数组 请求参数样例：\n1 /emps/1,2,3 响应数据\n参数格式：application/json\n参数说明：\n参数名 类型 是否必须 备注 code number 必须 响应码，1 代表成功，0 代表失败 msg string 非必须 提示信息 data object 非必须 返回的数据 响应数据样例：\n1 2 3 4 5 { \u0026#34;code\u0026#34;:1, \u0026#34;msg\u0026#34;:\u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;:null } 3.3.3 思路分析 接口文档规定：\n前端请求路径：/emps/{ids} 前端请求方式：DELETE 问题1：怎么在controller中接收请求路径中的路径参数？\n1 @PathVariable 问题2：如何限定请求方式是delete？\n1 @DeleteMapping 问题3：在Mapper接口中，执行delete操作的SQL语句时，条件中的id值是不确定的是动态的，怎么实现呢？\n1 Mybatis中的动态SQL：foreach 3.3.4 功能开发 通过查看接口文档：删除员工\n请求路径：/emps/{ids}\n请求方式：DELETE\n请求参数：路径参数 {ids}\n响应数据：json格式\nEmpController\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Slf4j @RestController @RequestMapping(\u0026#34;/emps\u0026#34;) public class EmpController { @Autowired private EmpService empService; //批量删除 @DeleteMapping(\u0026#34;/{ids}\u0026#34;) public Result delete(@PathVariable List\u0026lt;Integer\u0026gt; ids){ empService.delete(ids); return Result.success(); } //条件分页查询 @GetMapping public Result page(@RequestParam(defaultValue = \u0026#34;1\u0026#34;) Integer page, @RequestParam(defaultValue = \u0026#34;10\u0026#34;) Integer pageSize, String name, Short gender, @DateTimeFormat(pattern = \u0026#34;yyyy-MM-dd\u0026#34;) LocalDate begin, @DateTimeFormat(pattern = \u0026#34;yyyy-MM-dd\u0026#34;) LocalDate end) { //记录日志 log.info(\u0026#34;分页查询，参数：{},{},{},{},{},{}\u0026#34;, page, pageSize,name, gender, begin, end); //调用业务层分页查询功能 PageBean pageBean = empService.page(page, pageSize, name, gender, begin, end); //响应 return Result.success(pageBean); } } EmpService\n1 2 3 4 5 6 7 8 9 10 public interface EmpService { /** * 批量删除操作 * @param ids id集合 */ void delete(List\u0026lt;Integer\u0026gt; ids); //省略... } EmpServiceImpl\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Slf4j @Service public class EmpServiceImpl implements EmpService { @Autowired private EmpMapper empMapper; @Override public void delete(List\u0026lt;Integer\u0026gt; ids) { empMapper.delete(ids); } //省略... } EmpMapper\n1 2 3 4 5 6 7 @Mapper public interface EmpMapper { //批量删除 void delete(List\u0026lt;Integer\u0026gt; ids); //省略... } EmpMapper.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.itheima.mapper.EmpMapper\u0026#34;\u0026gt; \u0026lt;!--批量删除员工--\u0026gt; \u0026lt;select id=\u0026#34;delete\u0026#34;\u0026gt; delete from emp where id in \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34; separator=\u0026#34;,\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;!-- 省略... --\u0026gt; \u0026lt;/mapper\u0026gt; 3.3.5 功能测试 功能开发完成后，重启项目工程，打开postman，发起DELETE请求：\n控制台SQL语句：\n3.3.6 前后端联调 打开浏览器，测试后端功能接口：\n","date":"2024-07-05T22:27:20+08:00","image":"https://picsum.photos/800/600 ","permalink":"https://4evergreat.github.io/2024/springboot-blog-3/","title":"springboot-blog-3 案例篇1"},{"content":"SpringBootWeb案例 前面我们已经实现了员工信息的条件分页查询以及删除操作。 关于员工管理的功能，还有两个需要实现：\n新增员工 修改员工 首先我们先完成\u0026quot;新增员工\u0026quot;的功能开发，再完成\u0026quot;修改员工\u0026quot;的功能开发。而在\u0026quot;新增员工\u0026quot;中，需要添加头像，而头像需要用到\u0026quot;文件上传\u0026quot;技术。 当整个员工管理功能全部开发完成之后，我们再通过配置文件来优化一些内容。\n综上所述，我们今天的课程内容包含以下四个部分：\n新增员工 文件上传 修改员工 配置文件 1. 新增员工 1.1 需求 在新增用户时，我们需要保存用户的基本信息，并且还需要上传的员工的图片，目前我们先完成第一步操作，保存用户的基本信息。\n1.2 接口文档 我们参照接口文档来开发新增员工功能\n基本信息\n1 2 3 4 5 请求路径：/emps 请求方式：POST 接口描述：该接口用于添加员工的信息 请求参数\n参数格式：application/json\n参数说明：\n名称 类型 是否必须 备注 username string 必须 用户名 name string 必须 姓名 gender number 必须 性别, 说明: 1 男, 2 女 image string 非必须 图像 deptId number 非必须 部门id entrydate string 非必须 入职日期 job number 非必须 职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管, 5 咨询师 请求数据样例：\n1 2 3 4 5 6 7 8 9 { \u0026#34;image\u0026#34;: \u0026#34;https://web-framework.oss-cn-hangzhou.aliyuncs.com/2022-09-03-07-37-38222.jpg\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;linpingzhi\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;林平之\u0026#34;, \u0026#34;gender\u0026#34;: 1, \u0026#34;job\u0026#34;: 1, \u0026#34;entrydate\u0026#34;: \u0026#34;2022-09-18\u0026#34;, \u0026#34;deptId\u0026#34;: 1 } 响应数据\n参数格式：application/json\n参数说明：\n参数名 类型 是否必须 备注 code number 必须 响应码，1 代表成功，0 代表失败 msg string 非必须 提示信息 data object 非必须 返回的数据 响应数据样例：\n1 2 3 4 5 { \u0026#34;code\u0026#34;:1, \u0026#34;msg\u0026#34;:\u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;:null } 1.3 思路分析 新增员工的具体的流程：\n接口文档规定：\n请求路径：/emps 请求方式：POST 请求参数：Json格式数据 响应数据：Json格式数据 问题1：如何限定请求方式是POST？\n1 @PostMapping 问题2：怎么在controller中接收json格式的请求参数？\n1 @RequestBody //把前端传递的json数据填充到实体类中 1.4 功能开发 EmpController\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Slf4j @RestController @RequestMapping(\u0026#34;/emps\u0026#34;) public class EmpController { @Autowired private EmpService empService; //新增 @PostMapping public Result save(@RequestBody Emp emp){ //记录日志 log.info(\u0026#34;新增员工, emp:{}\u0026#34;,emp); //调用业务层新增功能 empService.save(emp); //响应 return Result.success(); } //省略... } EmpService\n1 2 3 4 5 6 7 8 9 10 public interface EmpService { /** * 保存员工信息 * @param emp */ void save(Emp emp); //省略... } EmpServiceImpl\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Slf4j @Service public class EmpServiceImpl implements EmpService { @Autowired private EmpMapper empMapper; @Override public void save(Emp emp) { //补全数据 emp.setCreateTime(LocalDateTime.now()); emp.setUpdateTime(LocalDateTime.now()); //调用添加方法 empMapper.insert(emp); } //省略... } EmpMapper\n1 2 3 4 5 6 7 8 9 @Mapper public interface EmpMapper { //新增员工 @Insert(\u0026#34;insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time) \u0026#34; + \u0026#34;values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime});\u0026#34;) void insert(Emp emp); //省略... } 1.5 功能测试 代码开发完成后，重启服务器，打开Postman发送 POST 请求，请求路径：http://localhost:8080/emps\n1.6 前后端联调 功能测试通过后，我们再进行通过打开浏览器，测试后端功能接口：\n2. 文件上传 在我们完成的新增员工功能中，还存在一个问题：没有头像(图片缺失)\n上述问题，需要我们通过文件上传技术来解决。下面我们就进入到文件上传技术的学习。\n文件上传技术这块我们主要讲解三个方面：首先我们先对文件上传做一个整体的介绍，接着再学习文件上传的本地存储方式，最后学习云存储方式。\n接下来我们就先来学习下什么是文件上传。\n2.1 简介 文件上传，是指将本地图片、视频、音频等文件上传到服务器，供其他用户浏览或下载的过程。\n文件上传在项目中应用非常广泛，我们经常发微博、发微信朋友圈都用到了文件上传功能。\n在我们的案例中，在新增员工的时候，要上传员工的头像，此时就会涉及到文件上传的功能。在进行文件上传时，我们点击加号或者是点击图片，就可以选择手机或者是电脑本地的图片文件了。当我们选择了某一个图片文件之后，这个文件就会上传到服务器，从而完成文件上传的操作。\n想要完成文件上传这个功能需要涉及到两个部分：\n前端程序 服务端程序 我们先来看看在前端程序中要完成哪些代码：\n1 2 3 4 5 6 \u0026lt;form action=\u0026#34;/upload\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; 姓名: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;br\u0026gt; 年龄: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;br\u0026gt; 头像: \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;image\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 上传文件的原始form表单，要求表单必须具备以下三点（上传文件页面三要素）：\n表单必须有file域，用于选择要上传的文件\n1 \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;image\u0026#34;/\u0026gt; 表单提交方式必须为POST\n通常上传的文件会比较大，所以需要使用 POST 提交方式\n表单的编码类型enctype必须要设置为：multipart/form-data\n普通默认的编码格式是不适合传输大型的二进制数据的，所以在文件上传时，表单的编码格式必须设置为multipart/form-data\n前端页面的3要素我们了解后，接下来我们就来验证下所讲解的文件上传3要素。\n在提供的\u0026quot;课程资料\u0026quot;中有一个名叫\u0026quot;文件上传\u0026quot;的文件夹，直接将里的\u0026quot;upload.html\u0026quot;文件，复制到springboot项目工程下的static目录里面。\n下面我们来验证：删除form表单中enctype属性值，会是什么情况？\n在IDEA中直接使用浏览器打开upload.html页面 选择要上传的本地文件 点击\u0026quot;提交\u0026quot;按钮，进入到开发者模式观察 我们再来验证：设置form表单中enctype属性值为multipart/form-data，会是什么情况？\n1 2 3 4 5 6 \u0026lt;form action=\u0026#34;/upload\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; 姓名: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;br\u0026gt; 年龄: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;br\u0026gt; 头像: \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;image\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 知道了前端程序中需要设置上传文件页面三要素，那我们的后端程序又是如何实现的呢？\n首先在服务端定义这么一个controller，用来进行文件上传，然后在controller当中定义一个方法来处理/upload 请求\n在定义的方法中接收提交过来的数据 （方法中的形参名和请求参数的名字保持一致）\n用户名：String name 年龄： Integer age 文件： MultipartFile image Spring中提供了一个API：MultipartFile，使用这个API就可以来接收到上传的文件\n问题：如果表单项的名字和方法中形参名不一致，该怎么办？\n1 2 3 public Result upload(String username, Integer age, MultipartFile file) //file形参名和请求参数名image不一致 解决：使用@RequestParam注解进行参数绑定\n1 2 3 public Result upload(String username, Integer age, @RequestParam(\u0026#34;image\u0026#34;) MultipartFile file) UploadController代码：\n1 2 3 4 5 6 7 8 9 10 11 @Slf4j @RestController public class UploadController { @PostMapping(\u0026#34;/upload\u0026#34;) public Result upload(String username, Integer age, MultipartFile image) { log.info(\u0026#34;文件上传：{},{},{}\u0026#34;,username,age,image); return Result.success(); } } 后端程序编写完成之后，打个断点，以debug方式启动SpringBoot项目\n打开浏览器输入：http://localhost:8080/upload.html ， 录入数据并提交\n通过后端程序控制台可以看到，上传的文件是存放在一个临时目录\n打开临时目录可以看到以下内容：\n表单提交的三项数据(姓名、年龄、文件)，分别存储在不同的临时文件中：\n当我们程序运行完毕之后，这个临时文件会自动删除。\n所以，我们如果想要实现文件上传，需要将这个临时文件，要转存到我们的磁盘目录中。\n2.2 本地存储 前面我们已分析了文件上传功能前端和后端的基础代码实现，文件上传时在服务端会产生一个临时文件，请求响应完成之后，这个临时文件被自动删除，并没有进行保存。下面呢，我们就需要完成将上传的文件保存在服务器的本地磁盘上。\n代码实现：\n在服务器本地磁盘上创建images目录，用来存储上传的文件（例：E盘创建images目录） 使用MultipartFile类提供的API方法，把临时文件转存到本地磁盘目录下 MultipartFile 常见方法：\nString getOriginalFilename(); //获取原始文件名 void transferTo(File dest); //将接收的文件转存到磁盘文件中 long getSize(); //获取文件的大小，单位：字节 byte[] getBytes(); //获取文件内容的字节数组 InputStream getInputStream(); //获取接收到的文件内容的输入流 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Slf4j @RestController public class UploadController { @PostMapping(\u0026#34;/upload\u0026#34;) public Result upload(String username, Integer age, MultipartFile image) throws IOException { log.info(\u0026#34;文件上传：{},{},{}\u0026#34;,username,age,image); //获取原始文件名 String originalFilename = image.getOriginalFilename(); //将文件存储在服务器的磁盘目录 image.transferTo(new File(\u0026#34;E:/images/\u0026#34;+originalFilename)); return Result.success(); } } 利用postman测试：\n注意：请求参数名和controller方法形参名保持一致\n通过postman测试，我们发现文件上传是没有问题的。但是由于我们是使用原始文件名作为所上传文件的存储名字，当我们再次上传一个名为1.jpg文件时，发现会把之前已经上传成功的文件覆盖掉。\n解决方案：保证每次上传文件时文件名都唯一的（使用UUID获取随机文件名）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Slf4j @RestController public class UploadController { @PostMapping(\u0026#34;/upload\u0026#34;) public Result upload(String username, Integer age, MultipartFile image) throws IOException { log.info(\u0026#34;文件上传：{},{},{}\u0026#34;,username,age,image); //获取原始文件名 String originalFilename = image.getOriginalFilename(); //构建新的文件名 String extname = originalFilename.substring(originalFilename.lastIndexOf(\u0026#34;.\u0026#34;));//文件扩展名 String newFileName = UUID.randomUUID().toString()+extname;//随机名+文件扩展名 //将文件存储在服务器的磁盘目录 image.transferTo(new File(\u0026#34;E:/images/\u0026#34;+newFileName)); return Result.success(); } } 在解决了文件名唯一性的问题后，我们再次上传一个较大的文件(超出1M)时发现，后端程序报错：\n报错原因呢是因为：在SpringBoot中，文件上传时默认单个文件最大大小为1M\n那么如果需要上传大文件，可以在application.properties进行如下配置：\n1 2 3 4 5 #配置单个文件最大上传大小 spring.servlet.multipart.max-file-size=10MB #配置单个请求最大上传大小(一次请求可以上传多个文件) spring.servlet.multipart.max-request-size=100MB 到时此，我们文件上传的本地存储方式已完成了。但是这种本地存储方式还存在一问题：\n如果直接存储在服务器的磁盘目录中，存在以下缺点：\n不安全：磁盘如果损坏，所有的文件就会丢失 容量有限：如果存储大量的图片，磁盘空间有限(磁盘不可能无限制扩容) 无法直接访问 为了解决上述问题呢，通常有两种解决方案：\n自己搭建存储服务器，如：fastDFS 、MinIO 使用现成的云服务，如：阿里云，腾讯云，华为云 2.3 阿里云OSS 2.3.1 准备 阿里云是阿里巴巴集团旗下全球领先的云计算公司，也是国内最大的云服务提供商 。\n云服务指的就是通过互联网对外提供的各种各样的服务，比如像：语音服务、短信服务、邮件服务、视频直播服务、文字识别服务、对象存储服务等等。\n当我们在项目开发时需要用到某个或某些服务，就不需要自己来开发了，可以直接使用阿里云提供好的这些现成服务就可以了。比如：在项目开发当中，我们要实现一个短信发送的功能，如果我们项目组自己实现，将会非常繁琐，因为你需要和各个运营商进行对接。而此时阿里云完成了和三大运营商对接，并对外提供了一个短信服务。我们项目组只需要调用阿里云提供的短信服务，就可以很方便的来发送短信了。这样就降低了我们项目的开发难度，同时也提高了项目的开发效率。（大白话：别人帮我们实现好了功能，我们只要调用即可）\n云服务提供商给我们提供的软件服务通常是需要收取一部分费用的。\n阿里云对象存储OSS（Object Storage Service），是一款海量、安全、低成本、高可靠的云存储服务。使用OSS，您可以通过网络随时存储和调用包括文本、图片、音频和视频等在内的各种文件。\n在我们使用了阿里云OSS对象存储服务之后，我们的项目当中如果涉及到文件上传这样的业务，在前端进行文件上传并请求到服务端时，在服务器本地磁盘当中就不需要再来存储文件了。我们直接将接收到的文件上传到oss，由 oss帮我们存储和管理，同时阿里云的oss存储服务还保障了我们所存储内容的安全可靠。\n那我们学习使用这类云服务，我们主要学习什么呢？其实我们主要学习的是如何在项目当中来使用云服务完成具体的业务功能。而无论使用什么样的云服务，阿里云也好，腾讯云、华为云也罢，在使用第三方的服务时，操作的思路都是一样的。\nSDK：Software Development Kit 的缩写，软件开发工具包，包括辅助软件开发的依赖（jar包）、代码示例等，都可以叫做SDK。\n简单说，sdk中包含了我们使用第三方云服务时所需要的依赖，以及一些示例代码。我们可以参照sdk所提供的示例代码就可以完成入门程序。\n第三方服务使用的通用思路，我们做一个简单介绍之后，接下来我们就来介绍一下我们当前要使用的阿里云oss对象存储服务具体的使用步骤。\nBucket：存储空间是用户用于存储对象（Object，就是文件）的容器，所有的对象都必须隶属于某个存储空间。\n下面我们根据之前介绍的使用步骤，完成准备工作：\n注册阿里云账户（注册完成后需要实名认证） 注册完账号之后，就可以登录阿里云 通过控制台找到对象存储OSS服务 如果是第一次访问，还需要开通对象存储服务OSS\n开通OSS服务之后，就可以进入到阿里云对象存储的控制台 点击左侧的 \u0026ldquo;Bucket列表\u0026rdquo;，创建一个Bucket 大家可以参照\u0026quot;资料\\04. 阿里云oss\u0026quot;中提供的文档，开通阿里云OSS服务。\n2.3.2 入门 阿里云oss 对象存储服务的准备工作我们已经完成了，接下来我们就来完成第二步操作：参照官方所提供的sdk示例来编写入门程序。\n首先我们需要来打开阿里云OSS的官方文档，在官方文档中找到 SDK 的示例代码：\n如果是在实际开发当中，我们是需要从前往后仔细的去阅读这一份文档的，但是由于现在是教学，我们就只挑重点的去看。有兴趣的同学大家下来也可以自己去看一下这份官方文档。\n参照官方提供的SDK，改造一下，即可实现文件上传功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 import com.aliyun.oss.ClientException; import com.aliyun.oss.OSS; import com.aliyun.oss.OSSClientBuilder; import com.aliyun.oss.OSSException; import com.aliyun.oss.model.PutObjectRequest; import com.aliyun.oss.model.PutObjectResult; import java.io.FileInputStream; import java.io.InputStream; public class AliOssTest { public static void main(String[] args) throws Exception { // Endpoint以华东1（杭州）为例，其它Region请按实际情况填写。 String endpoint = \u0026#34;oss-cn-shanghai.aliyuncs.com\u0026#34;; // 阿里云账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM用户进行API访问或日常运维，请登录RAM控制台创建RAM用户。 String accessKeyId = \u0026#34;LTAI5t9MZK8iq5T2Av5GLDxX\u0026#34;; String accessKeySecret = \u0026#34;C0IrHzKZGKqU8S7YQcevcotD3Zd5Tc\u0026#34;; // 填写Bucket名称，例如examplebucket。 String bucketName = \u0026#34;web-framework01\u0026#34;; // 填写Object完整路径，完整路径中不能包含Bucket名称，例如exampledir/exampleobject.txt。 String objectName = \u0026#34;1.jpg\u0026#34;; // 填写本地文件的完整路径，例如D:\\\\localpath\\\\examplefile.txt。 // 如果未指定本地路径，则默认从示例程序所属项目对应本地路径中上传文件流。 String filePath= \u0026#34;C:\\\\Users\\\\Administrator\\\\Pictures\\\\1.jpg\u0026#34;; // 创建OSSClient实例。 OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); try { InputStream inputStream = new FileInputStream(filePath); // 创建PutObjectRequest对象。 PutObjectRequest putObjectRequest = new PutObjectRequest(bucketName, objectName, inputStream); // 设置该属性可以返回response。如果不设置，则返回的response为空。 putObjectRequest.setProcess(\u0026#34;true\u0026#34;); // 创建PutObject请求。 PutObjectResult result = ossClient.putObject(putObjectRequest); // 如果上传成功，则返回200。 System.out.println(result.getResponse().getStatusCode()); } catch (OSSException oe) { System.out.println(\u0026#34;Caught an OSSException, which means your request made it to OSS, \u0026#34; + \u0026#34;but was rejected with an error response for some reason.\u0026#34;); System.out.println(\u0026#34;Error Message:\u0026#34; + oe.getErrorMessage()); System.out.println(\u0026#34;Error Code:\u0026#34; + oe.getErrorCode()); System.out.println(\u0026#34;Request ID:\u0026#34; + oe.getRequestId()); System.out.println(\u0026#34;Host ID:\u0026#34; + oe.getHostId()); } catch (ClientException ce) { System.out.println(\u0026#34;Caught an ClientException, which means the client encountered \u0026#34; + \u0026#34;a serious internal problem while trying to communicate with OSS, \u0026#34; + \u0026#34;such as not being able to access the network.\u0026#34;); System.out.println(\u0026#34;Error Message:\u0026#34; + ce.getMessage()); } finally { if (ossClient != null) { ossClient.shutdown(); } } } } 在以上代码中，需要替换的内容为：\naccessKeyId：阿里云账号AccessKey accessKeySecret：阿里云账号AccessKey对应的秘钥 bucketName：Bucket名称 objectName：对象名称，在Bucket中存储的对象的名称 filePath：文件路径 AccessKey ：\n运行以上程序后，会把本地的文件上传到阿里云OSS服务器上：\n2.3.3 集成 阿里云oss对象存储服务的准备工作以及入门程序我们都已经完成了，接下来我们就需要在案例当中集成oss对象存储服务，来存储和管理案例中上传的图片。\n在新增员工的时候，上传员工的图像，而之所以需要上传员工的图像，是因为将来我们需要在系统页面当中访问并展示员工的图像。而要想完成这个操作，需要做两件事：\n需要上传员工的图像，并把图像保存起来（存储到阿里云OSS） 访问员工图像（通过图像在阿里云OSS的存储地址访问图像） OSS中的每一个文件都会分配一个访问的url，通过这个url就可以访问到存储在阿里云上的图片。所以需要把url返回给前端，这样前端就可以通过url获取到图像。 我们参照接口文档来开发文件上传功能：\n基本信息\n1 2 3 4 5 请求路径：/upload 请求方式：POST 接口描述：上传图片接口 请求参数\n参数格式：multipart/form-data\n参数说明：\n参数名称 参数类型 是否必须 示例 备注 image file 是 响应数据\n参数格式：application/json\n参数说明：\n参数名 类型 是否必须 备注 code number 必须 响应码，1 代表成功，0 代表失败 msg string 非必须 提示信息 data object 非必须 返回的数据，上传图片的访问路径 响应数据样例：\n1 2 3 4 5 { \u0026#34;code\u0026#34;: 1, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: \u0026#34;https://web-framework.oss-cn-hangzhou.aliyuncs.com/2022-09-02-00-27-0400.jpg\u0026#34; } 引入阿里云OSS上传文件工具类（由官方的示例代码改造而来）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import com.aliyun.oss.OSS; import com.aliyun.oss.OSSClientBuilder; import org.springframework.stereotype.Component; import org.springframework.web.multipart.MultipartFile; import java.io.IOException; import java.io.InputStream; import java.util.UUID; @Component public class AliOSSUtils { private String endpoint = \u0026#34;https://oss-cn-shanghai.aliyuncs.com\u0026#34;; private String accessKeyId = \u0026#34;LTAI5t9MZK8iq5T2Av5GLDxX\u0026#34;; private String accessKeySecret = \u0026#34;C0IrHzKZGKqU8S7YQcevcotD3Zd5Tc\u0026#34;; private String bucketName = \u0026#34;web-framework01\u0026#34;; /** * 实现上传图片到OSS */ public String upload(MultipartFile multipartFile) throws IOException { // 获取上传的文件的输入流 InputStream inputStream = multipartFile.getInputStream(); // 避免文件覆盖 String originalFilename = multipartFile.getOriginalFilename(); String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(\u0026#34;.\u0026#34;)); //上传文件到 OSS OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); ossClient.putObject(bucketName, fileName, inputStream); //文件访问路径 String url = endpoint.split(\u0026#34;//\u0026#34;)[0] + \u0026#34;//\u0026#34; + bucketName + \u0026#34;.\u0026#34; + endpoint.split(\u0026#34;//\u0026#34;)[1] + \u0026#34;/\u0026#34; + fileName; // 关闭ossClient ossClient.shutdown(); return url;// 把上传到oss的路径返回 } } 修改UploadController代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import com.itheima.pojo.Result; import com.itheima.utils.AliOSSUtils; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.multipart.MultipartFile; import java.io.IOException; @Slf4j @RestController public class UploadController { @Autowired private AliOSSUtils aliOSSUtils; @PostMapping(\u0026#34;/upload\u0026#34;) public Result upload(MultipartFile image) throws IOException { //调用阿里云OSS工具类，将上传上来的文件存入阿里云 String url = aliOSSUtils.upload(image); //将图片上传完成后的url返回，用于浏览器回显展示 return Result.success(url); } } 使用postman测试：\n3. 修改员工 需求：修改员工信息\n在进行修改员工信息的时候，我们首先先要根据员工的ID查询员工的信息用于页面回显展示，然后用户修改员工数据之后，点击保存按钮，就可以将修改的数据提交到服务端，保存到数据库。 具体操作为：\n根据ID查询员工信息 保存修改的员工信息 3.1 查询回显 3.1.1 接口文档 根据ID查询员工数据\n基本信息\n1 2 3 4 5 请求路径：/emps/{id} 请求方式：GET 接口描述：该接口用于根据主键ID查询员工的信息 请求参数\n参数格式：路径参数\n参数说明：\n参数名 类型 是否必须 备注 id number 必须 员工ID 请求参数样例：\n1 /emps/1 响应数据\n参数格式：application/json\n参数说明：\n名称 类型 是否必须 默认值 备注 code number 必须 响应码, 1 成功 , 0 失败 msg string 非必须 提示信息 data object 必须 返回的数据 |- id number 非必须 id |- username string 非必须 用户名 |- name string 非必须 姓名 |- password string 非必须 密码 |- entrydate string 非必须 入职日期 |- gender number 非必须 性别 , 1 男 ; 2 女 |- image string 非必须 图像 |- job number 非必须 职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管, 5 咨询师 |- deptId number 非必须 部门id |- createTime string 非必须 创建时间 |- updateTime string 非必须 更新时间 响应数据样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \u0026#34;code\u0026#34;: 1, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 2, \u0026#34;username\u0026#34;: \u0026#34;zhangwuji\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;123456\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;张无忌\u0026#34;, \u0026#34;gender\u0026#34;: 1, \u0026#34;image\u0026#34;: \u0026#34;https://web-framework.oss-cn-hangzhou.aliyuncs.com/2022-09-02-00-27-53B.jpg\u0026#34;, \u0026#34;job\u0026#34;: 2, \u0026#34;entrydate\u0026#34;: \u0026#34;2015-01-01\u0026#34;, \u0026#34;deptId\u0026#34;: 2, \u0026#34;createTime\u0026#34;: \u0026#34;2022-09-01T23:06:30\u0026#34;, \u0026#34;updateTime\u0026#34;: \u0026#34;2022-09-02T00:29:04\u0026#34; } } 3.1.2 实现思路 3.1.3 代码实现 EmpMapper 1 2 3 4 5 6 7 8 9 10 11 12 @Mapper public interface EmpMapper { //根据ID查询员工信息 @Select(\u0026#34;select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time \u0026#34; + \u0026#34;from emp \u0026#34; + \u0026#34;where id = #{id}\u0026#34;) public Emp findById(Integer id); //省略... } EmpService 1 2 3 4 5 6 7 8 9 10 11 public interface EmpService { /** * 根据ID查询员工 * @param id * @return */ public Emp getById(Integer id); //省略... } EmpServiceImpl 1 2 3 4 5 6 7 8 9 10 11 12 13 @Slf4j @Service public class EmpServiceImpl implements EmpService { @Autowired private EmpMapper empMapper; @Override public Emp getById(Integer id) { return empMapper.findById(id); } //省略... } EmpController 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Slf4j @RestController @RequestMapping(\u0026#34;/emps\u0026#34;) public class EmpController { @Autowired private EmpService empService; //根据id查询 @GetMapping(\u0026#34;/{id}\u0026#34;) public Result getById(@PathVariable Integer id){ Emp emp = empService.getById(id); return Result.success(emp); } //省略... } 3.1.4 postman测试 3.2 修改员工 当用户修改完数据之后，点击保存按钮，就需要将数据提交到服务端，然后服务端需要将修改后的数据更新到数据库中。\n3.2.1 接口文档 基本信息\n1 2 3 4 5 请求路径：/emps 请求方式：PUT 接口描述：该接口用于修改员工的数据信息 请求参数\n参数格式：application/json\n参数说明：\n名称 类型 是否必须 备注 id number 必须 id username string 必须 用户名 name string 必须 姓名 gender number 必须 性别, 说明: 1 男, 2 女 image string 非必须 图像 deptId number 非必须 部门id entrydate string 非必须 入职日期 job number 非必须 职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管, 5 咨询师 请求数据样例：\n1 2 3 4 5 6 7 8 9 10 { \u0026#34;id\u0026#34;: 1, \u0026#34;image\u0026#34;: \u0026#34;https://web-framework.oss-cn-hangzhou.aliyuncs.com/2022-09-03-07-37-38222.jpg\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;linpingzhi\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;林平之\u0026#34;, \u0026#34;gender\u0026#34;: 1, \u0026#34;job\u0026#34;: 1, \u0026#34;entrydate\u0026#34;: \u0026#34;2022-09-18\u0026#34;, \u0026#34;deptId\u0026#34;: 1 } 响应数据\n参数格式：application/json\n参数说明：\n参数名 类型 是否必须 备注 code number 必须 响应码，1 代表成功，0 代表失败 msg string 非必须 提示信息 data object 非必须 返回的数据 响应数据样例：\n1 2 3 4 5 { \u0026#34;code\u0026#34;:1, \u0026#34;msg\u0026#34;:\u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;:null } 3.2.2 实现思路 3.2.3 代码实现 EmpMapper 1 2 3 4 5 6 7 @Mapper public interface EmpMapper { //修改员工信息 public void update(Emp emp); //省略... } EmpMapper.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.itheima.mapper.EmpMapper\u0026#34;\u0026gt; \u0026lt;!--更新员工信息--\u0026gt; \u0026lt;update id=\u0026#34;update\u0026#34;\u0026gt; update emp \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;username != null and username != \u0026#39;\u0026#39;\u0026#34;\u0026gt; username = #{username}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;password != null and password != \u0026#39;\u0026#39;\u0026#34;\u0026gt; password = #{password}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name != null and name != \u0026#39;\u0026#39;\u0026#34;\u0026gt; name = #{name}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt; gender = #{gender}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;image != null and image != \u0026#39;\u0026#39;\u0026#34;\u0026gt; image = #{image}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;job != null\u0026#34;\u0026gt; job = #{job}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;entrydate != null\u0026#34;\u0026gt; entrydate = #{entrydate}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;deptId != null\u0026#34;\u0026gt; dept_id = #{deptId}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;updateTime != null\u0026#34;\u0026gt; update_time = #{updateTime} \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id} \u0026lt;/update\u0026gt; \u0026lt;!-- 省略... --\u0026gt; \u0026lt;/mapper\u0026gt; EmpService 1 2 3 4 5 6 7 8 9 public interface EmpService { /** * 更新员工 * @param emp */ public void update(Emp emp); //省略... } EmpServiceImpl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Slf4j @Service public class EmpServiceImpl implements EmpService { @Autowired private EmpMapper empMapper; @Override public void update(Emp emp) { emp.setUpdateTime(LocalDateTime.now()); //更新修改时间为当前时间 empMapper.update(emp); } //省略... } EmpController 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Slf4j @RestController @RequestMapping(\u0026#34;/emps\u0026#34;) public class EmpController { @Autowired private EmpService empService; //修改员工 @PutMapping public Result update(@RequestBody Emp emp){ empService.update(emp); return Result.success(); } //省略... } 3.2.4 postman测试 3.2.5 前后端联调测试 4. 配置文件 员工管理的增删改查功能我们已开发完成，但在我们所开发的程序中还一些小问题，下面我们就来分析一下当前案例中存在的问题以及如何优化解决。\n4.1 参数配置化 在我们之前编写的程序中进行文件上传时，需要调用AliOSSUtils工具类，将文件上传到阿里云OSS对象存储服务当中。而在调用工具类进行文件上传时，需要一些参数：\nendpoint //阿里云OSS域名 accessKeyID //用户身份ID accessKeySecret //用户密钥 bucketName //存储空间的名字 关于以上的这些阿里云相关配置信息，我们是直接写死在java代码中了(硬编码)，如果我们在做项目时每涉及到一个第三方技术服务，就将其参数硬编码，那么在Java程序中会存在两个问题：\n如果这些参数发生变化了，就必须在源程序代码中改动这些参数，然后需要重新进行代码的编译，将Java代码编译成class字节码文件再重新运行程序。（比较繁琐） 如果我们开发的是一个真实的企业级项目， Java类可能会有很多，如果将这些参数分散的定义在各个Java类当中，我们要修改一个参数值，我们就需要在众多的Java代码当中来定位到对应的位置，再来修改参数，修改完毕之后再重新编译再运行。（参数配置过于分散，是不方便集中的管理和维护） 为了解决以上分析的问题，我们可以将参数配置在配置文件中。如下：\n1 2 3 4 5 #自定义的阿里云OSS配置信息 aliyun.oss.endpoint=https://oss-cn-hangzhou.aliyuncs.com aliyun.oss.accessKeyId=LTAI4GCH1vX6DKqJWxd6nEuW aliyun.oss.accessKeySecret=yBshYweHOpqDuhCArrVHwIiBKpyqSL aliyun.oss.bucketName=web-tlias 在将阿里云OSS配置参数交给properties配置文件来管理之后，我们的AliOSSUtils工具类就变为以下形式：\n1 2 3 4 5 6 7 8 9 10 @Component public class AliOSSUtils { /*以下4个参数没有指定值（默认值：null）*/ private String endpoint; private String accessKeyId; private String accessKeySecret; private String bucketName; //省略其他代码... } 而此时如果直接调用AliOSSUtils类当中的upload方法进行文件上传时，这4项参数全部为null，原因是因为并没有给它赋值。\n此时我们是不是需要将配置文件当中所配置的属性值读取出来，并分别赋值给AliOSSUtils工具类当中的各个属性呢？那应该怎么做呢？\n因为application.properties是springboot项目默认的配置文件，所以springboot程序在启动时会默认读取application.properties配置文件，而我们可以使用一个现成的注解：@Value，获取配置文件中的数据。\n@Value 注解通常用于外部配置的属性注入，具体用法为： @Value(\u0026quot;${配置文件中的key}\u0026quot;)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Component public class AliOSSUtils { @Value(\u0026#34;${aliyun.oss.endpoint}\u0026#34;) private String endpoint; @Value(\u0026#34;${aliyun.oss.accessKeyId}\u0026#34;) private String accessKeyId; @Value(\u0026#34;${aliyun.oss.accessKeySecret}\u0026#34;) private String accessKeySecret; @Value(\u0026#34;${aliyun.oss.bucketName}\u0026#34;) private String bucketName; //省略其他代码... } 使用postman测试：\n4.2 yml配置文件 前面我们一直使用springboot项目创建完毕后自带的application.properties进行属性的配置，那其实呢，在springboot项目当中是支持多种配置方式的，除了支持properties配置文件以外，还支持另外一种类型的配置文件，就是我们接下来要讲解的yml格式的配置文件。\napplication.properties\n1 2 server.port=8080 server.address=127.0.0.1 application.yml\n1 2 3 server: port: 8080 address: 127.0.0.1 application.yaml\n1 2 3 server: port: 8080 address: 127.0.0.1 yml 格式的配置文件，后缀名有两种：\nyml （推荐） yaml 常见配置文件格式对比：\n我们可以看到配置同样的数据信息，yml格式的数据有以下特点：\n容易阅读 容易与脚本语言交互 以数据为核心，重数据轻格式 简单的了解过springboot所支持的配置文件，以及不同类型配置文件之间的优缺点之后，接下来我们就来了解下yml配置文件的基本语法：\n大小写敏感 数值前边必须有空格，作为分隔符 使用缩进表示层级关系，缩进时，不允许使用Tab键，只能用空格（idea中会自动将Tab转换为空格） 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 #表示注释，从这个字符一直到行尾，都会被解析器忽略 了解完yml格式配置文件的基本语法之后，接下来我们再来看下yml文件中常见的数据格式。在这里我们主要介绍最为常见的两类：\n定义对象或Map集合 定义数组、list或set集合 对象/Map集合\n1 2 3 4 user: name: zhangsan age: 18 password: 123456 数组/List/Set集合\n1 2 3 4 hobby: - java - game - sport 熟悉完了yml文件的基本语法后，我们修改下之前案例中使用的配置文件，变更为application.yml配置方式：\n修改application.properties名字为：_application.properties（名字随便更换，只要加载不到即可） 创建新的配置文件： application.yml 原有application.properties文件：\n新建的application.yml文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/tlias username: root password: 1234 servlet: multipart: max-file-size: 10MB max-request-size: 100MB mybatis: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl map-underscore-to-camel-case: true aliyun: oss: endpoint: https://oss-cn-hangzhou.aliyuncs.com accessKeyId: LTAI4GCH1vX6DKqJWxd6nEuW accessKeySecret: yBshYweHOpqDuhCArrVHwIiBKpyqSL bucketName: web-397 4.3 @ConfigurationProperties 讲解完了yml配置文件之后，最后再来介绍一个注解@ConfigurationProperties。在介绍注解之前，我们先来看一个场景，分析下代码当中可能存在的问题：\n我们在application.properties或者application.yml中配置了阿里云OSS的四项参数之后，如果java程序中需要这四项参数数据，我们直接通过@Value注解来进行注入。这种方式本身没有什么问题问题，但是如果说需要注入的属性较多(例：需要20多个参数数据)，我们写起来就会比较繁琐。\n那么有没有一种方式可以简化这些配置参数的注入呢？答案是肯定有，在Spring中给我们提供了一种简化方式，可以直接将配置文件中配置项的值自动的注入到对象的属性中。\nSpring提供的简化方式套路：\n需要创建一个实现类，且实体类中的属性名和配置文件当中key的名字必须要一致\n比如：配置文件当中叫endpoints，实体类当中的属性也得叫endpoints，另外实体类当中的属性还需要提供 getter / setter方法\n需要将实体类交给Spring的IOC容器管理，成为IOC容器当中的bean对象\n在实体类上添加@ConfigurationProperties注解，并通过perfect属性来指定配置参数项的前缀\n实体类：AliOSSProperties\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import lombok.Data; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; /*阿里云OSS相关配置*/ @Data @Component @ConfigurationProperties(prefix = \u0026#34;aliyun.oss\u0026#34;) public class AliOSSProperties { //区域 private String endpoint; //身份ID private String accessKeyId ; //身份密钥 private String accessKeySecret ; //存储空间 private String bucketName; } AliOSSUtils工具类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import com.aliyun.oss.OSS; import com.aliyun.oss.OSSClientBuilder; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import org.springframework.web.multipart.MultipartFile; import java.io.IOException; import java.io.InputStream; import java.util.UUID; @Component //当前类对象由Spring创建和管理 public class AliOSSUtils { //注入配置参数实体类对象 @Autowired private AliOSSProperties aliOSSProperties; /** * 实现上传图片到OSS */ public String upload(MultipartFile multipartFile) throws IOException { // 获取上传的文件的输入流 InputStream inputStream = multipartFile.getInputStream(); // 避免文件覆盖 String originalFilename = multipartFile.getOriginalFilename(); String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(\u0026#34;.\u0026#34;)); //上传文件到 OSS OSS ossClient = new OSSClientBuilder().build(aliOSSProperties.getEndpoint(), aliOSSProperties.getAccessKeyId(), aliOSSProperties.getAccessKeySecret()); ossClient.putObject(aliOSSProperties.getBucketName(), fileName, inputStream); //文件访问路径 String url =aliOSSProperties.getEndpoint().split(\u0026#34;//\u0026#34;)[0] + \u0026#34;//\u0026#34; + aliOSSProperties.getBucketName() + \u0026#34;.\u0026#34; + aliOSSProperties.getEndpoint().split(\u0026#34;//\u0026#34;)[1] + \u0026#34;/\u0026#34; + fileName; // 关闭ossClient ossClient.shutdown(); return url;// 把上传到oss的路径返回 } } 在我们添加上注解后，会发现idea窗口上面出现一个红色警告：\n这个警告提示是告知我们还需要引入一个依赖：\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 当我们在pom.xml文件当中配置了这项依赖之后，我们重新启动服务，大家就会看到在properties或者是yml配置文件当中，就会提示阿里云 OSS 相关的配置项。所以这项依赖它的作用就是会自动的识别被@Configuration Properties注解标识的bean对象。\n刚才的红色警告，已经变成了一个灰色的提示，提示我们需要重新运行springboot服务\n@ConfigurationProperties注解我们已经介绍完了，接下来我们就来区分一下@ConfigurationProperties注解以及我们前面所介绍的另外一个@Value注解：\n相同点：都是用来注入外部配置的属性的。\n不同点：\n@Value注解只能一个一个的进行外部属性的注入。\n@ConfigurationProperties可以批量的将外部的属性配置注入到bean对象的属性中。\n如果要注入的属性非常的多，并且还想做到复用，就可以定义这么一个bean对象。通过 configuration properties 批量的将外部的属性配置直接注入到 bin 对象的属性当中。在其他的类当中，我要想获取到注入进来的属性，我直接注入 bin 对象，然后调用 get 方法，就可以获取到对应的属性值了\n","date":"2024-07-05T22:27:20+08:00","image":"https://picsum.photos/800/600 ","permalink":"https://4evergreat.github.io/2024/springboot-blog-4/","title":"springboot-blog-4 案例篇2"},{"content":"案例-登录认证 在前面的课程中，我们已经实现了部门管理、员工管理的基本功能，但是大家会发现，我们并没有登录，就直接访问到了Tlias智能学习辅助系统的后台。 这是不安全的，所以我们今天的主题就是登录认证。 最终我们要实现的效果就是用户必须登录之后，才可以访问后台系统中的功能。\n1. 登录功能 1.1 需求 在登录界面中，我们可以输入用户的用户名以及密码，然后点击 \u0026ldquo;登录\u0026rdquo; 按钮就要请求服务器，服务端判断用户输入的用户名或者密码是否正确。如果正确，则返回成功结果，前端跳转至系统首页面。\n1.2 接口文档 我们参照接口文档来开发登录功能\n基本信息\n1 2 3 4 5 请求路径：/login 请求方式：POST 接口描述：该接口用于员工登录Tlias智能学习辅助系统，登录完毕后，系统下发JWT令牌。 请求参数\n参数格式：application/json\n参数说明：\n名称 类型 是否必须 备注 username string 必须 用户名 password string 必须 密码 请求数据样例：\n1 2 3 4 { \u0026#34;username\u0026#34;: \u0026#34;jinyong\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;123456\u0026#34; } 响应数据\n参数格式：application/json\n参数说明：\n名称 类型 是否必须 默认值 备注 其他信息 code number 必须 响应码, 1 成功 ; 0 失败 msg string 非必须 提示信息 data string 必须 返回的数据 , jwt令牌 响应数据样例：\n1 2 3 4 5 { \u0026#34;code\u0026#34;: 1, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: \u0026#34;eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoi6YeR5bq4IiwiaWQiOjEsInVzZXJuYW1lIjoiamlueW9uZyIsImV4cCI6MTY2MjIwNzA0OH0.KkUc_CXJZJ8Dd063eImx4H9Ojfrr6XMJ-yVzaWCVZCo\u0026#34; } 1.3 思路分析 登录服务端的核心逻辑就是：接收前端请求传递的用户名和密码 ，然后再根据用户名和密码查询用户信息，如果用户信息存在，则说明用户输入的用户名和密码正确。如果查询到的用户不存在，则说明用户输入的用户名和密码错误。\n1.4 功能开发 LoginController\n1 2 3 4 5 6 7 8 9 10 11 12 @RestController public class LoginController { @Autowired private EmpService empService; @PostMapping(\u0026#34;/login\u0026#34;) public Result login(@RequestBody Emp emp){ Emp e = empService.login(emp); return e != null ? Result.success():Result.error(\u0026#34;用户名或密码错误\u0026#34;); } } EmpService\n1 2 3 4 5 6 7 8 9 10 11 public interface EmpService { /** * 用户登录 * @param emp * @return */ public Emp login(Emp emp); //省略其他代码... } EmpServiceImpl\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Slf4j @Service public class EmpServiceImpl implements EmpService { @Autowired private EmpMapper empMapper; @Override public Emp login(Emp emp) { //调用dao层功能：登录 Emp loginEmp = empMapper.getByUsernameAndPassword(emp); //返回查询结果给Controller return loginEmp; } //省略其他代码... } EmpMapper\n1 2 3 4 5 6 7 8 9 10 @Mapper public interface EmpMapper { @Select(\u0026#34;select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time \u0026#34; + \u0026#34;from emp \u0026#34; + \u0026#34;where username=#{username} and password =#{password}\u0026#34;) public Emp getByUsernameAndPassword(Emp emp); //省略其他代码... } 1.5 测试 功能开发完毕后，我们就可以启动服务，打开postman进行测试了。\n发起POST请求，访问：http://localhost:8080/login\npostman测试通过了，那接下来，我们就可以结合着前端工程进行联调测试。\n先退出系统，进入到登录页面：\n在登录页面输入账户密码：\n登录成功之后进入到后台管理系统页面：\n2. 登录校验 2.1 问题分析 我们已经完成了基础登录功能的开发与测试，在我们登录成功后就可以进入到后台管理系统中进行数据的操作。\n但是当我们在浏览器中新的页面上输入地址：http://localhost:9528/#/system/dept，发现没有登录仍然可以进入到后端管理系统页面。\n而真正的登录功能应该是：登陆后才能访问后端系统页面，不登陆则跳转登陆页面进行登陆。\n为什么会出现这个问题？其实原因很简单，就是因为针对于我们当前所开发的部门管理、员工管理以及文件上传等相关接口来说，我们在服务器端并没有做任何的判断，没有去判断用户是否登录了。所以无论用户是否登录，都可以访问部门管理以及员工管理的相关数据。所以我们目前所开发的登录功能，它只是徒有其表。而我们要想解决这个问题，我们就需要完成一步非常重要的操作：登录校验。\n什么是登录校验？\n所谓登录校验，指的是我们在服务器端接收到浏览器发送过来的请求之后，首先我们要对请求进行校验。先要校验一下用户登录了没有，如果用户已经登录了，就直接执行对应的业务操作就可以了；如果用户没有登录，此时就不允许他执行相关的业务操作，直接给前端响应一个错误的结果，最终跳转到登录页面，要求他登录成功之后，再来访问对应的数据。 了解完什么是登录校验之后，接下来我们分析一下登录校验大概的实现思路。\n首先我们在宏观上先有一个认知：\n前面在讲解HTTP协议的时候，我们提到HTTP协议是无状态协议。什么又是无状态的协议？\n所谓无状态，指的是每一次请求都是独立的，下一次请求并不会携带上一次请求的数据。而浏览器与服务器之间进行交互，基于HTTP协议也就意味着现在我们通过浏览器来访问了登陆这个接口，实现了登陆的操作，接下来我们在执行其他业务操作时，服务器也并不知道这个员工到底登陆了没有。因为HTTP协议是无状态的，两次请求之间是独立的，所以是无法判断这个员工到底登陆了没有。\n那应该怎么来实现登录校验的操作呢？具体的实现思路可以分为两部分：\n在员工登录成功后，需要将用户登录成功的信息存起来，记录用户已经登录成功的标记。 在浏览器发起请求时，需要在服务端进行统一拦截，拦截后进行登录校验。 想要判断员工是否已经登录，我们需要在员工登录成功之后，存储一个登录成功的标记，接下来在每一个接口方法执行之前，先做一个条件判断，判断一下这个员工到底登录了没有。如果是登录了，就可以执行正常的业务操作，如果没有登录，会直接给前端返回一个错误的信息，前端拿到这个错误信息之后会自动的跳转到登录页面。\n我们程序中所开发的查询功能、删除功能、添加功能、修改功能，都需要使用以上套路进行登录校验。此时就会出现：相同代码逻辑，每个功能都需要编写，就会造成代码非常繁琐。\n为了简化这块操作，我们可以使用一种技术：统一拦截技术。\n通过统一拦截的技术，我们可以来拦截浏览器发送过来的所有的请求，拦截到这个请求之后，就可以通过请求来获取之前所存入的登录标记，在获取到登录标记且标记为登录成功，就说明员工已经登录了。如果已经登录，我们就直接放行(意思就是可以访问正常的业务接口了)。\n我们要完成以上操作，会涉及到web开发中的两个技术：\n会话技术 统一拦截技术 而统一拦截技术现实方案也有两种：\nServlet规范中的Filter过滤器 Spring提供的interceptor拦截器 下面我们先学习会话技术，然后再学习统一拦截技术。\n2.2 会话技术 介绍了登录校验的大概思路之后，我们先来学习下会话技术。\n2.2.1 会话技术介绍 什么是会话？\n在我们日常生活当中，会话指的就是谈话、交谈。\n在web开发当中，会话指的就是浏览器与服务器之间的一次连接，我们就称为一次会话。\n在用户打开浏览器第一次访问服务器的时候，这个会话就建立了，直到有任何一方断开连接，此时会话就结束了。在一次会话当中，是可以包含多次请求和响应的。\n比如：打开了浏览器来访问web服务器上的资源（浏览器不能关闭、服务器不能断开）\n第1次：访问的是登录的接口，完成登录操作 第2次：访问的是部门管理接口，查询所有部门数据 第3次：访问的是员工管理接口，查询员工数据 只要浏览器和服务器都没有关闭，以上3次请求都属于一次会话当中完成的。\n需要注意的是：会话是和浏览器关联的，当有三个浏览器客户端和服务器建立了连接时，就会有三个会话。同一个浏览器在未关闭之前请求了多次服务器，这多次请求是属于同一个会话。比如：1、2、3这三个请求都是属于同一个会话。当我们关闭浏览器之后，这次会话就结束了。而如果我们是直接把web服务器关了，那么所有的会话就都结束了。\n知道了会话的概念了，接下来我们再来了解下会话跟踪。\n会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。\n服务器会接收很多的请求，但是服务器是需要识别出这些请求是不是同一个浏览器发出来的。比如：1和2这两个请求是不是同一个浏览器发出来的，3和5这两个请求不是同一个浏览器发出来的。如果是同一个浏览器发出来的，就说明是同一个会话。如果是不同的浏览器发出来的，就说明是不同的会话。而识别多次请求是否来自于同一浏览器的过程，我们就称为会话跟踪。\n我们使用会话跟踪技术就是要完成在同一个会话中，多个请求之间进行共享数据。\n为什么要共享数据呢？\n由于HTTP是无状态协议，在后面请求中怎么拿到前一次请求生成的数据呢？此时就需要在一次会话的多次请求之间进行数据共享\n会话跟踪技术有两种：\nCookie（客户端会话跟踪技术） 数据存储在客户端浏览器当中 Session（服务端会话跟踪技术） 数据存储在储在服务端 令牌技术 2.2.2 会话跟踪方案 上面我们介绍了什么是会话，什么是会话跟踪，并且也提到了会话跟踪 3 种常见的技术方案。接下来，我们就来对比一下这 3 种会话跟踪的技术方案，来看一下具体的实现思路，以及它们之间的优缺点。\n2.2.2.1 方案一 - Cookie cookie 是客户端会话跟踪技术，它是存储在客户端浏览器的，我们使用 cookie 来跟踪会话，我们就可以在浏览器第一次发起请求来请求服务器的时候，我们在服务器端来设置一个cookie。\n比如第一次请求了登录接口，登录接口执行完成之后，我们就可以设置一个cookie，在 cookie 当中我们就可以来存储用户相关的一些数据信息。比如我可以在 cookie 当中来存储当前登录用户的用户名，用户的ID。\n服务器端在给客户端在响应数据的时候，会自动的将 cookie 响应给浏览器，浏览器接收到响应回来的 cookie 之后，会自动的将 cookie 的值存储在浏览器本地。接下来在后续的每一次请求当中，都会将浏览器本地所存储的 cookie 自动地携带到服务端。\n接下来在服务端我们就可以获取到 cookie 的值。我们可以去判断一下这个 cookie 的值是否存在，如果不存在这个cookie，就说明客户端之前是没有访问登录接口的；如果存在 cookie 的值，就说明客户端之前已经登录完成了。这样我们就可以基于 cookie 在同一次会话的不同请求之间来共享数据。\n我刚才在介绍流程的时候，用了 3 个自动：\n服务器会 自动 的将 cookie 响应给浏览器。\n浏览器接收到响应回来的数据之后，会 自动 的将 cookie 存储在浏览器本地。\n在后续的请求当中，浏览器会 自动 的将 cookie 携带到服务器端。\n为什么这一切都是自动化进行的？\n是因为 cookie 它是 HTP 协议当中所支持的技术，而各大浏览器厂商都支持了这一标准。在 HTTP 协议官方给我们提供了一个响应头和请求头：\n响应头 Set-Cookie ：设置Cookie数据的\n请求头 Cookie：携带Cookie数据的\n代码测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Slf4j @RestController public class SessionController { //设置Cookie @GetMapping(\u0026#34;/c1\u0026#34;) public Result cookie1(HttpServletResponse response){ response.addCookie(new Cookie(\u0026#34;login_username\u0026#34;,\u0026#34;itheima\u0026#34;)); //设置Cookie/响应Cookie return Result.success(); } //获取Cookie @GetMapping(\u0026#34;/c2\u0026#34;) public Result cookie2(HttpServletRequest request){ Cookie[] cookies = request.getCookies(); for (Cookie cookie : cookies) { if(cookie.getName().equals(\u0026#34;login_username\u0026#34;)){ System.out.println(\u0026#34;login_username: \u0026#34;+cookie.getValue()); //输出name为login_username的cookie } } return Result.success(); } } A. 访问c1接口，设置Cookie，http://localhost:8080/c1\n我们可以看到，设置的cookie，通过响应头Set-Cookie响应给浏览器，并且浏览器会将Cookie，存储在浏览器端。\nB. 访问c2接口 http://localhost:8080/c2，此时浏览器会自动的将Cookie携带到服务端，是通过请求头Cookie，携带的。\n优缺点\n优点：HTTP协议中支持的技术（像Set-Cookie 响应头的解析以及 Cookie 请求头数据的携带，都是浏览器自动进行的，是无需我们手动操作的） 缺点： 移动端APP(Android、IOS)中无法使用Cookie 不安全，用户可以自己禁用Cookie Cookie不能跨域 跨域介绍：\n​\t现在的项目，大部分都是前后端分离的，前后端最终也会分开部署，前端部署在服务器 192.168.150.200 上，端口 80，后端部署在 192.168.150.100上，端口 8080 我们打开浏览器直接访问前端工程，访问url：http://192.168.150.200/login.html 然后在该页面发起请求到服务端，而服务端所在地址不再是localhost，而是服务器的IP地址192.168.150.100，假设访问接口地址为：http://192.168.150.100:8080/login 那此时就存在跨域操作了，因为我们是在 http://192.168.150.200/login.html 这个页面上访问了http://192.168.150.100:8080/login 接口 此时如果服务器设置了一个Cookie，这个Cookie是不能使用的，因为Cookie无法跨域 区分跨域的维度：\n协议 IP/协议 端口 只要上述的三个维度有任何一个维度不同，那就是跨域操作\n举例：\n​\thttp://192.168.150.200/login.html \u0026mdash;\u0026mdash;\u0026mdash;-\u0026gt; https://192.168.150.200/login [协议不同，跨域]\n​\thttp://192.168.150.200/login.html \u0026mdash;\u0026mdash;\u0026mdash;-\u0026gt; http://192.168.150.100/login [IP不同，跨域]\n​\thttp://192.168.150.200/login.html \u0026mdash;\u0026mdash;\u0026mdash;-\u0026gt; http://192.168.150.200:8080/login [端口不同，跨域]\n​ http://192.168.150.200/login.html \u0026mdash;\u0026mdash;\u0026mdash;-\u0026gt; http://192.168.150.200/login [不跨域]\n2.2.2.2 方案二 - Session 前面介绍的时候，我们提到Session，它是服务器端会话跟踪技术，所以它是存储在服务器端的。而 Session 的底层其实就是基于我们刚才所介绍的 Cookie 来实现的。\n获取Session\n如果我们现在要基于 Session 来进行会话跟踪，浏览器在第一次请求服务器的时候，我们就可以直接在服务器当中来获取到会话对象Session。如果是第一次请求Session ，会话对象是不存在的，这个时候服务器会自动的创建一个会话对象Session 。而每一个会话对象Session ，它都有一个ID（示意图中Session后面括号中的1，就表示ID），我们称之为 Session 的ID。\n响应Cookie (JSESSIONID)\n接下来，服务器端在给浏览器响应数据的时候，它会将 Session 的 ID 通过 Cookie 响应给浏览器。其实在响应头当中增加了一个 Set-Cookie 响应头。这个 Set-Cookie 响应头对应的值是不是cookie？ cookie 的名字是固定的 JSESSIONID 代表的服务器端会话对象 Session 的 ID。浏览器会自动识别这个响应头，然后自动将Cookie存储在浏览器本地。\n查找Session\n接下来，在后续的每一次请求当中，都会将 Cookie 的数据获取出来，并且携带到服务端。接下来服务器拿到JSESSIONID这个 Cookie 的值，也就是 Session 的ID。拿到 ID 之后，就会从众多的 Session 当中来找到当前请求对应的会话对象Session。\n这样我们是不是就可以通过 Session 会话对象在同一次会话的多次请求之间来共享数据了？好，这就是基于 Session 进行会话跟踪的流程。\n代码测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Slf4j @RestController public class SessionController { @GetMapping(\u0026#34;/s1\u0026#34;) public Result session1(HttpSession session){ log.info(\u0026#34;HttpSession-s1: {}\u0026#34;, session.hashCode()); session.setAttribute(\u0026#34;loginUser\u0026#34;, \u0026#34;tom\u0026#34;); //往session中存储数据 return Result.success(); } @GetMapping(\u0026#34;/s2\u0026#34;) public Result session2(HttpServletRequest request){ HttpSession session = request.getSession(); log.info(\u0026#34;HttpSession-s2: {}\u0026#34;, session.hashCode()); Object loginUser = session.getAttribute(\u0026#34;loginUser\u0026#34;); //从session中获取数据 log.info(\u0026#34;loginUser: {}\u0026#34;, loginUser); return Result.success(loginUser); } } A. 访问 s1 接口，http://localhost:8080/s1\n请求完成之后，在响应头中，就会看到有一个Set-Cookie的响应头，里面响应回来了一个Cookie，就是JSESSIONID，这个就是服务端会话对象 Session 的ID。\nB. 访问 s2 接口，http://localhost:8080/s2\n接下来，在后续的每次请求时，都会将Cookie的值，携带到服务端，那服务端呢，接收到Cookie之后，会自动的根据JSESSIONID的值，找到对应的会话对象Session。\n那经过这两步测试，大家也会看到，在控制台中输出如下日志：\n两次请求，获取到的Session会话对象的hashcode是一样的，就说明是同一个会话对象。而且，第一次请求时，往Session会话对象中存储的值，第二次请求时，也获取到了。 那这样，我们就可以通过Session会话对象，在同一个会话的多次请求之间来进行数据共享了。\n优缺点\n优点：Session是存储在服务端的，安全 缺点： 服务器集群环境下无法直接使用Session 移动端APP(Android、IOS)中无法使用Cookie 用户可以自己禁用Cookie Cookie不能跨域 PS：Session 底层是基于Cookie实现的会话跟踪，如果Cookie不可用，则该方案，也就失效了。\n服务器集群环境为何无法使用Session？\n​\t首先第一点，我们现在所开发的项目，一般都不会只部署在一台服务器上，因为一台服务器会存在一个很大的问题，就是单点故障。所谓单点故障，指的就是一旦这台服务器挂了，整个应用都没法访问了。 ​ 所以在现在的企业项目开发当中，最终部署的时候都是以集群的形式来进行部署，也就是同一个项目它会部署多份。比如这个项目我们现在就部署了 3 份。\n而用户在访问的时候，到底访问这三台其中的哪一台？其实用户在访问的时候，他会访问一台前置的服务器，我们叫负载均衡服务器，我们在后面项目当中会详细讲解。目前大家先有一个印象负载均衡服务器，它的作用就是将前端发起的请求均匀的分发给后面的这三台服务器。\n此时假如我们通过 session 来进行会话跟踪，可能就会存在这样一个问题。用户打开浏览器要进行登录操作，此时会发起登录请求。登录请求到达负载均衡服务器，将这个请求转给了第一台 Tomcat 服务器。\nTomcat 服务器接收到请求之后，要获取到会话对象session。获取到会话对象 session 之后，要给浏览器响应数据，最终在给浏览器响应数据的时候，就会携带这么一个 cookie 的名字，就是 JSESSIONID ，下一次再请求的时候，是不是又会将 Cookie 携带到服务端？\n好。此时假如又执行了一次查询操作，要查询部门的数据。这次请求到达负载均衡服务器之后，负载均衡服务器将这次请求转给了第二台 Tomcat 服务器，此时他就要到第二台 Tomcat 服务器当中。根据JSESSIONID 也就是对应的 session 的 ID 值，要找对应的 session 会话对象。\n我想请问在第二台服务器当中有没有这个ID的会话对象 Session， 是没有的。此时是不是就出现问题了？我同一个浏览器发起了 2 次请求，结果获取到的不是同一个会话对象，这就是Session这种会话跟踪方案它的缺点，在服务器集群环境下无法直接使用Session。\n大家会看到上面这两种传统的会话技术，在现在的企业开发当中是不是会存在很多的问题。 为了解决这些问题，在现在的企业开发当中，基本上都会采用第三种方案，通过令牌技术来进行会话跟踪。接下来我们就来介绍一下令牌技术，来看一下令牌技术又是如何跟踪会话的。\n2.2.2.3 方案三 - 令牌技术 这里我们所提到的令牌，其实它就是一个用户身份的标识，看似很高大上，很神秘，其实本质就是一个字符串。\n如果通过令牌技术来跟踪会话，我们就可以在浏览器发起请求。在请求登录接口的时候，如果登录成功，我就可以生成一个令牌，令牌就是用户的合法身份凭证。接下来我在响应数据的时候，我就可以直接将令牌响应给前端。\n接下来我们在前端程序当中接收到令牌之后，就需要将这个令牌存储起来。这个存储可以存储在 cookie 当中，也可以存储在其他的存储空间(比如：localStorage)当中。\n接下来，在后续的每一次请求当中，都需要将令牌携带到服务端。携带到服务端之后，接下来我们就需要来校验令牌的有效性。如果令牌是有效的，就说明用户已经执行了登录操作，如果令牌是无效的，就说明用户之前并未执行登录操作。\n此时，如果是在同一次会话的多次请求之间，我们想共享数据，我们就可以将共享的数据存储在令牌当中就可以了。\n优缺点\n优点： 支持PC端、移动端 解决集群环境下的认证问题 减轻服务器的存储压力（无需在服务器端存储） 缺点：需要自己实现（包括令牌的生成、令牌的传递、令牌的校验） 针对于这三种方案，现在企业开发当中使用的最多的就是第三种令牌技术进行会话跟踪。而前面的这两种传统的方案，现在企业项目开发当中已经很少使用了。所以在我们的课程当中，我们也将会采用令牌技术来解决案例项目当中的会话跟踪问题。\n2.3 JWT令牌 前面我们介绍了基于令牌技术来实现会话追踪。这里所提到的令牌就是用户身份的标识，其本质就是一个字符串。令牌的形式有很多，我们使用的是功能强大的 JWT令牌。\n2.3.1 介绍 JWT全称：JSON Web Token （官网：https://jwt.io/）\n定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。\n简洁：是指jwt就是一个简单的字符串。可以在请求参数或者是请求头当中直接传递。\n自包含：指的是jwt令牌，看似是一个随机的字符串，但是我们是可以根据自身的需求在jwt令牌中存储自定义的数据内容。如：可以直接在jwt令牌中存储用户的相关信息。\n简单来讲，jwt就是将原始的json数据格式进行了安全的封装，这样就可以直接基于jwt在通信双方安全的进行信息传输了。\nJWT的组成： （JWT令牌由三个部分组成，三个部分之间使用英文的点来分割）\n第一部分：Header(头）， 记录令牌类型、签名算法等。 例如：{\u0026ldquo;alg\u0026rdquo;:\u0026ldquo;HS256\u0026rdquo;,\u0026ldquo;type\u0026rdquo;:\u0026ldquo;JWT\u0026rdquo;}\n第二部分：Payload(有效载荷），携带一些自定义信息、默认信息等。 例如：{\u0026ldquo;id\u0026rdquo;:\u0026ldquo;1\u0026rdquo;,\u0026ldquo;username\u0026rdquo;:\u0026ldquo;Tom\u0026rdquo;}\n第三部分：Signature(签名），防止Token被篡改、确保安全性。将header、payload，并加入指定秘钥，通过指定签名算法计算而来。\n签名的目的就是为了防jwt令牌被篡改，而正是因为jwt令牌最后一个部分数字签名的存在，所以整个jwt 令牌是非常安全可靠的。一旦jwt令牌当中任何一个部分、任何一个字符被篡改了，整个令牌在校验的时候都会失败，所以它是非常安全可靠的。\nJWT是如何将原始的JSON格式数据，转变为字符串的呢？\n其实在生成JWT令牌时，会对JSON格式的数据进行一次编码：进行base64编码\nBase64：是一种基于64个可打印的字符来表示二进制数据的编码方式。既然能编码，那也就意味着也能解码。所使用的64个字符分别是A到Z、a到z、 0- 9，一个加号，一个斜杠，加起来就是64个字符。任何数据经过base64编码之后，最终就会通过这64个字符来表示。当然还有一个符号，那就是等号。等号它是一个补位的符号\n需要注意的是Base64是编码方式，而不是加密方式。\nJWT令牌最典型的应用场景就是登录认证：\n在浏览器发起请求来执行登录操作，此时会访问登录的接口，如果登录成功之后，我们需要生成一个jwt令牌，将生成的 jwt令牌返回给前端。 前端拿到jwt令牌之后，会将jwt令牌存储起来。在后续的每一次请求中都会将jwt令牌携带到服务端。 服务端统一拦截请求之后，先来判断一下这次请求有没有把令牌带过来，如果没有带过来，直接拒绝访问，如果带过来了，还要校验一下令牌是否是有效。如果有效，就直接放行进行请求的处理。 在JWT登录认证的场景中我们发现，整个流程当中涉及到两步操作：\n在登录成功之后，要生成令牌。 每一次请求当中，要接收令牌并对令牌进行校验。 稍后我们再来学习如何来生成jwt令牌，以及如何来校验jwt令牌。\n2.3.2 生成和校验 简单介绍了JWT令牌以及JWT令牌的组成之后，接下来我们就来学习基于Java代码如何生成和校验JWT令牌。\n首先我们先来实现JWT令牌的生成。要想使用JWT令牌，需要先引入JWT的依赖：\n1 2 3 4 5 6 \u0026lt;!-- JWT依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在引入完JWT来赖后，就可以调用工具包中提供的API来完成JWT令牌的生成和校验\n工具类：Jwts\n生成JWT代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Test public void genJwt(){ Map\u0026lt;String,Object\u0026gt; claims = new HashMap\u0026lt;\u0026gt;(); claims.put(\u0026#34;id\u0026#34;,1); claims.put(\u0026#34;username\u0026#34;,\u0026#34;Tom\u0026#34;); String jwt = Jwts.builder() .setClaims(claims) //自定义内容(载荷) .signWith(SignatureAlgorithm.HS256, \u0026#34;itheima\u0026#34;) //签名算法 .setExpiration(new Date(System.currentTimeMillis() + 24*3600*1000)) //有效期 .compact(); System.out.println(jwt); } 运行测试方法：\n1 eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNjcyNzI5NzMwfQ.fHi0Ub8npbyt71UqLXDdLyipptLgxBUg_mSuGJtXtBk 输出的结果就是生成的JWT令牌,，通过英文的点分割对三个部分进行分割，我们可以将生成的令牌复制一下，然后打开JWT的官网，将生成的令牌直接放在Encoded位置，此时就会自动的将令牌解析出来。\n第一部分解析出来，看到JSON格式的原始数据，所使用的签名算法为HS256。\n第二个部分是我们自定义的数据，之前我们自定义的数据就是id，还有一个exp代表的是我们所设置的过期时间。\n由于前两个部分是base64编码，所以是可以直接解码出来。但最后一个部分并不是base64编码，是经过签名算法计算出来的，所以最后一个部分是不会解析的。\n实现了JWT令牌的生成，下面我们接着使用Java代码来校验JWT令牌(解析生成的令牌)：\n1 2 3 4 5 6 7 8 9 @Test public void parseJwt(){ Claims claims = Jwts.parser() .setSigningKey(\u0026#34;itheima\u0026#34;)//指定签名密钥（必须保证和生成令牌时使用相同的签名密钥） .parseClaimsJws(\u0026#34;eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNjcyNzI5NzMwfQ.fHi0Ub8npbyt71UqLXDdLyipptLgxBUg_mSuGJtXtBk\u0026#34;) .getBody(); System.out.println(claims); } 运行测试方法：\n1 {id=1, exp=1672729730} 令牌解析后，我们可以看到id和过期时间，如果在解析的过程当中没有报错，就说明解析成功了。\n下面我们做一个测试：把令牌header中的数字9变为8，运行测试方法后发现报错：\n原header： eyJhbGciOiJIUzI1NiJ9\n修改为： eyJhbGciOiJIUzI1NiJ8\n结论：篡改令牌中的任何一个字符，在对令牌进行解析时都会报错，所以JWT令牌是非常安全可靠的。\n我们继续测试：修改生成令牌的时指定的过期时间，修改为1分钟\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Test public void genJwt(){ Map\u0026lt;String,Object\u0026gt; claims = new HashMap\u0026lt;\u0026gt;(); claims.put(“id”,1); claims.put(“username”,“Tom”); String jwt = Jwts.builder() .setClaims(claims) //自定义内容(载荷) .signWith(SignatureAlgorithm.HS256, “itheima”) //签名算法 .setExpiration(new Date(System.currentTimeMillis() + 60*1000)) //有效期60秒 .compact(); System.out.println(jwt); //输出结果：eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNjczMDA5NzU0fQ.RcVIR65AkGiax-ID6FjW60eLFH3tPTKdoK7UtE4A1ro } @Test public void parseJwt(){ Claims claims = Jwts.parser() .setSigningKey(\u0026#34;itheima\u0026#34;)//指定签名密钥 .parseClaimsJws(\u0026#34;eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNjczMDA5NzU0fQ.RcVIR65AkGiax-ID6FjW60eLFH3tPTKdoK7UtE4A1ro\u0026#34;) .getBody(); System.out.println(claims); } 等待1分钟之后运行测试方法发现也报错了，说明：JWT令牌过期后，令牌就失效了，解析的为非法令牌。\n通过以上测试，我们在使用JWT令牌时需要注意：\nJWT校验时使用的签名秘钥，必须和生成JWT令牌时使用的秘钥是配套的。\n如果JWT令牌解析校验时报错，则说明 JWT令牌被篡改 或 失效了，令牌非法。\n2.3.3 登录下发令牌 JWT令牌的生成和校验的基本操作我们已经学习完了，接下来我们就需要在案例当中通过JWT令牌技术来跟踪会话。具体的思路我们前面已经分析过了，主要就是两步操作：\n生成令牌 在登录成功之后来生成一个JWT令牌，并且把这个令牌直接返回给前端 校验令牌 拦截前端请求，从请求中获取到令牌，对令牌进行解析校验 那我们首先来完成：登录成功之后生成JWT令牌，并且把令牌返回给前端。\nJWT令牌怎么返回给前端呢？此时我们就需要再来看一下接口文档当中关于登录接口的描述（主要看响应数据）：\n响应数据\n参数格式：application/json\n参数说明：\n名称 类型 是否必须 默认值 备注 其他信息 code number 必须 响应码, 1 成功 ; 0 失败 msg string 非必须 提示信息 data string 必须 返回的数据 , jwt令牌 响应数据样例：\n1 2 3 4 5 { \u0026#34;code\u0026#34;: 1, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: \u0026#34;eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoi6YeR5bq4IiwiaWQiOjEsInVzZXJuYW1lIjoiamlueW9uZyIsImV4cCI6MTY2MjIwNzA0OH0.KkUc_CXJZJ8Dd063eImx4H9Ojfrr6XMJ-yVzaWCVZCo\u0026#34; } 备注说明\n用户登录成功后，系统会自动下发JWT令牌，然后在后续的每次请求中，都需要在请求头header中携带到服务端，请求头的名称为 token ，值为 登录时下发的JWT令牌。\n如果检测到用户未登录，则会返回如下固定错误信息：\n1 2 3 4 5 { \u0026#34;code\u0026#34;: 0, \u0026#34;msg\u0026#34;: \u0026#34;NOT_LOGIN\u0026#34;, \u0026#34;data\u0026#34;: null } 解读完接口文档中的描述了，目前我们先来完成令牌的生成和令牌的下发，我们只需要生成一个令牌返回给前端就可以了。\n实现步骤：\n引入JWT工具类 在项目工程下创建com.itheima.utils包，并把提供JWT工具类复制到该包下 登录完成后，调用工具类生成JWT令牌并返回 JWT工具类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class JwtUtils { private static String signKey = \u0026#34;itheima\u0026#34;;//签名密钥 private static Long expire = 43200000L; //有效时间 /** * 生成JWT令牌 * @param claims JWT第二部分负载 payload 中存储的内容 * @return */ public static String generateJwt(Map\u0026lt;String, Object\u0026gt; claims){ String jwt = Jwts.builder() .addClaims(claims)//自定义信息（有效载荷） .signWith(SignatureAlgorithm.HS256, signKey)//签名算法（头部） .setExpiration(new Date(System.currentTimeMillis() + expire))//过期时间 .compact(); return jwt; } /** * 解析JWT令牌 * @param jwt JWT令牌 * @return JWT第二部分负载 payload 中存储的内容 */ public static Claims parseJWT(String jwt){ Claims claims = Jwts.parser() .setSigningKey(signKey)//指定签名密钥 .parseClaimsJws(jwt)//指定令牌Token .getBody(); return claims; } } 登录成功，生成JWT令牌并返回\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @RestController @Slf4j public class LoginController { //依赖业务层对象 @Autowired private EmpService empService; @PostMapping(\u0026#34;/login\u0026#34;) public Result login(@RequestBody Emp emp) { //调用业务层：登录功能 Emp loginEmp = empService.login(emp); //判断：登录用户是否存在 if(loginEmp !=null ){ //自定义信息 Map\u0026lt;String , Object\u0026gt; claims = new HashMap\u0026lt;\u0026gt;(); claims.put(\u0026#34;id\u0026#34;, loginEmp.getId()); claims.put(\u0026#34;username\u0026#34;,loginEmp.getUsername()); claims.put(\u0026#34;name\u0026#34;,loginEmp.getName()); //使用JWT工具类，生成身份令牌 String token = JwtUtils.generateJwt(claims); return Result.success(token); } return Result.error(\u0026#34;用户名或密码错误\u0026#34;); } } 重启服务，打开postman测试登录接口：\n打开浏览器完成前后端联调操作：利用开发者工具，抓取一下网络请求\n登录请求完成后，可以看到JWT令牌已经响应给了前端，此时前端就会将JWT令牌存储在浏览器本地。\n服务器响应的JWT令牌存储在本地浏览器哪里了呢？\n在当前案例中，JWT令牌存储在浏览器的本地存储空间local storage中了。 local storage是浏览器的本地存储，在移动端也是支持的。 我们在发起一个查询部门数据的请求，此时我们可以看到在请求头中包含一个token(JWT令牌)，后续的每一次请求当中，都会将这个令牌携带到服务端。\n2.4 过滤器Filter 刚才通过浏览器的开发者工具，我们可以看到在后续的请求当中，都会在请求头中携带JWT令牌到服务端，而服务端需要统一拦截所有的请求，从而判断是否携带的有合法的JWT令牌。 那怎么样来统一拦截到所有的请求校验令牌的有效性呢？这里我们会学习两种解决方案：\nFilter过滤器 Interceptor拦截器 我们首先来学习过滤器Filter。\n2.4.1 快速入门 什么是Filter？\nFilter表示过滤器，是 JavaWeb三大组件(Servlet、Filter、Listener)之一。 过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能 使用了过滤器之后，要想访问web服务器上的资源，必须先经过滤器，过滤器处理完毕之后，才可以访问对应的资源。 过滤器一般完成一些通用的操作，比如：登录校验、统一编码处理、敏感字符处理等。 下面我们通过Filter快速入门程序掌握过滤器的基本使用操作：\n第1步，定义过滤器 ：1.定义一个类，实现 Filter 接口，并重写其所有方法。 第2步，配置过滤器：Filter类上加 @WebFilter 注解，配置拦截资源的路径。引导类上加 @ServletComponentScan 开启Servlet组件支持。 定义过滤器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //定义一个类，实现一个标准的Filter过滤器的接口 public class DemoFilter implements Filter { @Override //初始化方法, 只调用一次 public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\u0026#34;init 初始化方法执行了\u0026#34;); } @Override //拦截到请求之后调用, 调用多次 public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\u0026#34;Demo 拦截到了请求...放行前逻辑\u0026#34;); //放行 chain.doFilter(request,response); } @Override //销毁方法, 只调用一次 public void destroy() { System.out.println(\u0026#34;destroy 销毁方法执行了\u0026#34;); } } init方法：过滤器的初始化方法。在web服务器启动的时候会自动的创建Filter过滤器对象，在创建过滤器对象的时候会自动调用init初始化方法，这个方法只会被调用一次。\ndoFilter方法：这个方法是在每一次拦截到请求之后都会被调用，所以这个方法是会被调用多次的，每拦截到一次请求就会调用一次doFilter()方法。\ndestroy方法： 是销毁的方法。当我们关闭服务器的时候，它会自动的调用销毁方法destroy，而这个销毁方法也只会被调用一次。\n在定义完Filter之后，Filter其实并不会生效，还需要完成Filter的配置，Filter的配置非常简单，只需要在Filter类上添加一个注解：@WebFilter，并指定属性urlPatterns，通过这个属性指定过滤器要拦截哪些请求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) //配置过滤器要拦截的请求路径（ /* 表示拦截浏览器的所有请求 ） public class DemoFilter implements Filter { @Override //初始化方法, 只调用一次 public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\u0026#34;init 初始化方法执行了\u0026#34;); } @Override //拦截到请求之后调用, 调用多次 public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\u0026#34;Demo 拦截到了请求...放行前逻辑\u0026#34;); //放行 chain.doFilter(request,response); } @Override //销毁方法, 只调用一次 public void destroy() { System.out.println(\u0026#34;destroy 销毁方法执行了\u0026#34;); } } 当我们在Filter类上面加了@WebFilter注解之后，接下来我们还需要在启动类上面加上一个注解@ServletComponentScan，通过这个@ServletComponentScan注解来开启SpringBoot项目对于Servlet组件的支持。\n1 2 3 4 5 6 7 8 9 @ServletComponentScan @SpringBootApplication public class TliasWebManagementApplication { public static void main(String[] args) { SpringApplication.run(TliasWebManagementApplication.class, args); } } 重新启动服务，打开浏览器，执行部门管理的请求，可以看到控制台输出了过滤器中的内容：\n注意事项：\n​\t在过滤器Filter中，如果不执行放行操作，将无法访问后面的资源。 放行操作：chain.doFilter(request, response);\n现在我们已完成了Filter过滤器的基本使用，下面我们将学习Filter过滤器在使用过程中的一些细节。\n2.4.2 Filter详解 Filter过滤器的快速入门程序我们已经完成了，接下来我们就要详细的介绍一下过滤器Filter在使用中的一些细节。主要介绍以下3个方面的细节：\n过滤器的执行流程 过滤器的拦截路径配置 过滤器链 2.4.2.1 执行流程 首先我们先来看下过滤器的执行流程：\n过滤器当中我们拦截到了请求之后，如果希望继续访问后面的web资源，就要执行放行操作，放行就是调用 FilterChain对象当中的doFilter()方法，在调用doFilter()这个方法之前所编写的代码属于放行之前的逻辑。\n在放行后访问完 web 资源之后还会回到过滤器当中，回到过滤器之后如有需求还可以执行放行之后的逻辑，放行之后的逻辑我们写在doFilter()这行代码之后。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) public class DemoFilter implements Filter { @Override //初始化方法, 只调用一次 public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\u0026#34;init 初始化方法执行了\u0026#34;); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\u0026#34;DemoFilter 放行前逻辑.....\u0026#34;); //放行请求 filterChain.doFilter(servletRequest,servletResponse); System.out.println(\u0026#34;DemoFilter 放行后逻辑.....\u0026#34;); } @Override //销毁方法, 只调用一次 public void destroy() { System.out.println(\u0026#34;destroy 销毁方法执行了\u0026#34;); } } 2.4.2.2 拦截路径 执行流程我们搞清楚之后，接下来再来介绍一下过滤器的拦截路径，Filter可以根据需求，配置不同的拦截资源路径：\n拦截路径 urlPatterns值 含义 拦截具体路径 /login 只有访问 /login 路径时，才会被拦截 目录拦截 /emps/* 访问/emps下的所有资源，都会被拦截 拦截所有 /* 访问所有资源，都会被拦截 下面我们来测试\u0026quot;拦截具体路径\u0026quot;：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @WebFilter(urlPatterns = \u0026#34;/login\u0026#34;) //拦截/login具体路径 public class DemoFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\u0026#34;DemoFilter 放行前逻辑.....\u0026#34;); //放行请求 filterChain.doFilter(servletRequest,servletResponse); System.out.println(\u0026#34;DemoFilter 放行后逻辑.....\u0026#34;); } @Override public void init(FilterConfig filterConfig) throws ServletException { Filter.super.init(filterConfig); } @Override public void destroy() { Filter.super.destroy(); } } 测试1：访问部门管理请求，发现过滤器没有拦截请求\n测试2：访问登录请求/login，发现过滤器拦截请求\n下面我们来测试\u0026quot;目录拦截\u0026quot;：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @WebFilter(urlPatterns = \u0026#34;/depts/*\u0026#34;) //拦截所有以/depts开头，后面是什么无所谓 public class DemoFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\u0026#34;DemoFilter 放行前逻辑.....\u0026#34;); //放行请求 filterChain.doFilter(servletRequest,servletResponse); System.out.println(\u0026#34;DemoFilter 放行后逻辑.....\u0026#34;); } @Override public void init(FilterConfig filterConfig) throws ServletException { Filter.super.init(filterConfig); } @Override public void destroy() { Filter.super.destroy(); } } 测试1：访问部门管理请求，发现过滤器拦截了请求\n测试2：访问登录请求/login，发现过滤器没有拦截请求\n2.4.2.3 过滤器链 最后我们在来介绍下过滤器链，什么是过滤器链呢？所谓过滤器链指的是在一个web应用程序当中，可以配置多个过滤器，多个过滤器就形成了一个过滤器链。\n比如：在我们web服务器当中，定义了两个过滤器，这两个过滤器就形成了一个过滤器链。\n而这个链上的过滤器在执行的时候会一个一个的执行，会先执行第一个Filter，放行之后再来执行第二个Filter，如果执行到了最后一个过滤器放行之后，才会访问对应的web资源。\n访问完web资源之后，按照我们刚才所介绍的过滤器的执行流程，还会回到过滤器当中来执行过滤器放行后的逻辑，而在执行放行后的逻辑的时候，顺序是反着的。\n先要执行过滤器2放行之后的逻辑，再来执行过滤器1放行之后的逻辑，最后在给浏览器响应数据。\n以上就是当我们在web应用当中配置了多个过滤器，形成了这样一个过滤器链以及过滤器链的执行顺序。下面我们通过idea来验证下过滤器链。\n验证步骤：\n在filter包下再来新建一个Filter过滤器类：AbcFilter 在AbcFilter过滤器中编写放行前和放行后逻辑 配置AbcFilter过滤器拦截请求路径为：/* 重启SpringBoot服务，查看DemoFilter、AbcFilter的执行日志 AbcFilter过滤器\n1 2 3 4 5 6 7 8 9 10 11 12 @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) public class AbcFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\u0026#34;Abc 拦截到了请求... 放行前逻辑\u0026#34;); //放行 chain.doFilter(request,response); System.out.println(\u0026#34;Abc 拦截到了请求... 放行后逻辑\u0026#34;); } } DemoFilter过滤器\n1 2 3 4 5 6 7 8 9 10 11 12 @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) public class DemoFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\u0026#34;DemoFilter 放行前逻辑.....\u0026#34;); //放行请求 filterChain.doFilter(servletRequest,servletResponse); System.out.println(\u0026#34;DemoFilter 放行后逻辑.....\u0026#34;); } } 打开浏览器访问登录接口：\n通过控制台日志的输出，大家发现AbcFilter先执行DemoFilter后执行，这是为什么呢？\n其实是和过滤器的类名有关系。以注解方式配置的Filter过滤器，它的执行优先级是按时过滤器类名的自动排序确定的，类名排名越靠前，优先级越高。\n假如我们想让DemoFilter先执行，怎么办呢？答案就是修改类名。\n测试：修改AbcFilter类名为XbcFilter，运行程序查看控制台日志\n1 2 3 4 5 6 7 8 9 10 11 12 @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) public class XbcFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\u0026#34;Xbc 拦截到了请求...放行前逻辑\u0026#34;); //放行 chain.doFilter(request,response); System.out.println(\u0026#34;Xbc 拦截到了请求...放行后逻辑\u0026#34;); } } 到此，关于过滤器的使用细节，我们已经全部介绍完毕了。\n2.4.3 登录校验-Filter 2.4.3.1 分析 过滤器Filter的快速入门以及使用细节我们已经介绍完了，接下来最后一步，我们需要使用过滤器Filter来完成案例当中的登录校验功能。\n我们先来回顾下前面分析过的登录校验的基本流程：\n要进入到后台管理系统，我们必须先完成登录操作，此时就需要访问登录接口login。\n登录成功之后，我们会在服务端生成一个JWT令牌，并且把JWT令牌返回给前端，前端会将JWT令牌存储下来。\n在后续的每一次请求当中，都会将JWT令牌携带到服务端，请求到达服务端之后，要想去访问对应的业务功能，此时我们必须先要校验令牌的有效性。\n对于校验令牌的这一块操作，我们使用登录校验的过滤器，在过滤器当中来校验令牌的有效性。如果令牌是无效的，就响应一个错误的信息，也不会再去放行访问对应的资源了。如果令牌存在，并且它是有效的，此时就会放行去访问对应的web资源，执行相应的业务操作。\n大概清楚了在Filter过滤器的实现步骤了，那在正式开发登录校验过滤器之前，我们思考两个问题：\n所有的请求，拦截到了之后，都需要校验令牌吗？\n答案：登录请求例外 拦截到请求后，什么情况下才可以放行，执行业务操作？\n答案：有令牌，且令牌校验通过(合法)；否则都返回未登录错误结果 2.4.3.2 具体流程 我们要完成登录校验，主要是利用Filter过滤器实现，而Filter过滤器的流程步骤：\n基于上面的业务流程，我们分析出具体的操作步骤：\n获取请求url 判断请求url中是否包含login，如果包含，说明是登录操作，放行 获取请求头中的令牌（token） 判断令牌是否存在，如果不存在，返回错误结果（未登录） 解析token，如果解析失败，返回错误结果（未登录） 放行 2.4.3.3 代码实现 分析清楚了以上的问题后，我们就参照接口文档来开发登录功能了，登录接口描述如下：\n基本信息\n1 2 3 4 5 请求路径：/login 请求方式：POST 接口描述：该接口用于员工登录Tlias智能学习辅助系统，登录完毕后，系统下发JWT令牌。 请求参数\n参数格式：application/json\n参数说明：\n名称 类型 是否必须 备注 username string 必须 用户名 password string 必须 密码 请求数据样例：\n1 2 3 4 { \u0026#34;username\u0026#34;: \u0026#34;jinyong\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;123456\u0026#34; } 响应数据\n参数格式：application/json\n参数说明：\n名称 类型 是否必须 默认值 备注 其他信息 code number 必须 响应码, 1 成功 ; 0 失败 msg string 非必须 提示信息 data string 必须 返回的数据 , jwt令牌 响应数据样例：\n1 2 3 4 5 { \u0026#34;code\u0026#34;: 1, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: \u0026#34;eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoi6YeR5bq4IiwiaWQiOjEsInVzZXJuYW1lIjoiamlueW9uZyIsImV4cCI6MTY2MjIwNzA0OH0.KkUc_CXJZJ8Dd063eImx4H9Ojfrr6XMJ-yVzaWCVZCo\u0026#34; } 备注说明\n用户登录成功后，系统会自动下发JWT令牌，然后在后续的每次请求中，都需要在请求头header中携带到服务端，请求头的名称为 token ，值为 登录时下发的JWT令牌。\n如果检测到用户未登录，则会返回如下固定错误信息：\n1 2 3 4 5 { \u0026#34;code\u0026#34;: 0, \u0026#34;msg\u0026#34;: \u0026#34;NOT_LOGIN\u0026#34;, \u0026#34;data\u0026#34;: null } 登录校验过滤器：LoginCheckFilter\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @Slf4j @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) //拦截所有请求 public class LoginCheckFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain) throws IOException, ServletException { //前置：强制转换为http协议的请求对象、响应对象 （转换原因：要使用子类中特有方法） HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; //1.获取请求url String url = request.getRequestURL().toString(); log.info(\u0026#34;请求路径：{}\u0026#34;, url); //请求路径：http://localhost:8080/login //2.判断请求url中是否包含login，如果包含，说明是登录操作，放行 if(url.contains(\u0026#34;/login\u0026#34;)){ chain.doFilter(request, response);//放行请求 return;//结束当前方法的执行 } //3.获取请求头中的令牌（token） String token = request.getHeader(\u0026#34;token\u0026#34;); log.info(\u0026#34;从请求头中获取的令牌：{}\u0026#34;,token); //4.判断令牌是否存在，如果不存在，返回错误结果（未登录） if(!StringUtils.hasLength(token)){ log.info(\u0026#34;Token不存在\u0026#34;); Result responseResult = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); //把Result对象转换为JSON格式字符串 (fastjson是阿里巴巴提供的用于实现对象和json的转换工具类) String json = JSONObject.toJSONString(responseResult); response.setContentType(\u0026#34;application/json;charset=utf-8\u0026#34;); //响应 response.getWriter().write(json); return; } //5.解析token，如果解析失败，返回错误结果（未登录） try { JwtUtils.parseJWT(token); }catch (Exception e){ log.info(\u0026#34;令牌解析失败!\u0026#34;); Result responseResult = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); //把Result对象转换为JSON格式字符串 (fastjson是阿里巴巴提供的用于实现对象和json的转换工具类) String json = JSONObject.toJSONString(responseResult); response.setContentType(\u0026#34;application/json;charset=utf-8\u0026#34;); //响应 response.getWriter().write(json); return; } //6.放行 chain.doFilter(request, response); } } 在上述过滤器的功能实现中，我们使用到了一个第三方json处理的工具包fastjson。我们要想使用，需要引入如下依赖：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.76\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 登录校验的过滤器我们编写完成了，接下来我们就可以重新启动服务来做一个测试：\n测试前先把之前所编写的测试使用的过滤器，暂时注释掉。直接将@WebFilter注解给注释掉即可。\n测试1：未登录是否可以访问部门管理页面\n首先关闭浏览器，重新打开浏览器，在地址栏中输入：http://localhost:9528/#/system/dept\n由于用户没有登录，登录校验过滤器返回错误信息，前端页面根据返回的错误信息结果，自动跳转到登录页面了\n测试2：先进行登录操作，再访问部门管理页面\n登录校验成功之后，可以正常访问相关业务操作页面\n2.5 拦截器Interceptor 学习完了过滤器Filter之后，接下来我们继续学习拦截器Interseptor。\n拦截器我们主要分为三个方面进行讲解：\n介绍下什么是拦截器，并通过快速入门程序上手拦截器 拦截器的使用细节 通过拦截器Interceptor完成登录校验功能 我们先学习第一块内容：拦截器快速入门\n2.5.1 快速入门 什么是拦截器？\n是一种动态拦截方法调用的机制，类似于过滤器。 拦截器是Spring框架中提供的，用来动态拦截控制器方法的执行。 拦截器的作用：\n拦截请求，在指定方法调用前后，根据业务需要执行预先设定的代码。 在拦截器当中，我们通常也是做一些通用性的操作，比如：我们可以通过拦截器来拦截前端发起的请求，将登录校验的逻辑全部编写在拦截器当中。在校验的过程当中，如发现用户登录了(携带JWT令牌且是合法令牌)，就可以直接放行，去访问spring当中的资源。如果校验时发现并没有登录或是非法令牌，就可以直接给前端响应未登录的错误信息。\n下面我们通过快速入门程序，来学习下拦截器的基本使用。拦截器的使用步骤和过滤器类似，也分为两步：\n定义拦截器\n注册配置拦截器\n**自定义拦截器：**实现HandlerInterceptor接口，并重写其所有方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //自定义拦截器 @Component public class LoginCheckInterceptor implements HandlerInterceptor { //目标资源方法执行前执行。 返回true：放行 返回false：不放行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\u0026#34;preHandle .... \u0026#34;); return true; //true表示放行 } //目标资源方法执行后执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;postHandle ... \u0026#34;); } //视图渲染完毕后执行，最后执行 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026#34;afterCompletion .... \u0026#34;); } } 注意：\n​\tpreHandle方法：目标资源方法执行前执行。 返回true：放行 返回false：不放行\n​\tpostHandle方法：目标资源方法执行后执行\n​\tafterCompletion方法：视图渲染完毕后执行，最后执行\n注册配置拦截器：实现WebMvcConfigurer接口，并重写addInterceptors方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration public class WebConfig implements WebMvcConfigurer { //自定义的拦截器对象 @Autowired private LoginCheckInterceptor loginCheckInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { //注册自定义拦截器对象 registry.addInterceptor(loginCheckInterceptor).addPathPatterns(\u0026#34;/**\u0026#34;);//设置拦截器拦截的请求路径（ /** 表示拦截所有请求） } } 重新启动SpringBoot服务，打开postman测试：\n接下来我们再来做一个测试：将拦截器中返回值改为false\n使用postman，再次点击send发送请求后，没有响应数据，说明请求被拦截了没有放行\n2.5.2 Interceptor详解 拦截器的入门程序完成之后，接下来我们来介绍拦截器的使用细节。拦截器的使用细节我们主要介绍两个部分：\n拦截器的拦截路径配置 拦截器的执行流程 2.5.2.1 拦截路径 首先我们先来看拦截器的拦截路径的配置，在注册配置拦截器的时候，我们要指定拦截器的拦截路径，通过addPathPatterns(\u0026quot;要拦截路径\u0026quot;)方法，就可以指定要拦截哪些资源。\n在入门程序中我们配置的是/**，表示拦截所有资源，而在配置拦截器时，不仅可以指定要拦截哪些资源，还可以指定不拦截哪些资源，只需要调用excludePathPatterns(\u0026quot;不拦截路径\u0026quot;)方法，指定哪些资源不需要拦截。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Configuration public class WebConfig implements WebMvcConfigurer { //拦截器对象 @Autowired private LoginCheckInterceptor loginCheckInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { //注册自定义拦截器对象 registry.addInterceptor(loginCheckInterceptor) .addPathPatterns(\u0026#34;/**\u0026#34;)//设置拦截器拦截的请求路径（ /** 表示拦截所有请求） .excludePathPatterns(\u0026#34;/login\u0026#34;);//设置不拦截的请求路径 } } 在拦截器中除了可以设置/**拦截所有资源外，还有一些常见拦截路径设置：\n拦截路径 含义 举例 /* 一级路径 能匹配/depts，/emps，/login，不能匹配 /depts/1 /** 任意级路径 能匹配/depts，/depts/1，/depts/1/2 /depts/* /depts下的一级路径 能匹配/depts/1，不能匹配/depts/1/2，/depts /depts/** /depts下的任意级路径 能匹配/depts，/depts/1，/depts/1/2，不能匹配/emps/1 下面主要来演示下/**与/*的区别：\n修改拦截器配置，把拦截路径设置为/* 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Configuration public class WebConfig implements WebMvcConfigurer { //拦截器对象 @Autowired private LoginCheckInterceptor loginCheckInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { //注册自定义拦截器对象 registry.addInterceptor(loginCheckInterceptor) .addPathPatterns(\u0026#34;/*\u0026#34;) .excludePathPatterns(\u0026#34;/login\u0026#34;);//设置不拦截的请求路径 } } 使用postman测试：http://localhost:8080/emps/1\n控制台没有输出拦截器中的日志信息，说明/*没有匹配到拦截路径/emp/1 。\n2.5.2.2 执行流程 介绍完拦截路径的配置之后，接下来我们再来介绍拦截器的执行流程。通过执行流程，大家就能够清晰的知道过滤器与拦截器的执行时机。\n当我们打开浏览器来访问部署在web服务器当中的web应用时，此时我们所定义的过滤器会拦截到这次请求。拦截到这次请求之后，它会先执行放行前的逻辑，然后再执行放行操作。而由于我们当前是基于springboot开发的，所以放行之后是进入到了spring的环境当中，也就是要来访问我们所定义的controller当中的接口方法。\nTomcat并不识别所编写的Controller程序，但是它识别Servlet程序，所以在Spring的Web环境中提供了一个非常核心的Servlet：DispatcherServlet（前端控制器），所有请求都会先进行到DispatcherServlet，再将请求转给Controller。\n当我们定义了拦截器后，会在执行Controller的方法之前，请求被拦截器拦截住。执行preHandle()方法，这个方法执行完成后需要返回一个布尔类型的值，如果返回true，就表示放行本次操作，才会继续访问controller中的方法；如果返回false，则不会放行（controller中的方法也不会执行）。\n在controller当中的方法执行完毕之后，再回过来执行postHandle()这个方法以及afterCompletion() 方法，然后再返回给DispatcherServlet，最终再来执行过滤器当中放行后的这一部分逻辑的逻辑。执行完毕之后，最终给浏览器响应数据。\n接下来我们就来演示下过滤器和拦截器同时存在的执行流程：\n开启LoginCheckInterceptor拦截器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Component public class LoginCheckInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\u0026#34;preHandle .... \u0026#34;); return true; //true表示放行 } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;postHandle ... \u0026#34;); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026#34;afterCompletion .... \u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Configuration public class WebConfig implements WebMvcConfigurer { //拦截器对象 @Autowired private LoginCheckInterceptor loginCheckInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { //注册自定义拦截器对象 registry.addInterceptor(loginCheckInterceptor) .addPathPatterns(\u0026#34;/**\u0026#34;)//拦截所有请求 .excludePathPatterns(\u0026#34;/login\u0026#34;);//不拦截登录请求 } } 开启DemoFilter过滤器 1 2 3 4 5 6 7 8 9 10 11 12 @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) public class DemoFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\u0026#34;DemoFilter 放行前逻辑.....\u0026#34;); //放行请求 filterChain.doFilter(servletRequest,servletResponse); System.out.println(\u0026#34;DemoFilter 放行后逻辑.....\u0026#34;); } } 重启SpringBoot服务后，清空日志，打开Postman，测试查询部门：\n以上就是拦截器的执行流程。通过执行流程分析，大家应该已经清楚了过滤器和拦截器之间的区别，其实它们之间的区别主要是两点：\n接口规范不同：过滤器需要实现Filter接口，而拦截器需要实现HandlerInterceptor接口。 拦截范围不同：过滤器Filter会拦截所有的资源，而Interceptor只会拦截Spring环境中的资源。 2.5.3 登录校验- Interceptor 讲解完了拦截器的基本操作之后，接下来我们需要完成最后一步操作：通过拦截器来完成案例当中的登录校验功能。\n登录校验的业务逻辑以及操作步骤我们前面已经分析过了，和登录校验Filter过滤器当中的逻辑是完全一致的。现在我们只需要把这个技术方案由原来的过滤器换成拦截器interceptor就可以了。\n登录校验拦截器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 //自定义拦截器 @Component //当前拦截器对象由Spring创建和管理 @Slf4j public class LoginCheckInterceptor implements HandlerInterceptor { //前置方式 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\u0026#34;preHandle .... \u0026#34;); //1.获取请求url //2.判断请求url中是否包含login，如果包含，说明是登录操作，放行 //3.获取请求头中的令牌（token） String token = request.getHeader(\u0026#34;token\u0026#34;); log.info(\u0026#34;从请求头中获取的令牌：{}\u0026#34;,token); //4.判断令牌是否存在，如果不存在，返回错误结果（未登录） if(!StringUtils.hasLength(token)){ log.info(\u0026#34;Token不存在\u0026#34;); //创建响应结果对象 Result responseResult = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); //把Result对象转换为JSON格式字符串 (fastjson是阿里巴巴提供的用于实现对象和json的转换工具类) String json = JSONObject.toJSONString(responseResult); //设置响应头（告知浏览器：响应的数据类型为json、响应的数据编码表为utf-8） response.setContentType(\u0026#34;application/json;charset=utf-8\u0026#34;); //响应 response.getWriter().write(json); return false;//不放行 } //5.解析token，如果解析失败，返回错误结果（未登录） try { JwtUtils.parseJWT(token); }catch (Exception e){ log.info(\u0026#34;令牌解析失败!\u0026#34;); //创建响应结果对象 Result responseResult = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); //把Result对象转换为JSON格式字符串 (fastjson是阿里巴巴提供的用于实现对象和json的转换工具类) String json = JSONObject.toJSONString(responseResult); //设置响应头 response.setContentType(\u0026#34;application/json;charset=utf-8\u0026#34;); //响应 response.getWriter().write(json); return false; } //6.放行 return true; } 注册配置拦截器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration public class WebConfig implements WebMvcConfigurer { //拦截器对象 @Autowired private LoginCheckInterceptor loginCheckInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { //注册自定义拦截器对象 registry.addInterceptor(loginCheckInterceptor) .addPathPatterns(\u0026#34;/**\u0026#34;) .excludePathPatterns(\u0026#34;/login\u0026#34;); } } 登录校验的拦截器编写完成后，接下来我们就可以重新启动服务来做一个测试： （关闭登录校验Filter过滤器）\n测试1：未登录是否可以访问部门管理页面\n首先关闭浏览器，重新打开浏览器，在地址栏中输入：http://localhost:9528/#/system/dept\n由于用户没有登录，校验机制返回错误信息，前端页面根据返回的错误信息结果，自动跳转到登录页面了\n测试2：先进行登录操作，再访问部门管理页面\n登录校验成功之后，可以正常访问相关业务操作页面\n到此我们也就验证了所开发的登录校验的拦截器也是没问题的。登录校验的过滤器和拦截器，我们只需要使用其中的一种就可以了。\n3. 异常处理 3.1 当前问题 登录功能和登录校验功能我们都实现了，下面我们学习下今天最后一块技术点：异常处理。首先我们先来看一下系统出现异常之后会发生什么现象，再来介绍异常处理的方案。\n我们打开浏览器，访问系统中的新增部门操作，系统中已经有了 \u0026ldquo;就业部\u0026rdquo; 这个部门，我们再来增加一个就业部，看看会发生什么现象。\n点击确定之后，窗口关闭了，页面没有任何反应，就业部也没有添加上。 而此时，大家会发现，网络请求报错了。\n状态码为500，表示服务器端异常，我们打开idea，来看一下，服务器端出了什么问题。\n上述错误信息的含义是，dept部门表的name字段的值 就业部 重复了，因为在数据库表dept中已经有了就业部，我们之前设计这张表时，为name字段建议了唯一约束，所以该字段的值是不能重复的。\n而当我们再添加就业部，这个部门时，就违反了唯一约束，此时就会报错。\n我们来看一下出现异常之后，最终服务端给前端响应回来的数据长什么样。\n响应回来的数据是一个JSON格式的数据。但这种JSON格式的数据还是我们开发规范当中所提到的统一响应结果Result吗？显然并不是。由于返回的数据不符合开发规范，所以前端并不能解析出响应的JSON数据。\n接下来我们需要思考的是出现异常之后，当前案例项目的异常是怎么处理的？\n答案：没有做任何的异常处理 当我们没有做任何的异常处理时，我们三层架构处理异常的方案：\nMapper接口在操作数据库的时候出错了，此时异常会往上抛(谁调用Mapper就抛给谁)，会抛给service。 service 中也存在异常了，会抛给controller。 而在controller当中，我们也没有做任何的异常处理，所以最终异常会再往上抛。最终抛给框架之后，框架就会返回一个JSON格式的数据，里面封装的就是错误的信息，但是框架返回的JSON格式的数据并不符合我们的开发规范。 3.2 解决方案 那么在三层构架项目中，出现了异常，该如何处理?\n方案一：在所有Controller的所有方法中进行try…catch处理 缺点：代码臃肿（不推荐） 方案二：全局异常处理器 好处：简单、优雅（推荐） 3.3 全局异常处理器 我们该怎么样定义全局异常处理器？\n定义全局异常处理器非常简单，就是定义一个类，在类上加上一个注解@RestControllerAdvice，加上这个注解就代表我们定义了一个全局异常处理器。 在全局异常处理器当中，需要定义一个方法来捕获异常，在这个方法上需要加上注解@ExceptionHandler。通过@ExceptionHandler注解当中的value属性来指定我们要捕获的是哪一类型的异常。 1 2 3 4 5 6 7 8 9 10 11 12 @RestControllerAdvice public class GlobalExceptionHandler { //处理异常 @ExceptionHandler(Exception.class) //指定能够处理的异常类型 public Result ex(Exception e){ e.printStackTrace();//打印堆栈中的异常信息 //捕获到异常之后，响应一个标准的Result return Result.error(\u0026#34;对不起,操作失败,请联系管理员\u0026#34;); } } @RestControllerAdvice = @ControllerAdvice + @ResponseBody\n处理异常的方法返回值会转换为json后再响应给前端\n重新启动SpringBoot服务，打开浏览器，再来测试一下添加部门这个操作，我们依然添加已存在的 \u0026ldquo;就业部\u0026rdquo; 这个部门：\n此时，我们可以看到，出现异常之后，异常已经被全局异常处理器捕获了。然后返回的错误信息，被前端程序正常解析，然后提示出了对应的错误提示信息。\n以上就是全局异常处理器的使用，主要涉及到两个注解：\n@RestControllerAdvice //表示当前类为全局异常处理器 @ExceptionHandler //指定可以捕获哪种类型的异常进行处理 ","date":"2024-07-05T22:27:20+08:00","image":"https://picsum.photos/800/600 ","permalink":"https://4evergreat.github.io/2024/springboot-blog-4/","title":"springboot-blog-4 登陆认账篇"},{"content":"SpringBootWeb请求响应 前言 在上一次的课程中，我们开发了springbootweb的入门程序。 基于SpringBoot的方式开发一个web应用，浏览器发起请求 /hello 后 ，给浏览器返回字符串 “Hello World ~”。\n其实呢，是我们在浏览器发起请求，请求了我们的后端web服务器(也就是内置的Tomcat)。而我们在开发web程序时呢，定义了一个控制器类Controller，请求会被部署在Tomcat中的Controller接收，然后Controller再给浏览器一个响应，响应一个字符串 “Hello World”。 而在请求响应的过程中是遵循HTTP协议的。\n但是呢，这里要告诉大家的时，其实在Tomcat这类Web服务器中，是不识别我们自己定义的Controller的。但是我们前面讲到过Tomcat是一个Servlet容器，是支持Serlvet规范的，所以呢，在tomcat中是可以识别 Servlet程序的。 那我们所编写的XxxController 是如何处理请求的，又与Servlet之间有什么联系呢？\n其实呢，在SpringBoot进行web程序开发时，它内置了一个核心的Servlet程序 DispatcherServlet，称之为 核心控制器。 DispatcherServlet 负责接收页面发送的请求，然后根据执行的规则，将请求再转发给后面的请求处理器Controller，请求处理器处理完请求之后，最终再由DispatcherServlet给浏览器响应数据。\n那将来浏览器发送请求，会携带请求数据，包括：请求行、请求头；请求到达tomcat之后，tomcat会负责解析这些请求数据，然后呢将解析后的请求数据会传递给Servlet程序的HttpServletRequest对象，那也就意味着 HttpServletRequest 对象就可以获取到请求数据。 而Tomcat，还给Servlet程序传递了一个参数 HttpServletResponse，通过这个对象，我们就可以给浏览器设置响应数据 。\n那上述所描述的这种浏览器/服务器的架构模式呢，我们称之为：BS架构。\n• BS架构：Browser/Server，浏览器/服务器架构模式。客户端只需要浏览器，应用程序的逻辑和数据都存储在服务端。\n那今天呢，我们的课程内容主要就围绕着：请求、响应进行。 今天课程内容，主要包含三个部分：\n请求 响应 分层解耦 1. 请求 在本章节呢，我们主要讲解，如何接收页面传递过来的请求数据。\n1.1 Postman 之前我们课程中有提到当前最为主流的开发模式：前后端分离\n在这种模式下，前端技术人员基于\u0026quot;接口文档\u0026quot;，开发前端程序；后端技术人员也基于\u0026quot;接口文档\u0026quot;，开发后端程序。\n由于前后端分离，对我们后端技术人员来讲，在开发过程中，是没有前端页面的，那我们怎么测试自己所开发的程序呢？\n方式1：像之前SpringBoot入门案例中一样，直接使用浏览器。在浏览器中输入地址，测试后端程序。\n弊端：在浏览器地址栏中输入地址这种方式都是GET请求，如何我们要用到POST请求怎么办呢？ 要解决POST请求，需要程序员自己编写前端代码（比较麻烦） 方式2：使用专业的接口测试工具（课程中我们使用Postman工具）\n1.1.1 介绍 Postman是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件。\nPostman原是Chrome浏览器的插件，可以模拟浏览器向后端服务器发起任何形式(如:get、post)的HTTP请求\n使用Postman还可以在发起请求时，携带一些请求参数、请求头等信息\n作用：常用于进行接口测试\n特征\n简单 实用 美观 大方 1.1.2 安装 双击资料中提供的Postman-win64-8.3.1-Setup.exe即可自动安装。\n安装完成之后，进入页面中会提示有新版本可以升级（无需升级）\n界面介绍:\n如果我们需要将测试的请求信息保存下来，就需要创建一个postman的账号，然后登录之后才可以。\n登录完成之后，可以创建工作空间：\n创建请求：\n点击\u0026quot;Save\u0026quot;，保存当前请求\n1.2 简单参数 简单参数：在向服务器发起请求时，向服务器传递的是一些普通的请求数据。\n那么在后端程序中，如何接收传递过来的普通参数数据呢？\n我们在这里讲解两种方式：\n原始方式 SpringBoot方式 1.2.1 原始方式 在原始的Web程序当中，需要通过Servlet中提供的API：HttpServletRequest（请求对象），获取请求的相关信息。比如获取请求参数：\nTomcat接收到http请求时：把请求的相关信息封装到HttpServletRequest对象中\n在Controller中，我们要想获取Request对象，可以直接在方法的形参中声明 HttpServletRequest 对象。然后就可以通过该对象来获取请求信息：\n1 2 //根据指定的参数名获取请求参数的数据值 String request.getParameter(\u0026#34;参数名\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @RestController public class RequestController { //原始方式 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String simpleParam(HttpServletRequest request){ // http://localhost:8080/simpleParam?name=Tom\u0026amp;age=10 // 请求参数： name=Tom\u0026amp;age=10 （有2个请求参数） // 第1个请求参数： name=Tom 参数名:name，参数值:Tom // 第2个请求参数： age=10 参数名:age , 参数值:10 String name = request.getParameter(\u0026#34;name\u0026#34;);//name就是请求参数名 String ageStr = request.getParameter(\u0026#34;age\u0026#34;);//age就是请求参数名 int age = Integer.parseInt(ageStr);//需要手动进行类型转换 System.out.println(name+\u0026#34; : \u0026#34;+age); return \u0026#34;OK\u0026#34;; } } 以上这种方式，我们仅做了解。（在以后的开发中不会使用到）\n1.2.2 SpringBoot方式 在Springboot的环境中，对原始的API进行了封装，接收参数的形式更加简单。 如果是简单参数，参数名与形参变量名相同，定义同名的形参即可接收参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 @RestController public class RequestController { // http://localhost:8080/simpleParam?name=Tom\u0026amp;age=10 // 第1个请求参数： name=Tom 参数名:name，参数值:Tom // 第2个请求参数： age=10 参数名:age , 参数值:10 //springboot方式 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String simpleParam(String name , Integer age ){//形参名和请求参数名保持一致 System.out.println(name+\u0026#34; : \u0026#34;+age); return \u0026#34;OK\u0026#34;; } } postman测试( GET 请求)：\npostman测试( POST请求 )：\n结论：不论是GET请求还是POST请求，对于简单参数来讲，只要保证==请求参数名和Controller方法中的形参名保持一致==，就可以获取到请求参数中的数据值。\n1.2.3 参数名不一致 如果方法形参名称与请求参数名称不一致，controller方法中的形参还能接收到请求参数值吗？\n1 2 3 4 5 6 7 8 9 10 11 12 @RestController public class RequestController { // http://localhost:8080/simpleParam?name=Tom\u0026amp;age=20 // 请求参数名：name //springboot方式 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String simpleParam(String username , Integer age ){//请求参数名和形参名不相同 System.out.println(username+\u0026#34; : \u0026#34;+age); return \u0026#34;OK\u0026#34;; } } 答案：运行没有报错。 controller方法中的username值为：null，age值为20\n结论：对于简单参数来讲，请求参数名和controller方法中的形参名不一致时，无法接收到请求数据 那么如果我们开发中，遇到了这种请求参数名和controller方法中的形参名不相同，怎么办？\n解决方案：可以使用Spring提供的@RequestParam注解完成映射\n在方法形参前面加上 @RequestParam 然后通过value属性执行请求参数名，从而完成映射。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 @RestController public class RequestController { // http://localhost:8080/simpleParam?name=Tom\u0026amp;age=20 // 请求参数名：name //springboot方式 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String simpleParam(@RequestParam(\u0026#34;name\u0026#34;) String username , Integer age ){ System.out.println(username+\u0026#34; : \u0026#34;+age); return \u0026#34;OK\u0026#34;; } } 注意事项：\n@RequestParam中的required属性默认为true（默认值也是true），代表该请求参数必须传递，如果不传递将报错\n如果该参数是可选的，可以将required属性设置为false\n1 2 3 4 5 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String simpleParam(@RequestParam(name = \u0026#34;name\u0026#34;, required = false) String username, Integer age){ System.out.println(username+ \u0026#34;:\u0026#34; + age); return \u0026#34;OK\u0026#34;; } 1.3 实体参数 在使用简单参数做为数据传递方式时，前端传递了多少个请求参数，后端controller方法中的形参就要书写多少个。如果请求参数比较多，通过上述的方式一个参数一个参数的接收，会比较繁琐。\n此时，我们可以考虑将请求参数封装到一个实体类对象中。 要想完成数据封装，需要遵守如下规则：请求参数名与实体类的属性名相同\n1.3.1 简单实体对象 定义POJO实体类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class User { private String name; private Integer age; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } Controller方法：\n1 2 3 4 5 6 7 8 9 @RestController public class RequestController { //实体参数：简单实体对象 @RequestMapping(\u0026#34;/simplePojo\u0026#34;) public String simplePojo(User user){ System.out.println(user); return \u0026#34;OK\u0026#34;; } } Postman测试：\n参数名和实体类属性名一致时 参数名和实体类属性名不一致时 1.3.2 复杂实体对象 上面我们讲的呢是简单的实体对象，下面我们在来学习下复杂的实体对象。\n复杂实体对象指的是，在实体类中有一个或多个属性，也是实体对象类型的。如下：\nUser类中有一个Address类型的属性（Address是一个实体类） 复杂实体对象的封装，需要遵守如下规则：\n请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套实体类属性参数。 定义POJO实体类：\nAddress实体类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Address { private String province; private String city; public String getProvince() { return province; } public void setProvince(String province) { this.province = province; } public String getCity() { return city; } public void setCity(String city) { this.city = city; } @Override public String toString() { return \u0026#34;Address{\u0026#34; + \u0026#34;province=\u0026#39;\u0026#34; + province + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, city=\u0026#39;\u0026#34; + city + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } User实体类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public class User { private String name; private Integer age; private Address address; //地址对象 public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Address getAddress() { return address; } public void setAddress(Address address) { this.address = address; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#34;, address=\u0026#34; + address + \u0026#39;}\u0026#39;; } } Controller方法：\n1 2 3 4 5 6 7 8 9 @RestController public class RequestController { //实体参数：复杂实体对象 @RequestMapping(\u0026#34;/complexPojo\u0026#34;) public String complexPojo(User user){ System.out.println(user); return \u0026#34;OK\u0026#34;; } } Postman测试：\n1.4 数组集合参数 数组集合参数的使用场景：在HTML的表单中，有一个表单项是支持多选的(复选框)，可以提交选择的多个值。\n多个值是怎么提交的呢？其实多个值也是一个一个的提交。\n后端程序接收上述多个值的方式有两种：\n数组 集合 1.4.1 数组 数组参数：请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数\nController方法：\n1 2 3 4 5 6 7 8 9 @RestController public class RequestController { //数组集合参数 @RequestMapping(\u0026#34;/arrayParam\u0026#34;) public String arrayParam(String[] hobby){ System.out.println(Arrays.toString(hobby)); return \u0026#34;OK\u0026#34;; } } Postman测试：\n在前端请求时，有两种传递形式：\n方式一： xxxxxxxxxx?hobby=game\u0026amp;hobby=java\n方式二：xxxxxxxxxxxxx?hobby=game,java\n1.4.2 集合 集合参数：请求参数名与形参集合对象名相同且请求参数为多个，@RequestParam 绑定参数关系\n默认情况下，请求中参数名相同的多个值，是封装到数组。如果要封装到集合，要使用@RequestParam绑定参数关系\nController方法：\n1 2 3 4 5 6 7 8 9 @RestController public class RequestController { //数组集合参数 @RequestMapping(\u0026#34;/listParam\u0026#34;) public String listParam(@RequestParam List\u0026lt;String\u0026gt; hobby){ System.out.println(hobby); return \u0026#34;OK\u0026#34;; } } Postman测试：\n方式一： xxxxxxxxxx?hobby=game\u0026amp;hobby=java\n方式二：xxxxxxxxxxxxx?hobby=game,java\n1.5 日期参数 上述演示的都是一些普通的参数，在一些特殊的需求中，可能会涉及到日期类型数据的封装。比如，如下需求：\n因为日期的格式多种多样（如：2022-12-12 10:05:45 、2022/12/12 10:05:45），那么对于日期类型的参数在进行封装的时候，需要通过@DateTimeFormat注解，以及其pattern属性来设置日期的格式。\n@DateTimeFormat注解的pattern属性中指定了哪种日期格式，前端的日期参数就必须按照指定的格式传递。 后端controller方法中，需要使用Date类型或LocalDateTime类型，来封装传递的参数。 Controller方法：\n1 2 3 4 5 6 7 8 9 @RestController public class RequestController { //日期时间参数 @RequestMapping(\u0026#34;/dateParam\u0026#34;) public String dateParam(@DateTimeFormat(pattern = \u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;) LocalDateTime updateTime){ System.out.println(updateTime); return \u0026#34;OK\u0026#34;; } } Postman测试：\n1.6 JSON参数 在学习前端技术时，我们有讲到过JSON，而在前后端进行交互时，如果是比较复杂的参数，前后端通过会使用JSON格式的数据进行传输。 （JSON是开发中最常用的前后端数据交互方式）\n我们学习JSON格式参数，主要从以下两个方面着手：\nPostman在发送请求时，如何传递json格式的请求参数 在服务端的controller方法中，如何接收json格式的请求参数 Postman发送JSON格式数据：\n服务端Controller方法接收JSON格式数据：\n传递json格式的参数，在Controller中会使用实体类进行封装。 封装规则：JSON数据键名与形参对象属性名相同，定义POJO类型形参即可接收参数。需要使用 @RequestBody标识。 @RequestBody注解：将JSON数据映射到形参的实体类对象中（JSON中的key和实体类中的属性名保持一致） 实体类：Address\n1 2 3 4 5 6 public class Address { private String province; private String city; //省略GET , SET 方法 } 实体类：User\n1 2 3 4 5 6 7 public class User { private String name; private Integer age; private Address address; //省略GET , SET 方法 } Controller方法：\n1 2 3 4 5 6 7 8 9 @RestController public class RequestController { //JSON参数 @RequestMapping(\u0026#34;/jsonParam\u0026#34;) public String jsonParam(@RequestBody User user){ System.out.println(user); return \u0026#34;OK\u0026#34;; } } Postman测试：\n1.7 路径参数 传统的开发中请求参数是放在请求体(POST请求)传递或跟在URL后面通过?key=value的形式传递(GET请求)。\n在现在的开发中，经常还会直接在请求的URL中传递参数。例如：\n1 2 http://localhost:8080/user/1\thttp://localhost:880/user/1/0 上述的这种传递请求参数的形式呢，我们称之为：路径参数。\n学习路径参数呢，主要掌握在后端的controller方法中，如何接收路径参数。\n路径参数：\n前端：通过请求URL直接传递参数 后端：使用{…}来标识该路径参数，需要使用@PathVariable获取路径参数 Controller方法：\n1 2 3 4 5 6 7 8 9 @RestController public class RequestController { //路径参数 @RequestMapping(\u0026#34;/path/{id}\u0026#34;) public String pathParam(@PathVariable Integer id){ System.out.println(id); return \u0026#34;OK\u0026#34;; } } Postman测试：\n传递多个路径参数：\nPostman：\nController方法：\n1 2 3 4 5 6 7 8 9 @RestController public class RequestController { //路径参数 @RequestMapping(\u0026#34;/path/{id}/{name}\u0026#34;) public String pathParam2(@PathVariable Integer id, @PathVariable String name){ System.out.println(id+ \u0026#34; : \u0026#34; +name); return \u0026#34;OK\u0026#34;; } } 2. 响应 前面我们学习过HTTL协议的交互方式：请求响应模式（有请求就有响应）\n那么Controller程序呢，除了接收请求外，还可以进行响应。\n2.1 @ResponseBody 在我们前面所编写的controller方法中，都已经设置了响应数据。\ncontroller方法中的return的结果，怎么就可以响应给浏览器呢？\n答案：使用@ResponseBody注解\n@ResponseBody注解：\n类型：方法注解、类注解 位置：书写在Controller方法上或类上 作用：将方法返回值直接响应给浏览器 如果返回值类型是实体对象/集合，将会转换为JSON格式后在响应给浏览器 但是在我们所书写的Controller中，只在类上添加了@RestController注解、方法添加了@RequestMapping注解，并没有使用@ResponseBody注解，怎么给浏览器响应呢？\n1 2 3 4 5 6 7 8 @RestController public class HelloController { @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(){ System.out.println(\u0026#34;Hello World ~\u0026#34;); return \u0026#34;Hello World ~\u0026#34;; } } 原因：在类上添加的@RestController注解，是一个组合注解。\n@RestController = @Controller + @ResponseBody @RestController源码：\n1 2 3 4 5 6 7 8 9 10 11 @Target({ElementType.TYPE}) //元注解（修饰注解的注解） @Retention(RetentionPolicy.RUNTIME) //元注解 @Documented //元注解 @Controller @ResponseBody public @interface RestController { @AliasFor( annotation = Controller.class ) String value() default \u0026#34;\u0026#34;; } 结论：在类上添加@RestController就相当于添加了@ResponseBody注解。\n类上有@RestController注解或@ResponseBody注解时：表示当前类下所有的方法返回值做为响应数据 方法的返回值，如果是一个POJO对象或集合时，会先转换为JSON格式，在响应给浏览器 下面我们来测试下响应数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @RestController public class ResponseController { //响应字符串 @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(){ System.out.println(\u0026#34;Hello World ~\u0026#34;); return \u0026#34;Hello World ~\u0026#34;; } //响应实体对象 @RequestMapping(\u0026#34;/getAddr\u0026#34;) public Address getAddr(){ Address addr = new Address();//创建实体类对象 addr.setProvince(\u0026#34;广东\u0026#34;); addr.setCity(\u0026#34;深圳\u0026#34;); return addr; } //响应集合数据 @RequestMapping(\u0026#34;/listAddr\u0026#34;) public List\u0026lt;Address\u0026gt; listAddr(){ List\u0026lt;Address\u0026gt; list = new ArrayList\u0026lt;\u0026gt;();//集合对象 Address addr = new Address(); addr.setProvince(\u0026#34;广东\u0026#34;); addr.setCity(\u0026#34;深圳\u0026#34;); Address addr2 = new Address(); addr2.setProvince(\u0026#34;陕西\u0026#34;); addr2.setCity(\u0026#34;西安\u0026#34;); list.add(addr); list.add(addr2); return list; } } 在服务端响应了一个对象或者集合，那私前端获取到的数据是什么样子的呢？我们使用postman发送请求来测试下。测试效果如下：\n2.2 统一响应结果 大家有没有发现一个问题，我们在前面所编写的这些Controller方法中，返回值各种各样，没有任何的规范。\n如果我们开发一个大型项目，项目中controller方法将成千上万，使用上述方式将造成整个项目难以维护。那在真实的项目开发中是什么样子的呢？\n在真实的项目开发中，无论是哪种方法，我们都会定义一个统一的返回结果。方案如下：\n前端：只需要按照统一格式的返回结果进行解析(仅一种解析方案)，就可以拿到数据。\n统一的返回结果使用类来描述，在这个结果中包含：\n响应状态码：当前请求是成功，还是失败\n状态码信息：给页面的提示信息\n返回的数据：给前端响应的数据（字符串、对象、集合）\n定义在一个实体类Result来包含以上信息。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 public class Result { private Integer code;//响应码，1 代表成功; 0 代表失败 private String msg; //响应码 描述字符串 private Object data; //返回的数据 public Result() { } public Result(Integer code, String msg, Object data) { this.code = code; this.msg = msg; this.data = data; } public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public Object getData() { return data; } public void setData(Object data) { this.data = data; } //增删改 成功响应(不需要给前端返回数据) public static Result success(){ return new Result(1,\u0026#34;success\u0026#34;,null); } //查询 成功响应(把查询结果做为返回数据响应给前端) public static Result success(Object data){ return new Result(1,\u0026#34;success\u0026#34;,data); } //失败响应 public static Result error(String msg){ return new Result(0,msg,null); } } 改造Controller：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @RestController public class ResponseController { //响应统一格式的结果 @RequestMapping(\u0026#34;/hello\u0026#34;) public Result hello(){ System.out.println(\u0026#34;Hello World ~\u0026#34;); //return new Result(1,\u0026#34;success\u0026#34;,\u0026#34;Hello World ~\u0026#34;); return Result.success(\u0026#34;Hello World ~\u0026#34;); } //响应统一格式的结果 @RequestMapping(\u0026#34;/getAddr\u0026#34;) public Result getAddr(){ Address addr = new Address(); addr.setProvince(\u0026#34;广东\u0026#34;); addr.setCity(\u0026#34;深圳\u0026#34;); return Result.success(addr); } //响应统一格式的结果 @RequestMapping(\u0026#34;/listAddr\u0026#34;) public Result listAddr(){ List\u0026lt;Address\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Address addr = new Address(); addr.setProvince(\u0026#34;广东\u0026#34;); addr.setCity(\u0026#34;深圳\u0026#34;); Address addr2 = new Address(); addr2.setProvince(\u0026#34;陕西\u0026#34;); addr2.setCity(\u0026#34;西安\u0026#34;); list.add(addr); list.add(addr2); return Result.success(list); } } 使用Postman测试：\n2.3 案例 下面我们通过一个案例，来加强对请求响应的学习。\n2.3.1 需求说明 需求：加载并解析xml文件中的数据，完成数据处理，并在页面展示\n获取员工数据，返回统一响应结果，在页面渲染展示 2.3.2 准备工作 案例准备：\nXML文件\n已经准备好(emp.xml)，直接导入进来，放在 src/main/resources目录下 工具类\n已经准备好解析XML文件的工具类，无需自己实现 直接在创建一个包 com.itheima.utils ，然后将工具类拷贝进来 前端页面资源\n已经准备好，直接拷贝进来，放在src/main/resources下的static目录下 Springboot项目的静态资源(html，css，js等前端资源)默认存放目录为：classpath:/static 、 classpath:/public、 classpath:/resources\n在SpringBoot项目中，静态资源默认可以存放的目录：\nclasspath:/static/ classpath:/public/ classpath:/resources/ classpath:/META-INF/resources/ classpath：\n代表的是类路径，在maven的项目中，其实指的就是 src/main/resources 或者 src/main/java，但是java目录是存放java代码的，所以相关的配置文件及静态资源文档，就放在 src/main/resources下。 2.3.3 实现步骤 在pom.xml文件中引入dom4j的依赖，用于解析XML文件\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dom4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dom4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 引入资料中提供的：解析XML的工具类XMLParserUtils、实体类Emp、XML文件emp.xml\n引入资料中提供的静态页面文件，放在resources下的static目录下\n创建EmpController类，编写Controller程序，处理请求，响应数据\n2.3.4 代码实现 Contriller代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @RestController public class EmpController { @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result list(){ //1. 加载并解析emp.xml String file = this.getClass().getClassLoader().getResource(\u0026#34;emp.xml\u0026#34;).getFile(); //System.out.println(file); List\u0026lt;Emp\u0026gt; empList = XmlParserUtils.parse(file, Emp.class); //2. 对数据进行转换处理 - gender, job empList.stream().forEach(emp -\u0026gt; { //处理 gender 1: 男, 2: 女 String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); }else if(\u0026#34;2\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;女\u0026#34;); } //处理job - 1: 讲师, 2: 班主任 , 3: 就业指导 String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;讲师\u0026#34;); }else if(\u0026#34;2\u0026#34;.equals(job)){ emp.setJob(\u0026#34;班主任\u0026#34;); }else if(\u0026#34;3\u0026#34;.equals(job)){ emp.setJob(\u0026#34;就业指导\u0026#34;); } }); //3. 响应数据 return Result.success(empList); } } 统一返回结果实体类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public class Result { private Integer code ;//1 成功 , 0 失败 private String msg; //提示信息 private Object data; //数据 date public Result() { } public Result(Integer code, String msg, Object data) { this.code = code; this.msg = msg; this.data = data; } public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public Object getData() { return data; } public void setData(Object data) { this.data = data; } public static Result success(Object data){ return new Result(1, \u0026#34;success\u0026#34;, data); } public static Result success(){ return new Result(1, \u0026#34;success\u0026#34;, null); } public static Result error(String msg){ return new Result(0, msg, null); } } 2.3.5 测试 代码编写完毕之后，我们就可以运行引导类，启动服务进行测试了。\n使用Postman测试：\n打开浏览器，在浏览器地址栏输入： http://localhost:8080/emp.html\n2.3.6 问题分析 上述案例的功能，我们虽然已经实现，但是呢，我们会发现案例中：解析XML数据，获取数据的代码，处理数据的逻辑的代码，给页面响应的代码全部都堆积在一起了，全部都写在controller方法中了。\n当前程序的这个业务逻辑还是比较简单的，如果业务逻辑再稍微复杂一点，我们会看到Controller方法的代码量就很大了。\n当我们要修改操作数据部分的代码，需要改动Controller\n当我们要完善逻辑处理部分的代码，需要改动Controller\n当我们需要修改数据响应的代码，还是需要改动Controller\n这样呢，就会造成我们整个工程代码的复用性比较差，而且代码难以维护。 那如何解决这个问题呢？其实在现在的开发中，有非常成熟的解决思路，那就是分层开发。\n3. 分层解耦 3.1 三层架构 3.1.1 介绍 在我们进行程序设计以及程序开发时，尽可能让每一个接口、类、方法的职责更单一些（单一职责原则）。\n单一职责原则：一个类或一个方法，就只做一件事情，只管一块功能。\n这样就可以让类、接口、方法的复杂度更低，可读性更强，扩展性更好，也更利用后期的维护。\n我们之前开发的程序呢，并不满足单一职责原则。下面我们来分析下之前的程序：\n那其实我们上述案例的处理逻辑呢，从组成上看可以分为三个部分：\n数据访问：负责业务数据的维护操作，包括增、删、改、查等操作。 逻辑处理：负责业务逻辑处理的代码。 请求处理、响应数据：负责，接收页面的请求，给页面响应数据。 按照上述的三个组成部分，在我们项目开发中呢，可以将代码分为三层：\nController：控制层。接收前端发送的请求，对请求进行处理，并响应数据。 Service：业务逻辑层。处理具体的业务逻辑。 Dao：数据访问层(Data Access Object)，也称为持久层。负责数据访问操作，包括数据的增、删、改、查。 基于三层架构的程序执行流程：\n前端发起的请求，由Controller层接收（Controller响应数据给前端） Controller层调用Service层来进行逻辑处理（Service层处理完后，把处理结果返回给Controller层） Serivce层调用Dao层（逻辑处理过程中需要用到的一些数据要从Dao层获取） Dao层操作文件中的数据（Dao拿到的数据会返回给Service层） 思考：按照三层架构的思想，如何要对业务逻辑(Service层)进行变更，会影响到Controller层和Dao层吗？\n答案：不会影响。 （程序的扩展性、维护性变得更好了）\n3.1.2 代码拆分 我们使用三层架构思想，来改造下之前的程序：\n控制层包名：xxxx.controller 业务逻辑层包名：xxxx.service 数据访问层包名：xxxx.dao **控制层：**接收前端发送的请求，对请求进行处理，并响应数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @RestController public class EmpController { //业务层对象 private EmpService empService = new EmpServiceA(); @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result list(){ //1. 调用service层, 获取数据 List\u0026lt;Emp\u0026gt; empList = empService.listEmp(); //3. 响应数据 return Result.success(empList); } } **业务逻辑层：**处理具体的业务逻辑\n业务接口 1 2 3 4 5 //业务逻辑接口（制定业务标准） public interface EmpService { //获取员工列表 public List\u0026lt;Emp\u0026gt; listEmp(); } 业务实现类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //业务逻辑实现类（按照业务标准实现） public class EmpServiceA implements EmpService { //dao层对象 private EmpDao empDao = new EmpDaoA(); @Override public List\u0026lt;Emp\u0026gt; listEmp() { //1. 调用dao, 获取数据 List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); //2. 对数据进行转换处理 - gender, job empList.stream().forEach(emp -\u0026gt; { //处理 gender 1: 男, 2: 女 String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); }else if(\u0026#34;2\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;女\u0026#34;); } //处理job - 1: 讲师, 2: 班主任 , 3: 就业指导 String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;讲师\u0026#34;); }else if(\u0026#34;2\u0026#34;.equals(job)){ emp.setJob(\u0026#34;班主任\u0026#34;); }else if(\u0026#34;3\u0026#34;.equals(job)){ emp.setJob(\u0026#34;就业指导\u0026#34;); } }); return empList; } } **数据访问层：**负责数据的访问操作，包含数据的增、删、改、查\n数据访问接口 1 2 3 4 5 //数据访问层接口（制定标准） public interface EmpDao { //获取员工列表数据 public List\u0026lt;Emp\u0026gt; listEmp(); } 数据访问实现类 1 2 3 4 5 6 7 8 9 10 11 //数据访问实现类 public class EmpDaoA implements EmpDao { @Override public List\u0026lt;Emp\u0026gt; listEmp() { //1. 加载并解析emp.xml String file = this.getClass().getClassLoader().getResource(\u0026#34;emp.xml\u0026#34;).getFile(); System.out.println(file); List\u0026lt;Emp\u0026gt; empList = XmlParserUtils.parse(file, Emp.class); return empList; } } 三层架构的好处：\n复用性强 便于维护 利用扩展 3.2 分层解耦 刚才我们学习过程序分层思想了，接下来呢，我们来学习下程序的解耦思想。\n解耦：解除耦合。\n3.2.1 耦合问题 首先需要了解软件开发涉及到的两个概念：内聚和耦合。\n内聚：软件中各个功能模块内部的功能联系。\n耦合：衡量软件中各个层/模块之间的依赖、关联的程度。\n软件设计原则：高内聚低耦合。\n高内聚指的是：一个模块中各个元素之间的联系的紧密程度，如果各个元素(语句、程序段)之间的联系程度越高，则内聚性越高，即 \u0026ldquo;高内聚\u0026rdquo;。\n低耦合指的是：软件中各个层、模块之间的依赖关联程序越低越好。\n程序中高内聚的体现：\nEmpServiceA类中只编写了和员工相关的逻辑处理代码 程序中耦合代码的体现：\n把业务类变为EmpServiceB时，需要修改controller层中的代码 高内聚、低耦合的目的是使程序模块的可重用性、移植性大大增强。\n3.2.2 解耦思路 之前我们在编写代码时，需要什么对象，就直接new一个就可以了。 这种做法呢，层与层之间代码就耦合了，当service层的实现变了之后， 我们还需要修改controller层的代码。\n那应该怎么解耦呢？\n首先不能在EmpController中使用new对象。代码如下： 此时，就存在另一个问题了，不能new，就意味着没有业务层对象（程序运行就报错），怎么办呢？ 我们的解决思路是： 提供一个容器，容器中存储一些对象(例：EmpService对象) controller程序从容器中获取EmpService类型的对象 我们想要实现上述解耦操作，就涉及到Spring中的两个核心概念：\n控制反转： Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。\n对象的创建权由程序员主动创建转移到容器(由容器创建、管理对象)。这个容器称为：IOC容器或Spring容器\n依赖注入： Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。\n程序运行时需要某个资源，此时容器就为其提供这个资源。\n例：EmpController程序运行时需要EmpService对象，Spring容器就为其提供并注入EmpService对象\nIOC容器中创建、管理的对象，称之为：bean对象\n3.3 IOC\u0026amp;DI 上面我们引出了Spring中IOC和DI的基本概念，下面我们就来具体学习下IOC和DI的代码实现。\n3.3.1 IOC\u0026amp;DI入门 任务：完成Controller层、Service层、Dao层的代码解耦\n思路： 删除Controller层、Service层中new对象的代码 Service层及Dao层的实现类，交给IOC容器管理 为Controller及Service注入运行时依赖的对象 Controller程序中注入依赖的Service层对象 Service程序中注入依赖的Dao层对象 第1步：删除Controller层、Service层中new对象的代码\n第2步：Service层及Dao层的实现类，交给IOC容器管理\n使用Spring提供的注解：@Component ，就可以实现类交给IOC容器管理 第3步：为Controller及Service注入运行时依赖的对象\n使用Spring提供的注解：@Autowired ，就可以实现程序运行时IOC容器自动注入需要的依赖对象 完整的三层代码：\nController层： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @RestController public class EmpController { @Autowired //运行时,从IOC容器中获取该类型对象,赋值给该变量 private EmpService empService ; @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result list(){ //1. 调用service, 获取数据 List\u0026lt;Emp\u0026gt; empList = empService.listEmp(); //3. 响应数据 return Result.success(empList); } } Service层： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @Component //将当前对象交给IOC容器管理,成为IOC容器的bean public class EmpServiceA implements EmpService { @Autowired //运行时,从IOC容器中获取该类型对象,赋值给该变量 private EmpDao empDao ; @Override public List\u0026lt;Emp\u0026gt; listEmp() { //1. 调用dao, 获取数据 List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); //2. 对数据进行转换处理 - gender, job empList.stream().forEach(emp -\u0026gt; { //处理 gender 1: 男, 2: 女 String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); }else if(\u0026#34;2\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;女\u0026#34;); } //处理job - 1: 讲师, 2: 班主任 , 3: 就业指导 String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;讲师\u0026#34;); }else if(\u0026#34;2\u0026#34;.equals(job)){ emp.setJob(\u0026#34;班主任\u0026#34;); }else if(\u0026#34;3\u0026#34;.equals(job)){ emp.setJob(\u0026#34;就业指导\u0026#34;); } }); return empList; } } Dao层：\n1 2 3 4 5 6 7 8 9 10 11 @Component //将当前对象交给IOC容器管理,成为IOC容器的bean public class EmpDaoA implements EmpDao { @Override public List\u0026lt;Emp\u0026gt; listEmp() { //1. 加载并解析emp.xml String file = this.getClass().getClassLoader().getResource(\u0026#34;emp.xml\u0026#34;).getFile(); System.out.println(file); List\u0026lt;Emp\u0026gt; empList = XmlParserUtils.parse(file, Emp.class); return empList; } } 运行测试：\n启动SpringBoot引导类，打开浏览器，输入：http://localhost:8080/emp.html 3.3.2 IOC详解 通过IOC和DI的入门程序呢，我们已经基本了解了IOC和DI的基础操作。接下来呢，我们学习下IOC控制反转和DI依赖注入的细节。\n3.3.2.1 bean的声明 前面我们提到IOC控制反转，就是将对象的控制权交给Spring的IOC容器，由IOC容器创建及管理对象。IOC容器创建的对象称为bean对象。\n在之前的入门案例中，要把某个对象交给IOC容器管理，需要在类上添加一个注解：@Component\n而Spring框架为了更好的标识web应用程序开发当中，bean对象到底归属于哪一层，又提供了@Component的衍生注解：\n@Controller （标注在控制层类上） @Service （标注在业务层类上） @Repository （标注在数据访问层类上） 修改入门案例代码：\nController层： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @RestController //@RestController = @Controller + @ResponseBody public class EmpController { @Autowired //运行时,从IOC容器中获取该类型对象,赋值给该变量 private EmpService empService ; @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result list(){ //1. 调用service, 获取数据 List\u0026lt;Emp\u0026gt; empList = empService.listEmp(); //3. 响应数据 return Result.success(empList); } } Service层： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @Service public class EmpServiceA implements EmpService { @Autowired //运行时,从IOC容器中获取该类型对象,赋值给该变量 private EmpDao empDao ; @Override public List\u0026lt;Emp\u0026gt; listEmp() { //1. 调用dao, 获取数据 List\u0026lt;Emp\u0026gt; empList = empDao.listEmp(); //2. 对数据进行转换处理 - gender, job empList.stream().forEach(emp -\u0026gt; { //处理 gender 1: 男, 2: 女 String gender = emp.getGender(); if(\u0026#34;1\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;男\u0026#34;); }else if(\u0026#34;2\u0026#34;.equals(gender)){ emp.setGender(\u0026#34;女\u0026#34;); } //处理job - 1: 讲师, 2: 班主任 , 3: 就业指导 String job = emp.getJob(); if(\u0026#34;1\u0026#34;.equals(job)){ emp.setJob(\u0026#34;讲师\u0026#34;); }else if(\u0026#34;2\u0026#34;.equals(job)){ emp.setJob(\u0026#34;班主任\u0026#34;); }else if(\u0026#34;3\u0026#34;.equals(job)){ emp.setJob(\u0026#34;就业指导\u0026#34;); } }); return empList; } } Dao层：\n1 2 3 4 5 6 7 8 9 10 11 @Repository public class EmpDaoA implements EmpDao { @Override public List\u0026lt;Emp\u0026gt; listEmp() { //1. 加载并解析emp.xml String file = this.getClass().getClassLoader().getResource(\u0026#34;emp.xml\u0026#34;).getFile(); System.out.println(file); List\u0026lt;Emp\u0026gt; empList = XmlParserUtils.parse(file, Emp.class); return empList; } } 要把某个对象交给IOC容器管理，需要在对应的类上加上如下注解之一：\n注解 说明 位置 @Controller @Component的衍生注解 标注在控制器类上 @Service @Component的衍生注解 标注在业务类上 @Repository @Component的衍生注解 标注在数据访问类上（由于与mybatis整合，用的少） @Component 声明bean的基础注解 不属于以上三类时，用此注解 查看源码：\n在IOC容器中，每一个Bean都有一个属于自己的名字，可以通过注解的value属性指定bean的名字。如果没有指定，默认为类名首字母小写。\n注意事项:\n声明bean的时候，可以通过value属性指定bean的名字，如果没有指定，默认为类名首字母小写。 使用以上四个注解都可以声明bean，但是在springboot集成web开发中，声明控制器bean只能用@Controller。 3.3.2.2 组件扫描 问题：使用前面学习的四个注解声明的bean，一定会生效吗？\n答案：不一定。（原因：bean想要生效，还需要被组件扫描）\n下面我们通过修改项目工程的目录结构，来测试bean对象是否生效：\n运行程序后，报错：\n为什么没有找到bean对象呢？\n使用四大注解声明的bean，要想生效，还需要被组件扫描注解@ComponentScan扫描 @ComponentScan注解虽然没有显式配置，但是实际上已经包含在了引导类声明注解 @SpringBootApplication 中，==默认扫描的范围是SpringBoot启动类所在包及其子包==。\n解决方案：手动添加@ComponentScan注解，指定要扫描的包 （==仅做了解，不推荐==） 推荐做法（如下图）：\n将我们定义的controller，service，dao这些包呢，都放在引导类所在包com.itheima的子包下，这样我们定义的bean就会被自动的扫描到 3.3.3 DI详解 上一小节我们讲解了控制反转IOC的细节，接下来呢，我们学习依赖注解DI的细节。\n依赖注入，是指IOC容器要为应用程序去提供运行时所依赖的资源，而资源指的就是对象。\n在入门程序案例中，我们使用了@Autowired这个注解，完成了依赖注入的操作，而这个Autowired翻译过来叫：自动装配。\n@Autowired注解，默认是按照类型进行自动装配的（去IOC容器中找某个类型的对象，然后完成注入操作）\n入门程序举例：在EmpController运行的时候，就要到IOC容器当中去查找EmpService这个类型的对象，而我们的IOC容器中刚好有一个EmpService这个类型的对象，所以就找到了这个类型的对象完成注入操作。\n那如果在IOC容器中，存在多个相同类型的bean对象，会出现什么情况呢？\n程序运行会报错 如何解决上述问题呢？Spring提供了以下几种解决方案：\n@Primary\n@Qualifier\n@Resource\n使用@Primary注解：当存在多个相同类型的Bean注入时，加上@Primary注解，来确定默认的实现。\n使用@Qualifier注解：指定当前要注入的bean对象。 在@Qualifier的value属性中，指定注入的bean的名称。\n@Qualifier注解不能单独使用，必须配合@Autowired使用 使用@Resource注解：是按照bean的名称进行注入。通过name属性指定要注入的bean的名称。\n面试题 ： @Autowird 与 @Resource的区别\n@Autowired 是spring框架提供的注解，而@Resource是JDK提供的注解 @Autowired 默认是按照类型注入，而@Resource是按照名称注入 ","date":"2024-07-05T22:27:20+08:00","image":"https://picsum.photos/800/600 ","permalink":"https://4evergreat.github.io/2024/springboot-blog-5/","title":"springboot-blog-5 请求响应篇"},{"content":"网站插件安装与性能优化 1.建站以来遇到的问题 1.1 推送到服务器后，发现一些跳转链接不是实际页面地址，而是localhost1313 原因： 推送前使用了hugo server 命令，/public 文件夹中存放的是搭建本地网站生成的文件。 处理： 第一步，先执行 hugo \u0026ndash;gc 命令清楚缓存。注意不同版本hugo的清除命令会有一定的区别。留意hugo help里面的具体参数描述即可。第二步，执行hugo命令，尔后把public文件夹推送到服务器。\n1.2 markdown文件经过hugo编译成html后，代码的部分没有复制按钮 一如markdown文件常用编译器typora原生不支持代码复制按钮一样。hugo引入的markdown插件也不提供这个功能。解决方法： 在 ts\\main.ts文件里添加如下代码段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 /* # 前文定位 let Stack = { init: () =\u0026gt; { .... observer.observe(articleTile) } */ // 添加代码段 /** * Add copy button to code block */ const highlights = document.querySelectorAll(\u0026#39;.article-content div.highlight\u0026#39;); const copyText = `Copy`, copiedText = `Copied!`; highlights.forEach(highlight =\u0026gt; { const copyButton = document.createElement(\u0026#39;button\u0026#39;); copyButton.innerHTML = copyText; copyButton.classList.add(\u0026#39;copyCodeButton\u0026#39;); highlight.appendChild(copyButton); const codeBlock = highlight.querySelector(\u0026#39;code[data-lang]\u0026#39;); if (!codeBlock) return; copyButton.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { navigator.clipboard.writeText(codeBlock.textContent) .then(() =\u0026gt; { copyButton.textContent = copiedText; setTimeout(() =\u0026gt; { copyButton.textContent = copyText; }, 1000); }) .catch(err =\u0026gt; { alert(err) console.log(\u0026#39;Something went wrong\u0026#39;, err); }); }); }); /* # 后文定位 ... new StackColorScheme(document.getElementById(\u0026#39;dark-mode-toggle\u0026#39;)); } } */ 在成功添加copy button 后修改它的css样式。修改/assets/scss/partials/layout/article.scss文件.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* .article-content { ... .highlight { ... */ // 添加代码段 \u0026amp;:hover { //可选悬停样式变化 .copyCodeButton { opacity: 1; } } /* ... } */ // 添加代码段 .copyCodeButton { position: absolute; top: calc(var(--card-padding)); right: calc(var(--card-padding)); background: var(--card-background); border: none; box-shadow: var(--shadow-l2); border-radius: var(--tag-border-radius); padding: 8px 16px; color: var(--card-text-color-main); cursor: pointer; font-size: 14px; opacity: 0; transition: opacity 0.3s ease; } /* ... } */ 1.3. 博客内添加一键跳转到页头、页尾的按钮 \u0026gt; 思路： 在/layouts/_default/single.html 中自定义按钮。我选择在right sidebar一侧添加该按钮\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 {{ define \u0026#34;right-sidebar\u0026#34; }} {{ if (.Scratch.Get \u0026#34;hasTOC\u0026#34;) }} \u0026lt;aside class=\u0026#34;sidebar right-sidebar sticky\u0026#34;\u0026gt; \u0026lt;section class=\u0026#34;widget archives\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;widget-icon\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;hash\u0026#34; }} \u0026lt;/div\u0026gt; \u0026lt;h2 class=\u0026#34;widget-title section-title\u0026#34;\u0026gt;{{ T \u0026#34;article.tableOfContents\u0026#34; }}\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;widget--toc\u0026#34;\u0026gt; {{ .TableOfContents }} \u0026lt;/div\u0026gt; // ###############新增代码段start###################### \u0026lt;div class=\u0026#34;scroll-buttons\u0026#34;\u0026gt; \u0026lt;!-- 跳转页面顶部的按钮 --\u0026gt; \u0026lt;button id=\u0026#34;scrollToTopBtn\u0026#34; class=\u0026#34;scroll-button\u0026#34;\u0026gt;返回顶部\u0026lt;/button\u0026gt; \u0026lt;!-- 跳转页面底部的按钮 --\u0026gt; \u0026lt;button id=\u0026#34;scrollToBottomBtn\u0026#34; class=\u0026#34;scroll-button\u0026#34;\u0026gt;跳转底部\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/aside\u0026gt; {{ end }} \u0026lt;!-- JavaScript 代码 --\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function() { var scrollToBottomBtn = document.getElementById(\u0026#39;scrollToBottomBtn\u0026#39;); scrollToBottomBtn.addEventListener(\u0026#39;click\u0026#39;, function() { window.scrollTo(0, document.body.scrollHeight); }); var scrollToTopBtn = document.getElementById(\u0026#39;scrollToTopBtn\u0026#39;); scrollToTopBtn.addEventListener(\u0026#39;click\u0026#39;, function() { window.scrollTo({ top: 0, behavior: \u0026#39;smooth\u0026#39; // 平滑滚动 }); }); }); \u0026lt;/script\u0026gt; // #################新增代码段end#################### {{ end }} 同样需要修改按钮的css样式。在/assets/scss/partials/layouts/article.scss 文件的文末添加如下代码段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 .scroll-buttons { position: fixed; /* 固定定位 */ bottom: 20px; /* 距离页面底部的距离 */ right: 20px; /* 距离页面右侧的距离 */ display: flex; /* 使用Flexbox进行布局 */ flex-direction: column; /* 垂直排列子元素 */ align-items: flex-end; /* 可选，如果按钮需要更靠近右边 */ gap: 10px; /* 子元素之间的间隔 */ z-index: 1000; /* 确保按钮位于其他元素之上 */ } .scroll-button { /* 按钮的基本样式 */ background-color: #acd6acb7; /* 按钮的背景颜色 */ color: rgb(4, 1, 17); /* 按钮上文字的颜色 */ padding: 10px 20px; /* 按钮的内边距 */ border: none; /* 去除边框 */ border-radius: 5px; /* 边框圆角 */ cursor: pointer; /* 鼠标悬停时的光标样式 */ /* 可选的：按钮的过渡效果 */ transition: background-color 0.3s ease; /* 可选的：按钮悬停时的样式变化 */ \u0026amp;:hover { background-color: #b39200; /* 悬停时的背景颜色 */ } } 1.4. 添加文章字数统计 单篇字数统计 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # layouts\\partials\\article\\components\\details.html的 article-details div里添加 \u0026lt;footer class=\u0026#34;article-time\u0026#34;\u0026gt; {{ if $showDate }} \u0026lt;div\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clapperboard-solid\u0026#34; }} \u0026lt;time class=\u0026#34;article-time--published\u0026#34;\u0026gt; {{- .Date.Format (or .Site.Params.dateFormat.published \u0026#34;Jan 02, 2006\u0026#34;) -}} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{ end }} {{ if $showReadingTime }} \u0026lt;div\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;time class=\u0026#34;article-time--reading\u0026#34;\u0026gt; {{ T \u0026#34;article.readingTime\u0026#34; .ReadingTime }} # 共{{ .WordCount }} 字 \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/footer\u0026gt; 总文章的字数统计 1 2 3 4 5 6 7 8 9 10 11 12 13 # layouts\\partials\\footer\\footer.html \u0026lt;section class=\u0026#34;powerby\u0026#34;\u0026gt; {{ with .Site.Params.footer.customText }} {{ . | safeHTML }} \u0026lt;br/\u0026gt; {{ end }} {{ $articleCount := len .Site.RegularPages }} {{ $totalWordCount := 0 }} {{ range .Site.Pages }} {{ $totalWordCount = add $totalWordCount .WordCount }} {{ end }} \u0026lt;p\u0026gt;已经写了 {{ $articleCount }} 篇文章，共 {{ $totalWordCount }} 字。\u0026lt;/p\u0026gt; \u0026lt;/section\u0026gt; 1.5. 文章置顶 给想要置顶的文章，在其的头部添加权重即可\n1 2 3 4 5 6 --- ... # 添加权重，数值自定 weight: 1000 --- 1.6.鼠标特效 1.创建static\\js\\fireworks.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 var fireworks = (function() { var canvasEl = document.querySelector(\u0026#39;.fireworks\u0026#39;); var ctx = canvasEl.getContext(\u0026#39;2d\u0026#39;); var numberOfParticules = Number(location.href.split(\u0026#39;?\u0026#39;)[1]) || 40; var pointerX = 0; var pointerY = 0; var tap = (\u0026#39;ontouchstart\u0026#39; in window || navigator.msMaxTouchPoints) ? \u0026#39;touchstart\u0026#39; : \u0026#39;mousedown\u0026#39;; var colors = [\u0026#39;#FF1461\u0026#39;, \u0026#39;#18FF92\u0026#39;, \u0026#39;#5A87FF\u0026#39;, \u0026#39;#FBF38C\u0026#39;]; function setCanvasSize() { canvasEl.width = window.innerWidth * 2; canvasEl.height = window.innerHeight * 2; canvasEl.style.width = window.innerWidth + \u0026#39;px\u0026#39;; canvasEl.style.height = window.innerHeight + \u0026#39;px\u0026#39;; canvasEl.getContext(\u0026#39;2d\u0026#39;).scale(2, 2); } function updateCoords(e) { pointerX = e.clientX || e.touches[0].clientX; pointerY = e.clientY || e.touches[0].clientY; } function setParticuleDirection(p) { var angle = anime.random(0, 360) * Math.PI / 180; var value = anime.random(50, 180); var radius = [-1, 1][anime.random(0, 1)] * value; return { x: p.x + radius * Math.cos(angle), y: p.y + radius * Math.sin(angle) } } function createParticule(x,y) { var p = {}; p.x = x; p.y = y; p.color = colors[anime.random(0, colors.length - 1)]; p.radius = anime.random(16, 32); p.endPos = setParticuleDirection(p); p.draw = function() { ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, 2 * Math.PI, true); ctx.fillStyle = p.color; ctx.fill(); } return p; } function createCircle(x,y) { var p = {}; p.x = x; p.y = y; p.color = \u0026#39;#FFF\u0026#39;; p.radius = 0.1; p.alpha = .5; p.lineWidth = 6; p.draw = function() { ctx.globalAlpha = p.alpha; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, 2 * Math.PI, true); ctx.lineWidth = p.lineWidth; ctx.strokeStyle = p.color; ctx.stroke(); ctx.globalAlpha = 1; } return p; } function renderParticule(anim) { for (var i = 0; i \u0026lt; anim.animatables.length; i++) { anim.animatables[i].target.draw(); } } function animateParticules(x, y) { var circle = createCircle(x, y); var particules = []; for (var i = 0; i \u0026lt; numberOfParticules; i++) { particules.push(createParticule(x, y)); } anime.timeline().add({ targets: particules, x: function(p) { return p.endPos.x; }, y: function(p) { return p.endPos.y; }, radius: 0.1, // -------------------------圆球消失的速度为 1900ms - 2400ms duration: anime.random(1900, 2400), easing: \u0026#39;easeOutExpo\u0026#39;, update: renderParticule }) .add({ targets: circle, radius: anime.random(180, 160), lineWidth: 0, alpha: { value: 0, easing: \u0026#39;linear\u0026#39;, duration: anime.random(800, 1000), }, // -------------------------圆线消失的速度为 1900ms - 2400ms duration: anime.random(1900, 2400), easing: \u0026#39;easeOutExpo\u0026#39;, update: renderParticule, offset: 0 }).add({ targets: circle, radius: anime.random(180, 160), lineWidth: 0, alpha: { value: 0, easing: \u0026#39;linear\u0026#39;, duration: anime.random(800, 1000), }, // -------------------------第二层圆线消失的速度为 2200ns - 2800ms duration: anime.random(2200, 2800), easing: \u0026#39;easeOutExpo\u0026#39;, update: renderParticule, offset: 0 }); } var render = anime({ duration: Infinity, update: function() { ctx.clearRect(0, 0, canvasEl.width, canvasEl.height); } }); document.addEventListener(tap, function(e) { window.human = true; render.play(); updateCoords(e); animateParticules(pointerX, pointerY); ga(\u0026#39;send\u0026#39;, \u0026#39;event\u0026#39;, \u0026#39;Fireworks\u0026#39;, \u0026#39;Click\u0026#39;); }, false); window.addEventListener(\u0026#39;resize\u0026#39;, setCanvasSize, false); return { render: render, setCanvasSize: setCanvasSize, animateParticules: animateParticules } })(); 2.创建static\\js\\anime.min.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 /* 2017 Julian Garnier Released under the MIT license */ var $jscomp = { scope: {} }; $jscomp.defineProperty = \u0026#34;function\u0026#34; == typeof Object.defineProperties ? Object.defineProperty : function (e, r, p) { if (p.get || p.set) throw new TypeError(\u0026#34;ES3 does not support getters and setters.\u0026#34;); e != Array.prototype \u0026amp;\u0026amp; e != Object.prototype \u0026amp;\u0026amp; (e[r] = p.value) }; $jscomp.getGlobal = function (e) { return \u0026#34;undefined\u0026#34; != typeof window \u0026amp;\u0026amp; window === e ? e : \u0026#34;undefined\u0026#34; != typeof global \u0026amp;\u0026amp; null != global ? global : e }; $jscomp.global = $jscomp.getGlobal(this); $jscomp.SYMBOL_PREFIX = \u0026#34;jscomp_symbol_\u0026#34;; $jscomp.initSymbol = function () { $jscomp.initSymbol = function () {}; $jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol) }; $jscomp.symbolCounter_ = 0; $jscomp.Symbol = function (e) { return $jscomp.SYMBOL_PREFIX + (e || \u0026#34;\u0026#34;) + $jscomp.symbolCounter_++ }; $jscomp.initSymbolIterator = function () { $jscomp.initSymbol(); var e = $jscomp.global.Symbol.iterator; e || (e = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol(\u0026#34;iterator\u0026#34;)); \u0026#34;function\u0026#34; != typeof Array.prototype[e] \u0026amp;\u0026amp; $jscomp.defineProperty(Array.prototype, e, { configurable: !0, writable: !0, value: function () { return $jscomp.arrayIterator(this) } }); $jscomp.initSymbolIterator = function () {} }; $jscomp.arrayIterator = function (e) { var r = 0; return $jscomp.iteratorPrototype(function () { return r \u0026lt; e.length ? { done: !1, value: e[r++] } : { done: !0 } }) }; $jscomp.iteratorPrototype = function (e) { $jscomp.initSymbolIterator(); e = { next: e }; e[$jscomp.global.Symbol.iterator] = function () { return this }; return e }; $jscomp.array = $jscomp.array || {}; $jscomp.iteratorFromArray = function (e, r) { $jscomp.initSymbolIterator(); e instanceof String \u0026amp;\u0026amp; (e += \u0026#34;\u0026#34;); var p = 0, m = { next: function () { if (p \u0026lt; e.length) { var u = p++; return { value: r(u, e[u]), done: !1 } } m.next = function () { return { done: !0, value: void 0 } }; return m.next() } }; m[Symbol.iterator] = function () { return m }; return m }; $jscomp.polyfill = function (e, r, p, m) { if (r) { p = $jscomp.global; e = e.split(\u0026#34;.\u0026#34;); for (m = 0; m \u0026lt; e.length - 1; m++) { var u = e[m]; u in p || (p[u] = {}); p = p[u] } e = e[e.length - 1]; m = p[e]; r = r(m); r != m \u0026amp;\u0026amp; null != r \u0026amp;\u0026amp; $jscomp.defineProperty(p, e, { configurable: !0, writable: !0, value: r }) } }; $jscomp.polyfill(\u0026#34;Array.prototype.keys\u0026#34;, function (e) { return e ? e : function () { return $jscomp.iteratorFromArray(this, function (e) { return e }) } }, \u0026#34;es6-impl\u0026#34;, \u0026#34;es3\u0026#34;); var $jscomp$this = this; (function (e, r) { \u0026#34;function\u0026#34; === typeof define \u0026amp;\u0026amp; define.amd ? define([], r) : \u0026#34;object\u0026#34; === typeof module \u0026amp;\u0026amp; module.exports ? module.exports = r() : e.anime = r() })(this, function () { function e(a) { if (!h.col(a)) try { return document.querySelectorAll(a) } catch (c) {} } function r(a, c) { for (var d = a.length, b = 2 \u0026lt;= arguments.length ? arguments[1] : void 0, f = [], n = 0; n \u0026lt; d; n++) if (n in a) { var k = a[n]; c.call(b, k, n, a) \u0026amp;\u0026amp; f.push(k) } return f } function p(a) { return a.reduce(function (a, d) { return a.concat(h.arr(d) ? p(d) : d) }, []) } function m(a) { if (h.arr(a)) return a; h.str(a) \u0026amp;\u0026amp; (a = e(a) || a); return a instanceof NodeList || a instanceof HTMLCollection ? [].slice.call(a) : [a] } function u(a, c) { return a.some(function (a) { return a === c }) } function C(a) { var c = {}, d; for (d in a) c[d] = a[d]; return c } function D(a, c) { var d = C(a), b; for (b in a) d[b] = c.hasOwnProperty(b) ? c[b] : a[b]; return d } function z(a, c) { var d = C(a), b; for (b in c) d[b] = h.und(a[b]) ? c[b] : a[b]; return d } function T(a) { a = a.replace(/^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i, function (a, c, d, k) { return c + c + d + d + k + k }); var c = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(a); a = parseInt(c[1], 16); var d = parseInt(c[2], 16), c = parseInt(c[3], 16); return \u0026#34;rgba(\u0026#34; + a + \u0026#34;,\u0026#34; + d + \u0026#34;,\u0026#34; + c + \u0026#34;,1)\u0026#34; } function U(a) { function c(a, c, b) { 0 \u0026gt; b \u0026amp;\u0026amp; (b += 1); 1 \u0026lt; b \u0026amp;\u0026amp; --b; return b \u0026lt; 1 / 6 ? a + 6 * (c - a) * b : .5 \u0026gt; b ? c : b \u0026lt; 2 / 3 ? a + (c - a) * (2 / 3 - b) * 6 : a } var d = /hsl\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%\\)/g.exec(a) || /hsla\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%,\\s*([\\d.]+)\\)/g.exec(a); a = parseInt(d[1]) / 360; var b = parseInt(d[2]) / 100, f = parseInt(d[3]) / 100, d = d[4] || 1; if (0 == b) f = b = a = f; else { var n = .5 \u0026gt; f ? f * (1 + b) : f + b - f * b, k = 2 * f - n, f = c(k, n, a + 1 / 3), b = c(k, n, a); a = c(k, n, a - 1 / 3) } return \u0026#34;rgba(\u0026#34; + 255 * f + \u0026#34;,\u0026#34; + 255 * b + \u0026#34;,\u0026#34; + 255 * a + \u0026#34;,\u0026#34; + d + \u0026#34;)\u0026#34; } function y(a) { if (a = /([\\+\\-]?[0-9#\\.]+)(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(a)) return a[2] } function V(a) { if (-1 \u0026lt; a.indexOf(\u0026#34;translate\u0026#34;) || \u0026#34;perspective\u0026#34; === a) return \u0026#34;px\u0026#34;; if (-1 \u0026lt; a.indexOf(\u0026#34;rotate\u0026#34;) || -1 \u0026lt; a.indexOf(\u0026#34;skew\u0026#34;)) return \u0026#34;deg\u0026#34; } function I(a, c) { return h.fnc(a) ? a(c.target, c.id, c.total) : a } function E(a, c) { if (c in a.style) return getComputedStyle(a).getPropertyValue(c.replace(/([a-z])([A-Z])/g, \u0026#34;$1-$2\u0026#34;).toLowerCase()) || \u0026#34;0\u0026#34; } function J(a, c) { if (h.dom(a) \u0026amp;\u0026amp; u(W, c)) return \u0026#34;transform\u0026#34;; if (h.dom(a) \u0026amp;\u0026amp; (a.getAttribute(c) || h.svg(a) \u0026amp;\u0026amp; a[c])) return \u0026#34;attribute\u0026#34;; if (h.dom(a) \u0026amp;\u0026amp; \u0026#34;transform\u0026#34; !== c \u0026amp;\u0026amp; E(a, c)) return \u0026#34;css\u0026#34;; if (null != a[c]) return \u0026#34;object\u0026#34; } function X(a, c) { var d = V(c), d = -1 \u0026lt; c.indexOf(\u0026#34;scale\u0026#34;) ? 1 : 0 + d; a = a.style.transform; if (!a) return d; for (var b = [], f = [], n = [], k = /(\\w+)\\((.+?)\\)/g; b = k.exec(a);) f.push(b[1]), n.push(b[2]); a = r(n, function (a, b) { return f[b] === c }); return a.length ? a[0] : d } function K(a, c) { switch (J(a, c)) { case \u0026#34;transform\u0026#34;: return X(a, c); case \u0026#34;css\u0026#34;: return E(a, c); case \u0026#34;attribute\u0026#34;: return a.getAttribute(c) } return a[c] || 0 } function L(a, c) { var d = /^(\\*=|\\+=|-=)/.exec(a); if (!d) return a; var b = y(a) || 0; c = parseFloat(c); a = parseFloat(a.replace(d[0], \u0026#34;\u0026#34;)); switch (d[0][0]) { case \u0026#34;+\u0026#34;: return c + a + b; case \u0026#34;-\u0026#34;: return c - a + b; case \u0026#34;*\u0026#34;: return c * a + b } } function F(a, c) { return Math.sqrt(Math.pow(c.x - a.x, 2) + Math.pow(c.y - a.y, 2)) } function M(a) { a = a.points; for (var c = 0, d, b = 0; b \u0026lt; a.numberOfItems; b++) { var f = a.getItem(b); 0 \u0026lt; b \u0026amp;\u0026amp; (c += F(d, f)); d = f } return c } function N(a) { if (a.getTotalLength) return a.getTotalLength(); switch (a.tagName.toLowerCase()) { case \u0026#34;circle\u0026#34;: return 2 * Math.PI * a.getAttribute(\u0026#34;r\u0026#34;); case \u0026#34;rect\u0026#34;: return 2 * a.getAttribute(\u0026#34;width\u0026#34;) + 2 * a.getAttribute(\u0026#34;height\u0026#34;); case \u0026#34;line\u0026#34;: return F({ x: a.getAttribute(\u0026#34;x1\u0026#34;), y: a.getAttribute(\u0026#34;y1\u0026#34;) }, { x: a.getAttribute(\u0026#34;x2\u0026#34;), y: a.getAttribute(\u0026#34;y2\u0026#34;) }); case \u0026#34;polyline\u0026#34;: return M(a); case \u0026#34;polygon\u0026#34;: var c = a.points; return M(a) + F(c.getItem(c.numberOfItems - 1), c.getItem(0)) } } function Y(a, c) { function d(b) { b = void 0 === b ? 0 : b; return a.el.getPointAtLength(1 \u0026lt;= c + b ? c + b : 0) } var b = d(), f = d(-1), n = d(1); switch (a.property) { case \u0026#34;x\u0026#34;: return b.x; case \u0026#34;y\u0026#34;: return b.y; case \u0026#34;angle\u0026#34;: return 180 * Math.atan2(n.y - f.y, n.x - f.x) / Math.PI } } function O(a, c) { var d = /-?\\d*\\.?\\d+/g, b; b = h.pth(a) ? a.totalLength : a; if (h.col(b)) if (h.rgb(b)) { var f = /rgb\\((\\d+,\\s*[\\d]+,\\s*[\\d]+)\\)/g.exec(b); b = f ? \u0026#34;rgba(\u0026#34; + f[1] + \u0026#34;,1)\u0026#34; : b } else b = h.hex(b) ? T(b) : h.hsl(b) ? U(b) : void 0; else f = (f = y(b)) ? b.substr(0, b.length - f.length) : b, b = c \u0026amp;\u0026amp; !/\\s/g.test(b) ? f + c : f; b += \u0026#34;\u0026#34;; return { original: b, numbers: b.match(d) ? b.match(d).map(Number) : [0], strings: h.str(a) || c ? b.split(d) : [] } } function P(a) { a = a ? p(h.arr(a) ? a.map(m) : m(a)) : []; return r(a, function (a, d, b) { return b.indexOf(a) === d }) } function Z(a) { var c = P(a); return c.map(function (a, b) { return { target: a, id: b, total: c.length } }) } function aa(a, c) { var d = C(c); if (h.arr(a)) { var b = a.length; 2 !== b || h.obj(a[0]) ? h.fnc(c.duration) || (d.duration = c.duration / b) : a = { value: a } } return m(a).map(function (a, b) { b = b ? 0 : c.delay; a = h.obj(a) \u0026amp;\u0026amp; !h.pth(a) ? a : { value: a }; h.und(a.delay) \u0026amp;\u0026amp; (a.delay = b); return a }).map(function (a) { return z(a, d) }) } function ba(a, c) { var d = {}, b; for (b in a) { var f = I(a[b], c); h.arr(f) \u0026amp;\u0026amp; (f = f.map(function (a) { return I(a, c) }), 1 === f.length \u0026amp;\u0026amp; (f = f[0])); d[b] = f } d.duration = parseFloat(d.duration); d.delay = parseFloat(d.delay); return d } function ca(a) { return h.arr(a) ? A.apply(this, a) : Q[a] } function da(a, c) { var d; return a.tweens.map(function (b) { b = ba(b, c); var f = b.value, e = K(c.target, a.name), k = d ? d.to.original : e, k = h.arr(f) ? f[0] : k, w = L(h.arr(f) ? f[1] : f, k), e = y(w) || y(k) || y(e); b.from = O(k, e); b.to = O(w, e); b.start = d ? d.end : a.offset; b.end = b.start + b.delay + b.duration; b.easing = ca(b.easing); b.elasticity = (1E3 - Math.min(Math.max(b.elasticity, 1), 999)) / 1E3; b.isPath = h.pth(f); b.isColor = h.col(b.from.original); b.isColor \u0026amp;\u0026amp; (b.round = 1); return d = b }) } function ea(a, c) { return r(p(a.map(function (a) { return c.map(function (b) { var c = J(a.target, b.name); if (c) { var d = da(b, a); b = { type: c, property: b.name, animatable: a, tweens: d, duration: d[d.length - 1].end, delay: d[0].delay } } else b = void 0; return b }) })), function (a) { return !h.und(a) }) } function R(a, c, d, b) { var f = \u0026#34;delay\u0026#34; === a; return c.length ? (f ? Math.min : Math.max).apply(Math, c.map(function (b) { return b[a] })) : f ? b.delay : d.offset + b.delay + b.duration } function fa(a) { var c = D(ga, a), d = D(S, a), b = Z(a.targets), f = [], e = z(c, d), k; for (k in a) e.hasOwnProperty(k) || \u0026#34;targets\u0026#34; === k || f.push({ name: k, offset: e.offset, tweens: aa(a[k], d) }); a = ea(b, f); return z(c, { children: [], animatables: b, animations: a, duration: R(\u0026#34;duration\u0026#34;, a, c, d), delay: R(\u0026#34;delay\u0026#34;, a, c, d) }) } function q(a) { function c() { return window.Promise \u0026amp;\u0026amp; new Promise(function (a) { return p = a }) } function d(a) { return g.reversed ? g.duration - a : a } function b(a) { for (var b = 0, c = {}, d = g.animations, f = d.length; b \u0026lt; f;) { var e = d[b], k = e.animatable, h = e.tweens, n = h.length - 1, l = h[n]; n \u0026amp;\u0026amp; (l = r(h, function (b) { return a \u0026lt; b.end })[0] || l); for (var h = Math.min(Math.max(a - l.start - l.delay, 0), l.duration) / l.duration, w = isNaN(h) ? 1 : l.easing(h, l.elasticity), h = l.to.strings, p = l.round, n = [], m = void 0, m = l.to.numbers.length, t = 0; t \u0026lt; m; t++) { var x = void 0, x = l.to.numbers[t], q = l.from.numbers[t], x = l.isPath ? Y(l.value, w * x) : q + w * (x - q); p \u0026amp;\u0026amp; (l.isColor \u0026amp;\u0026amp; 2 \u0026lt; t || (x = Math.round(x * p) / p)); n.push(x) } if (l = h.length) for (m = h[0], w = 0; w \u0026lt; l; w++) p = h[w + 1], t = n[w], isNaN(t) || (m = p ? m + (t + p) : m + (t + \u0026#34; \u0026#34;)); else m = n[0]; ha[e.type](k.target, e.property, m, c, k.id); e.currentValue = m; b++ } if (b = Object.keys(c).length) for (d = 0; d \u0026lt; b; d++) H || (H = E(document.body, \u0026#34;transform\u0026#34;) ? \u0026#34;transform\u0026#34; : \u0026#34;-webkit-transform\u0026#34;), g.animatables[d].target.style[H] = c[d].join(\u0026#34; \u0026#34;); g.currentTime = a; g.progress = a / g.duration * 100 } function f(a) { if (g[a]) g[a](g) } function e() { g.remaining \u0026amp;\u0026amp; !0 !== g.remaining \u0026amp;\u0026amp; g.remaining-- } function k(a) { var k = g.duration, n = g.offset, w = n + g.delay, r = g.currentTime, x = g.reversed, q = d(a); if (g.children.length) { var u = g.children, v = u.length; if (q \u0026gt;= g.currentTime) for (var G = 0; G \u0026lt; v; G++) u[G].seek(q); else for (; v--;) u[v].seek(q) } if (q \u0026gt;= w || !k) g.began || (g.began = !0, f(\u0026#34;begin\u0026#34;)), f(\u0026#34;run\u0026#34;); if (q \u0026gt; n \u0026amp;\u0026amp; q \u0026lt; k) b(q); else if (q \u0026lt;= n \u0026amp;\u0026amp; 0 !== r \u0026amp;\u0026amp; (b(0), x \u0026amp;\u0026amp; e()), q \u0026gt;= k \u0026amp;\u0026amp; r !== k || !k) b(k), x || e(); f(\u0026#34;update\u0026#34;); a \u0026gt;= k \u0026amp;\u0026amp; (g.remaining ? (t = h, \u0026#34;alternate\u0026#34; === g.direction \u0026amp;\u0026amp; (g.reversed = !g.reversed)) : (g.pause(), g.completed || (g.completed = !0, f(\u0026#34;complete\u0026#34;), \u0026#34;Promise\u0026#34; in window \u0026amp;\u0026amp; (p(), m = c()))), l = 0) } a = void 0 === a ? {} : a; var h, t, l = 0, p = null, m = c(), g = fa(a); g.reset = function () { var a = g.direction, c = g.loop; g.currentTime = 0; g.progress = 0; g.paused = !0; g.began = !1; g.completed = !1; g.reversed = \u0026#34;reverse\u0026#34; === a; g.remaining = \u0026#34;alternate\u0026#34; === a \u0026amp;\u0026amp; 1 === c ? 2 : c; b(0); for (a = g.children.length; a--;) g.children[a].reset() }; g.tick = function (a) { h = a; t || (t = h); k((l + h - t) * q.speed) }; g.seek = function (a) { k(d(a)) }; g.pause = function () { var a = v.indexOf(g); - 1 \u0026lt; a \u0026amp;\u0026amp; v.splice(a, 1); g.paused = !0 }; g.play = function () { g.paused \u0026amp;\u0026amp; (g.paused = !1, t = 0, l = d(g.currentTime), v.push(g), B || ia()) }; g.reverse = function () { g.reversed = !g.reversed; t = 0; l = d(g.currentTime) }; g.restart = function () { g.pause(); g.reset(); g.play() }; g.finished = m; g.reset(); g.autoplay \u0026amp;\u0026amp; g.play(); return g } var ga = { update: void 0, begin: void 0, run: void 0, complete: void 0, loop: 1, direction: \u0026#34;normal\u0026#34;, autoplay: !0, offset: 0 }, S = { duration: 1E3, delay: 0, easing: \u0026#34;easeOutElastic\u0026#34;, elasticity: 500, round: 0 }, W = \u0026#34;translateX translateY translateZ rotate rotateX rotateY rotateZ scale scaleX scaleY scaleZ skewX skewY perspective\u0026#34;.split(\u0026#34; \u0026#34;), H, h = { arr: function (a) { return Array.isArray(a) }, obj: function (a) { return -1 \u0026lt; Object.prototype.toString.call(a).indexOf(\u0026#34;Object\u0026#34;) }, pth: function (a) { return h.obj(a) \u0026amp;\u0026amp; a.hasOwnProperty(\u0026#34;totalLength\u0026#34;) }, svg: function (a) { return a instanceof SVGElement }, dom: function (a) { return a.nodeType || h.svg(a) }, str: function (a) { return \u0026#34;string\u0026#34; === typeof a }, fnc: function (a) { return \u0026#34;function\u0026#34; === typeof a }, und: function (a) { return \u0026#34;undefined\u0026#34; === typeof a }, hex: function (a) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a) }, rgb: function (a) { return /^rgb/.test(a) }, hsl: function (a) { return /^hsl/.test(a) }, col: function (a) { return h.hex(a) || h.rgb(a) || h.hsl(a) } }, A = function () { function a(a, d, b) { return (((1 - 3 * b + 3 * d) * a + (3 * b - 6 * d)) * a + 3 * d) * a } return function (c, d, b, f) { if (0 \u0026lt;= c \u0026amp;\u0026amp; 1 \u0026gt;= c \u0026amp;\u0026amp; 0 \u0026lt;= b \u0026amp;\u0026amp; 1 \u0026gt;= b) { var e = new Float32Array(11); if (c !== d || b !== f) for (var k = 0; 11 \u0026gt; k; ++k) e[k] = a(.1 * k, c, b); return function (k) { if (c === d \u0026amp;\u0026amp; b === f) return k; if (0 === k) return 0; if (1 === k) return 1; for (var h = 0, l = 1; 10 !== l \u0026amp;\u0026amp; e[l] \u0026lt;= k; ++l) h += .1; --l; var l = h + (k - e[l]) / (e[l + 1] - e[l]) * .1, n = 3 * (1 - 3 * b + 3 * c) * l * l + 2 * (3 * b - 6 * c) * l + 3 * c; if (.001 \u0026lt;= n) { for (h = 0; 4 \u0026gt; h; ++h) { n = 3 * (1 - 3 * b + 3 * c) * l * l + 2 * (3 * b - 6 * c) * l + 3 * c; if (0 === n) break; var m = a(l, c, b) - k, l = l - m / n } k = l } else if (0 === n) k = l; else { var l = h, h = h + .1, g = 0; do m = l + (h - l) / 2, n = a(m, c, b) - k, 0 \u0026lt; n ? h = m : l = m; while (1e-7 \u0026lt; Math.abs(n) \u0026amp;\u0026amp; 10 \u0026gt; ++g); k = m } return a(k, d, f) } } } }(), Q = function () { function a(a, b) { return 0 === a || 1 === a ? a : -Math.pow(2, 10 * (a - 1)) * Math.sin(2 * (a - 1 - b / (2 * Math.PI) * Math.asin(1)) * Math.PI / b) } var c = \u0026#34;Quad Cubic Quart Quint Sine Expo Circ Back Elastic\u0026#34;.split(\u0026#34; \u0026#34;), d = { In: [ [.55, .085, .68, .53], [.55, .055, .675, .19], [.895, .03, .685, .22], [.755, .05, .855, .06], [.47, 0, .745, .715], [.95, .05, .795, .035], [.6, .04, .98, .335], [.6, -.28, .735, .045], a ], Out: [ [.25, .46, .45, .94 ], [.215, .61, .355, 1], [.165, .84, .44, 1], [.23, 1, .32, 1], [.39, .575, .565, 1], [.19, 1, .22, 1], [.075, .82, .165, 1], [.175, .885, .32, 1.275], function (b, c) { return 1 - a(1 - b, c) } ], InOut: [ [.455, .03, .515, .955], [.645, .045, .355, 1], [.77, 0, .175, 1], [.86, 0, .07, 1], [.445, .05, .55, .95], [1, 0, 0, 1], [.785, .135, .15, .86], [.68, -.55, .265, 1.55], function (b, c) { return .5 \u0026gt; b ? a(2 * b, c) / 2 : 1 - a(-2 * b + 2, c) / 2 } ] }, b = { linear: A(.25, .25, .75, .75) }, f = {}, e; for (e in d) f.type = e, d[f.type].forEach(function (a) { return function (d, f) { b[\u0026#34;ease\u0026#34; + a.type + c[f]] = h.fnc(d) ? d : A.apply($jscomp$this, d) } }(f)), f = { type: f.type }; return b }(), ha = { css: function (a, c, d) { return a.style[c] = d }, attribute: function (a, c, d) { return a.setAttribute(c, d) }, object: function (a, c, d) { return a[c] = d }, transform: function (a, c, d, b, f) { b[f] || (b[f] = []); b[f].push(c + \u0026#34;(\u0026#34; + d + \u0026#34;)\u0026#34;) } }, v = [], B = 0, ia = function () { function a() { B = requestAnimationFrame(c) } function c(c) { var b = v.length; if (b) { for (var d = 0; d \u0026lt; b;) v[d] \u0026amp;\u0026amp; v[d].tick(c), d++; a() } else cancelAnimationFrame(B), B = 0 } return a }(); q.version = \u0026#34;2.2.0\u0026#34;; q.speed = 1; q.running = v; q.remove = function (a) { a = P(a); for (var c = v.length; c--;) for (var d = v[c], b = d.animations, f = b.length; f--;) u(a, b[f].animatable.target) \u0026amp;\u0026amp; (b.splice(f, 1), b.length || d.pause()) }; q.getValue = K; q.path = function (a, c) { var d = h.str(a) ? e(a)[0] : a, b = c || 100; return function (a) { return { el: d, property: a, totalLength: N(d) * (b / 100) } } }; q.setDashoffset = function (a) { var c = N(a); a.setAttribute(\u0026#34;stroke-dasharray\u0026#34;, c); return c }; q.bezier = A; q.easings = Q; q.timeline = function (a) { var c = q(a); c.pause(); c.duration = 0; c.add = function (d) { c.children.forEach(function (a) { a.began = !0; a.completed = !0 }); m(d).forEach(function (b) { var d = z(b, D(S, a || {})); d.targets = d.targets || a.targets; b = c.duration; var e = d.offset; d.autoplay = !1; d.direction = c.direction; d.offset = h.und(e) ? b : L(e, b); c.began = !0; c.completed = !0; c.seek(d.offset); d = q(d); d.began = !0; d.completed = !0; d.duration \u0026gt; b \u0026amp;\u0026amp; (c.duration = d.duration); c.children.push(d) }); c.seek(0); c.reset(); c.autoplay \u0026amp;\u0026amp; c.restart(); return c }; return c }; q.random = function (a, c) { return Math.floor(Math.random() * (c - a + 1)) + a }; return q }); 3.修改layouts_default\\baseof.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!-- //鼠标动画 --\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .fireworks { position: fixed; pointer-events: none; top: 0; left: 0; height: 100%; } \u0026lt;/style\u0026gt; \u0026lt;canvas class=\u0026#34;fireworks\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;script src=\u0026#34;/js/anime.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;/js/fireworks.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- \u0026lt;script src=\u0026#34;/js/mouseClick.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; fireworks.setCanvasSize(); \u0026lt;/script\u0026gt; /* \u0026lt;!DOCTYPE html\u0026gt; .... */ 2.未解决的问题 博客内容实现可折叠功能 right sidebar 的 categories wideget 样式修改实现小标签化，并一行双栏或多栏展示 博客内，right sidebar 目录的数字编号重复问题 博客内，目录太长时，没有滚动条 3.引入插件 3.1 cusdis 评论系统 cudis官方文档\n1 A bunch of code here 制作一个封面图生成工具 自定义脑图shortcode\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote ","date":"2024-07-01T23:29:20+08:00","image":"https://4evergreat.github.io/cover/014b0b5c7e1b6ba801203d229d9893.jpg@3000w_1l_0o_100sh.jpg","permalink":"https://4evergreat.github.io/2024/hugo-blog-4/","title":"hugo-blog-4网站插件安装与性能优化"},{"content":"hugo博客推送到服务器 1 2 3 4 5 6 7 8 9 10 11 12 13 //先回顾一下博客路径文件夹的结构 myblog/ ├── archetypes/ │ └── default.md ├── assets/ ├── public/ \u0026lt;-- 步骤3后生成的文件夹，里面存放对外展示的静态博客网页 ├── content/ ├── data/ ├── i18n/ ├── layouts/ ├── static/ ├── themes/ \u0026lt;-- 主题 └── hugo.toml \u0026lt;-- 网站参数 1.推送到git服务器 1 2 3 4 5 6 7 8 9 10 cd public/ git init git add . git commit -m \u0026#34;备注\u0026#34; //使用 git remote add 命令将远程仓库添加到仓库配置中 git remote add origin https://github.com/your-username/your-repo.git //--\u0026gt;仓库链接 //（非固定方式，确保能提交过去就行）使用 SSH 连接后，可以使用 SSH URL 推送到 GitHub 仓库 git remote set-url origin git@github.com:your-username/your-repo.git //推送文件 git push -u origin master 注意事项：\n推送的文件过大时，需要自己去action那里找到pages-build-deployment选项，选择重新构建。\n2.后续提交其他内容 1 2 3 4 5 6 7 8 #检查是否有改变 git status #提交到缓存区 git add . #提交到版本库，并备注修改内容 git commit -m \u0026#34;new\u0026#34; #推送到远程仓库 git push ","date":"2024-07-01T23:27:20+08:00","image":"https://4evergreat.github.io/cover/R.jpg","permalink":"https://4evergreat.github.io/2024/hugo-blog-3/","title":"hugo-blog-3hugo博客推送到服务器"},{"content":"本地搭建hugo网站 1.初始化hugo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 hugo new site 博客路径 // cd 博客路径 //博客路径文件夹的结构如下 myblog/ ├── archetypes/ │ └── default.md ├── assets/ ├── public/ \u0026lt;-- 步骤3后生成的文件夹，里面存放对外展示的静态博客网页 ├── content/ ├── data/ ├── i18n/ ├── layouts/ ├── static/ ├── themes/ \u0026lt;-- 主题 └── hugo.toml \u0026lt;-- 网站参数 2. 配置主题themes 方式一： git\n1 2 cd themes/ git clone https://github.com/author/theme-name.git themes/theme-name 方式二： 下载包手动解压\n把主题的包压到themes/文件夹下，之后对hugo.toml文件进行一点过的修改。个人推荐stack主题。\n修改 hugo.toml文件\n1 2 theme = \u0026#34;my-theme\u0026#34; // my-theme是你下载的theme的主题名，要和你解压的文件名一致 3.生成网站和第一篇博客 1 2 3 4 5 6 cd myblog/ --\u0026gt;博客路径 # 打开cmd输入以下命令： hugo #之后博客文件路径会产生一个public/文件夹，里面保存生成的静态页面。 # 生成一篇 .md 博客 hugo new content_type/content_name.md 上述步骤后会在\\myblog\\content\\content_type\\ 文件夹中生成 我们的第一篇博客 content_name.md， 博客内容在文件 content_name.md 中编辑即可。\n4.本地浏览器预览网页 1 2 3 hugo server # 打开以下网页预览 http://localhost:1313 5.放在最后！ 5.1配置hugo.toml 下载好主题后，主题的 exampleSite 目录一般会有一个 config.toml 配置文件，根据注释做一些基本的修改，再复制到你的根目录下的 config.tmol 文件。博客原文这个博客直接给出修改后的 config 文件，可以拿来学习配置的注释。注意到这个博客用的是LoveIt主题，而我建站使用的是stack主题，所以后续个性化我的博客后，我会在后面贴出我的配置以供参考。持续更新中\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 baseURL = \u0026#34;https://your-domain.org\u0026#34; # 更改使用 Hugo 构建网站时使用的默认主题 theme = \u0026#34;LoveIt\u0026#34; # 网站标题 title = \u0026#34;Stilig\u0026#34; defaultContentLanguage = \u0026#34;zh-cn\u0026#34; # 网站语言, 仅在这里 CN 大写 [\u0026#34;en\u0026#34;, \u0026#34;zh-CN\u0026#34;, \u0026#34;fr\u0026#34;, \u0026#34;pl\u0026#34;, ...] languageCode = \u0026#34;zh-CN\u0026#34; # 语言名称 [\u0026#34;English\u0026#34;, \u0026#34;简体中文\u0026#34;, \u0026#34;Français\u0026#34;, \u0026#34;Polski\u0026#34;, ...] languageName = \u0026#34;简体中文\u0026#34; # 是否包括中日韩文字 hasCJKLanguage = true # 默认每页列表显示的文章数目 paginate = 12 # 谷歌分析代号 [UA-XXXXXXXX-X] googleAnalytics = \u0026#34;\u0026#34; # 版权描述，仅仅用于 SEO copyright = \u0026#34;\u0026#34; # 是否使用 robots.txt enableRobotsTXT = true # 是否使用 git 信息 #enableGitInfo = true # 是否使用 emoji 代码 enableEmoji = true # 忽略一些构建错误 ignoreErrors = [\u0026#34;error-remote-getjson\u0026#34;, \u0026#34;error-missing-instagram-accesstoken\u0026#34;] # 作者配置 [author] name = \u0026#34;Stilig\u0026#34; email = \u0026#34;your_email\u0026#34; # 菜单配置 [menu] [[menu.main]] weight = 1 identifier = \u0026#34;posts\u0026#34; # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \u0026#34;\u0026#34; # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \u0026#34;\u0026#34; name = \u0026#34;文章\u0026#34; url = \u0026#34;/posts/\u0026#34; # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \u0026#34;\u0026#34; [[menu.main]] weight = 2 identifier = \u0026#34;tags\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;标签\u0026#34; url = \u0026#34;/tags/\u0026#34; title = \u0026#34;\u0026#34; [[menu.main]] weight = 3 identifier = \u0026#34;categories\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;分类\u0026#34; url = \u0026#34;/categories/\u0026#34; title = \u0026#34;\u0026#34; # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) codeFences = true guessSyntax = true lineNos = true lineNumbersInTable = true # false 是必要的设置 # (https://github.com/dillonzq/LoveIt/issues/158) # Goldmark 是 Hugo 0.60 以来的默认 Markdown 解析库 noClasses = false # Goldmark 是 Hugo 0.60 以来的默认 Markdown 解析库 [markup.goldmark] [markup.goldmark.extensions] definitionList = true footnote = true linkify = true strikethrough = true table = true taskList = true typographer = true [markup.goldmark.renderer] # 是否在文档中直接使用 HTML 标签 unsafe = true # 目录设置 [markup.tableOfContents] startLevel = 2 endLevel = 6 [params] # 网站默认主题样式 [\u0026#34;auto\u0026#34;, \u0026#34;light\u0026#34;, \u0026#34;dark\u0026#34;] defaultTheme = \u0026#34;light\u0026#34; # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 #gitRepo = \u0026#34;\u0026#34; # LoveIt 新增 | 0.1.1 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # [\u0026#34;sha256\u0026#34;, \u0026#34;sha384\u0026#34;, \u0026#34;sha512\u0026#34;, \u0026#34;md5\u0026#34;] fingerprint = \u0026#34;sha256\u0026#34; # LoveIt 新增 | 0.2.0 日期格式 dateFormat = \u0026#34;2006-01-02\u0026#34; # 网站标题, 用于 Open Graph 和 Twitter Cards title = \u0026#34;Stilig的博客\u0026#34; # 网站描述, 用于 RSS, SEO, Open Graph 和 Twitter Cards description = \u0026#34;Stilig的博客\u0026#34; # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\u0026#34;首页中间的图片\u0026#34;] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 [\u0026#34;fixed\u0026#34;, \u0026#34;normal\u0026#34;, \u0026#34;auto\u0026#34;] desktopMode = \u0026#34;normal\u0026#34; # 移动端导航栏模式 [\u0026#34;fixed\u0026#34;, \u0026#34;normal\u0026#34;, \u0026#34;auto\u0026#34;] mobileMode = \u0026#34;normal\u0026#34; # LoveIt 新增 | 0.2.0 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \u0026#34;\u0026#34; # 标题名称 name = \u0026#34;Stilig\u0026#34; # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \u0026#34;\u0026#34; # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \u0026#34;\u0026#34; # LoveIt 新增 | 0.2.5 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # LoveIt 新增 | 0.2.0 自定义内容 (支持 HTML 格式) custom = \u0026#39;\u0026#39; # LoveIt 新增 | 0.2.0 是否显示 Hugo 和主题信息 hugo = false # LoveIt 新增 | 0.2.0 是否显示版权信息 copyright = true # LoveIt 新增 | 0.2.0 是否显示作者 author = true # 网站创立年份 since = 2022 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \u0026#39;\u0026#39; # 许可协议信息 (支持 HTML 格式) license = \u0026#39;\u0026lt;a rel=\u0026#34;license external nofollow noopener noreffer\u0026#34; href=\u0026#34;https://creativecommons.org/licenses/by-nc/4.0/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;CC BY-NC 4.0\u0026lt;/a\u0026gt;\u0026#39; # LoveIt 新增 | 0.2.0 Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \u0026#34;01-02\u0026#34; # RSS 文章数目 rss = 10 # LoveIt 新增 | 0.2.0 List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \u0026#34;01-02\u0026#34; # RSS 文章数目 rss = 10 # LoveIt 新增 | 0.2.0 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \u0026#34;\u0026#34; # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \u0026#34;\u0026#34; # Android 浏览器主题色 themeColor = \u0026#34;#ffffff\u0026#34; # Safari 图标颜色 iconColor = \u0026#34;#5bbad5\u0026#34; # Windows v8-10磁贴颜色 tileColor = \u0026#34;#da532c\u0026#34; # LoveIt 新增 | 0.2.0 搜索配置 [params.search] enable = true # 搜索引擎的类型 [\u0026#34;lunr\u0026#34;, \u0026#34;algolia\u0026#34;] type = \u0026#34;algolia\u0026#34; # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \u0026#34;\u0026#34; # LoveIt 新增 | 0.2.1 最大结果数目 maxResultLength = 10 # LoveIt 新增 | 0.2.3 结果内容片段长度 snippetLength = 50 # LoveIt 新增 | 0.2.1 搜索结果中高亮部分的 HTML 标签 highlightTag = \u0026#34;em\u0026#34; # LoveIt 新增 | 0.2.4 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false ##注册使用，前往：https://www.algolia.com/ [params.search.algolia] index = \u0026#34;\u0026#34; appID = \u0026#34;\u0026#34; searchKey = \u0026#34;\u0026#34; # 主页配置 [params.home] # LoveIt 新增 | 0.2.0 RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \u0026#34;\u0026#34; # 主页显示头像的 URL avatarURL = \u0026#34;\u0026#34; # LoveIt 更改 | 0.2.7 主页显示的网站标题 (支持 HTML 格式) title = \u0026#34;\u0026#34; # 主页显示的网站副标题 (允许 HTML 格式) subtitle = \u0026#34;欢迎来到我的博客\u0026#34; # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # LoveIt 新增 | 0.2.0 免责声明 (支持 HTML 格式) disclaimer = \u0026#34;\u0026#34; # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # LoveIt 删除 | 0.2.0 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \u0026#34;hiddenFromHomePage\u0026#34; 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \u0026#34;\u0026#34; Linkedin = \u0026#34;\u0026#34; Twitter = \u0026#34;\u0026#34; Instagram = \u0026#34;\u0026#34; Facebook = \u0026#34;\u0026#34; Telegram = \u0026#34;\u0026#34; Medium = \u0026#34;\u0026#34; Gitlab = \u0026#34;\u0026#34; Youtubelegacy = \u0026#34;\u0026#34; Youtubecustom = \u0026#34;\u0026#34; Youtubechannel = \u0026#34;\u0026#34; Tumblr = \u0026#34;\u0026#34; Quora = \u0026#34;\u0026#34; Keybase = \u0026#34;\u0026#34; Pinterest = \u0026#34;\u0026#34; Reddit = \u0026#34;\u0026#34; Codepen = \u0026#34;\u0026#34; FreeCodeCamp = \u0026#34;\u0026#34; Bitbucket = \u0026#34;\u0026#34; Stackoverflow = \u0026#34;\u0026#34; Weibo = \u0026#34;\u0026#34; Odnoklassniki = \u0026#34;\u0026#34; VK = \u0026#34;\u0026#34; Flickr = \u0026#34;\u0026#34; Xing = \u0026#34;\u0026#34; Snapchat = \u0026#34;\u0026#34; Soundcloud = \u0026#34;\u0026#34; Spotify = \u0026#34;\u0026#34; Bandcamp = \u0026#34;\u0026#34; Paypal = \u0026#34;\u0026#34; Fivehundredpx = \u0026#34;\u0026#34; Mix = \u0026#34;\u0026#34; Goodreads = \u0026#34;\u0026#34; Lastfm = \u0026#34;\u0026#34; Foursquare = \u0026#34;\u0026#34; Hackernews = \u0026#34;\u0026#34; Kickstarter = \u0026#34;\u0026#34; Patreon = \u0026#34;\u0026#34; Steam = \u0026#34;\u0026#34; Twitch = \u0026#34;\u0026#34; Strava = \u0026#34;\u0026#34; Skype = \u0026#34;\u0026#34; Whatsapp = \u0026#34;\u0026#34; Zhihu = \u0026#34;\u0026#34; Douban = \u0026#34;\u0026#34; Angellist = \u0026#34;\u0026#34; Slidershare = \u0026#34;\u0026#34; Jsfiddle = \u0026#34;\u0026#34; Deviantart = \u0026#34;\u0026#34; Behance = \u0026#34;\u0026#34; Dribbble = \u0026#34;\u0026#34; Wordpress = \u0026#34;\u0026#34; Vine = \u0026#34;\u0026#34; Googlescholar = \u0026#34;\u0026#34; Researchgate = \u0026#34;\u0026#34; Mastodon = \u0026#34;\u0026#34; Thingiverse = \u0026#34;\u0026#34; Devto = \u0026#34;\u0026#34; Gitea = \u0026#34;\u0026#34; XMPP = \u0026#34;\u0026#34; Matrix = \u0026#34;\u0026#34; Bilibili = \u0026#34;\u0026#34; Discord = \u0026#34;\u0026#34; DiscordInvite = \u0026#34;\u0026#34; Lichess = \u0026#34;\u0026#34; ORCID = \u0026#34;\u0026#34; Pleroma = \u0026#34;\u0026#34; Kaggle = \u0026#34;\u0026#34; MediaWiki= \u0026#34;\u0026#34; Plume = \u0026#34;\u0026#34; HackTheBox = \u0026#34;\u0026#34; RootMe= \u0026#34;\u0026#34; Phone = \u0026#34;\u0026#34; Email = \u0026#34;\u0026#34; RSS = true # LoveIt 新增 | 0.2.0 # LoveIt 更改 | 0.2.0 文章页面全局配置 [params.page] # LoveIt 新增 | 0.2.0 是否在主页隐藏一篇文章 hiddenFromHomePage = false # LoveIt 新增 | 0.2.0 是否在搜索结果中隐藏一篇文章 hiddenFromSearch = false # LoveIt 新增 | 0.2.0 是否使用 twemoji twemoji = false # 是否使用 lightgallery lightgallery = false # LoveIt 新增 | 0.2.0 是否使用 ruby 扩展语法 ruby = true # LoveIt 新增 | 0.2.0 是否使用 fraction 扩展语法 fraction = true # LoveIt 新增 | 0.2.0 是否使用 fontawesome 扩展语法 fontawesome = true # 是否在文章页面显示原始 Markdown 文档链接 linkToMarkdown = false # LoveIt 新增 | 0.2.4 是否在 RSS 中显示全文内容 rssFullText = false # LoveIt 新增 | 0.2.0 目录配置 [params.page.toc] # 是否使用目录 enable = true # LoveIt 新增 | 0.2.9 是否保持使用文章前面的静态目录 keepStatic = false # 是否使侧边目录自动折叠展开 auto = true # LoveIt 新增 | 0.2.0 代码配置 [params.page.code] # 是否显示代码块的复制按钮 copy = true # 默认展开显示的代码行数 maxShownLines = 50 # LoveIt 更改 | 0.2.0 KaTeX 数学公式 [params.page.math] enable = true # LoveIt 更改 | 0.2.11 默认行内定界符是 $ ... $ 和 \\( ... \\) inlineLeftDelimiter = \u0026#34;\u0026#34; inlineRightDelimiter = \u0026#34;\u0026#34; # LoveIt 更改 | 0.2.11 默认块定界符是 $$ ... $$, \\[ ... \\], \\begin{equation} ... \\end{equation} 和一些其它的函数 blockLeftDelimiter = \u0026#34;\u0026#34; blockRightDelimiter = \u0026#34;\u0026#34; # KaTeX 插件 copy_tex copyTex = true # KaTeX 插件 mhchem mhchem = true # LoveIt 新增 | 0.2.0 Mapbox GL JS 配置 [params.page.mapbox] # Mapbox GL JS 的 access token accessToken = \u0026#34;\u0026#34; # 浅色主题的地图样式 lightStyle = \u0026#34;mapbox://styles/mapbox/light-v10?optimize=true\u0026#34; # 深色主题的地图样式 darkStyle = \u0026#34;mapbox://styles/mapbox/dark-v10?optimize=true\u0026#34; # 是否添加 NavigationControl navigation = true # 是否添加 GeolocateControl geolocate = true # 是否添加 ScaleControl scale = true # 是否添加 FullscreenControl fullscreen = true # LoveIt 更改 | 0.2.0 文章页面的分享信息设置 [params.page.share] enable = true Twitter = true Facebook = true Linkedin = true Whatsapp = false Pinterest = false Tumblr = false HackerNews = false Reddit = false VK = false Buffer = false Xing = false Line = true Instapaper = false Pocket = false Flipboard = false Weibo = true Blogger = false Baidu = false Odnoklassniki = false Evernote = false Skype = false Trello = false Mix = false # LoveIt 更改 | 0.2.0 评论系统设置 [params.page.comment] enable = false # Disqus 评论系统设置 [params.page.comment.disqus] # LoveIt 新增 | 0.1.1 enable = false # Disqus 的 shortname，用来在文章中启用 Disqus 评论系统 shortname = \u0026#34;\u0026#34; # Gitalk 评论系统设置 [params.page.comment.gitalk] # LoveIt 新增 | 0.1.1 enable = false owner = \u0026#34;\u0026#34; repo = \u0026#34;\u0026#34; clientId = \u0026#34;\u0026#34; clientSecret = \u0026#34;\u0026#34; # Valine 评论系统设置 [params.page.comment.valine] enable = false appId = \u0026#34;\u0026#34; appKey = \u0026#34;\u0026#34; placeholder = \u0026#34;\u0026#34; avatar = \u0026#34;mp\u0026#34; meta= \u0026#34;\u0026#34; pageSize = 10 # 为空时自动适配当前主题 i18n 配置 lang = \u0026#34;\u0026#34; visitor = true recordIP = true highlight = true enableQQ = false serverURLs = \u0026#34;\u0026#34; # LoveIt 新增 | 0.2.6 emoji 数据文件名称, 默认是 \u0026#34;google.yml\u0026#34; # [\u0026#34;apple.yml\u0026#34;, \u0026#34;google.yml\u0026#34;, \u0026#34;facebook.yml\u0026#34;, \u0026#34;twitter.yml\u0026#34;] # 位于 \u0026#34;themes/LoveIt/assets/lib/valine/emoji/\u0026#34; 目录 # 可以在你的项目下相同路径存放你自己的数据文件: # \u0026#34;assets/lib/valine/emoji/\u0026#34; emoji = \u0026#34;\u0026#34; # Facebook 评论系统设置 [params.page.comment.facebook] enable = false width = \u0026#34;100%\u0026#34; numPosts = 10 appId = \u0026#34;\u0026#34; # 为空时自动适配当前主题 i18n 配置 languageCode = \u0026#34;zh_CN\u0026#34; # LoveIt 新增 | 0.2.0 Telegram Comments 评论系统设置 [params.page.comment.telegram] enable = false siteID = \u0026#34;\u0026#34; limit = 5 height = \u0026#34;\u0026#34; color = \u0026#34;\u0026#34; colorful = true dislikes = false outlined = false # LoveIt 新增 | 0.2.0 Commento 评论系统设置 [params.page.comment.commento] enable = false # LoveIt 新增 | 0.2.5 utterances 评论系统设置 [params.page.comment.utterances] enable = false # owner/repo repo = \u0026#34;\u0026#34; issueTerm = \u0026#34;pathname\u0026#34; label = \u0026#34;\u0026#34; lightTheme = \u0026#34;github-light\u0026#34; darkTheme = \u0026#34;github-dark\u0026#34; # giscus comment 评论系统设置 (https://giscus.app/zh-CN) [params.page.comment.giscus] # 你可以参考官方文档来使用下列配置 enable = false repo = \u0026#34;\u0026#34; repoId = \u0026#34;\u0026#34; category = \u0026#34;Announcements\u0026#34; categoryId = \u0026#34;\u0026#34; # 为空时自动适配当前主题 i18n 配置 lang = \u0026#34;\u0026#34; mapping = \u0026#34;pathname\u0026#34; reactionsEnabled = \u0026#34;1\u0026#34; emitMetadata = \u0026#34;0\u0026#34; inputPosition = \u0026#34;bottom\u0026#34; lazyLoading = false lightTheme = \u0026#34;light\u0026#34; darkTheme = \u0026#34;dark\u0026#34; # LoveIt 新增 | 0.2.7 第三方库配置 [params.page.library] [params.page.library.css] # someCSS = \u0026#34;some.css\u0026#34; # 位于 \u0026#34;assets/\u0026#34; # 或者 # someCSS = \u0026#34;https://cdn.example.com/some.css\u0026#34; [params.page.library.js] # someJavascript = \u0026#34;some.js\u0026#34; # 位于 \u0026#34;assets/\u0026#34; # 或者 # someJavascript = \u0026#34;https://cdn.example.com/some.js\u0026#34; # LoveIt 更改 | 0.2.10 页面 SEO 配置 [params.page.seo] # 图片 URL images = [] # 出版者信息 [params.page.seo.publisher] name = \u0026#34;\u0026#34; logoUrl = \u0026#34;\u0026#34; # LoveIt 新增 | 0.2.5 TypeIt 配置 [params.typeit] # 每一步的打字速度 (单位是毫秒) speed = 100 # 光标的闪烁速度 (单位是毫秒) cursorSpeed = 1000 # 光标的字符 (支持 HTML 格式) cursorChar = \u0026#34;|\u0026#34; # 打字结束之后光标的持续时间 (单位是毫秒, \u0026#34;-1\u0026#34; 代表无限大) duration = -1 # 网站验证代码，用于 Google/Bing/Yandex/Pinterest/Baidu [params.verification] google = \u0026#34;\u0026#34; bing = \u0026#34;\u0026#34; yandex = \u0026#34;\u0026#34; pinterest = \u0026#34;\u0026#34; baidu = \u0026#34;\u0026#34; # LoveIt 新增 | 0.2.10 网站 SEO 配置 [params.seo] # 图片 URL image = \u0026#34;\u0026#34; # 缩略图 URL thumbnailUrl = \u0026#34;\u0026#34; # LoveIt 新增 | 0.2.0 网站分析配置 [params.analytics] enable = true [params.analytics.google] id = \u0026#34;\u0026#34; # whether to anonymize IP # 是否匿名化用户 IP anonymizeIP = true # Fathom Analytics # 百度统计,自己配置的 [params.analytics.baidu] id = \u0026#34;\u0026#34; # Cookie 许可配置 #[params.cookieconsent] #enable = true # 用于 Cookie 许可横幅的文本字符串 #[params.cookieconsent.content] #message = \u0026#34;\u0026#34; #dismiss = \u0026#34;\u0026#34; #link = \u0026#34;\u0026#34; # 第三方库文件的 CDN 设置 [params.cdn] # CDN 数据文件名称, 默认不启用 # [\u0026#34;jsdelivr.yml\u0026#34;] # 位于 \u0026#34;themes/LoveIt/assets/data/cdn/\u0026#34; 目录 # 可以在你的项目下相同路径存放你自己的数据文件: # \u0026#34;assets/data/cdn/\u0026#34; data = \u0026#34;\u0026#34; # 兼容性设置 [params.compatibility] # 是否使用 Polyfill.io 来兼容旧式浏览器 polyfill = false # 是否使用 object-fit-images 来兼容旧式浏览器 objectFit = false # 网站地图配置 [sitemap] changefreq = \u0026#34;weekly\u0026#34; filename = \u0026#34;sitemap.xml\u0026#34; priority = 0.5 # Permalinks 配置 [Permalinks] # posts = \u0026#34;:year/:month/:filename\u0026#34; posts = \u0026#34;:filename\u0026#34; # 隐私信息配置 [privacy] # Google Analytics 相关隐私 (被 params.analytics.google 替代) [privacy.googleAnalytics] # ... [privacy.twitter] enableDNT = true [privacy.youtube] privacyEnhanced = true # 用于输出 Markdown 格式文档的设置 [mediaTypes] [mediaTypes.\u0026#34;text/plain\u0026#34;] suffixes = [\u0026#34;md\u0026#34;] # 用于输出 Markdown 格式文档的设置 [outputFormats.MarkDown] mediaType = \u0026#34;text/plain\u0026#34; isPlainText = true isHTML = false # 用于 Hugo 输出文档的设置 [outputs] home = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;] page = [\u0026#34;HTML\u0026#34;, \u0026#34;MarkDown\u0026#34;] section = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] taxonomy = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] taxonomyTerm = [\u0026#34;HTML\u0026#34;] 我的配置（使用yaml格式）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 baseurl: https://4evergreat.github.io/ #基础路由 languageCode: zh-cn #语言 title: alwaysGreat\u0026#39;s blog #网站名称 theme: hugo-theme-stack-master #指定主题名 paginate: 10 copyright: alwaysGreat #languages: # zh-cn: # languageName: 中文 # title: 欢迎来看 alwaysGreat 的博客~ #TODO 博客标题 # weight: 2 # Theme i18n support # Available values: ar, bn, ca, de, el, en, es, fr, hu, id, it, ja, ko, nl, pt-br, th, uk, zh-cn, zh-hk, zh-tw DefaultContentLanguage: zh-cn # Set hasCJKLanguage to true if DefaultContentLanguage is in [zh-cn ja ko] # This will make .Summary and .WordCount behave correctly for CJK languages. hasCJKLanguage: true # services: # # Change it to your Disqus shortname before using # disqus: # shortname: \u0026#34;hugo-theme-stack\u0026#34; # # GA Tracking ID # googleAnalytics: # id: permalinks: post: /p/:slug/ #TODO 链接形式 page: /:slug/ params: mainSections: - post featuredImageField: image rssFullContent: true favicon: /static/photo.ico # e.g.: favicon placed in `/favicon.ico` of your site folder, then set this field to `/favicon.ico` (`/` is necessary) footer: since: 2024 #TODO 这里是建站时间 customText: 2024开始使用hugo建站 dateFormat: # published: Jan 02, 2006 # lastUpdated: Jan 02, 2006 15:04 MST published: 01月02日, 2006年 lastUpdated: 01月02日 15点04分, 2006年 sidebar: emoji: 🀄 # 🀄🤺🐇 ☁️ #TODO emoji大全 https://www.emojiall.com/zh-hans/platform-wechat #TODO emoji大全 https://emoji8.com/zh-hans/ subtitle: 在人生中不断诞生新的自己！ #TODO 副标题 avatar: enabled: true local: true #TODO 设置为true使用网络图片 src: /img/head.png article: math: false toc: true readingTime: true license: enabled: true default: Licensed under CC BY-NC-SA 4.0 #TODO 版权标语 comments: enabled: true provider: waline disqusjs: shortname: apiUrl: apiKey: admin: adminLabel: utterances: repo: issueTerm: pathname label: beaudar: repo: issueTerm: pathname label: theme: remark42: host: site: locale: vssue: platform: owner: repo: clientId: clientSecret: autoCreateIssue: false # Waline client configuration see: https://waline.js.org/en/reference/component.html waline: serverURL: #TODO Waline 自行配置 lang: pageview: emoji: - https://unpkg.com/@waline/emojis@1.0.1/weibo - https://cdn.jsdelivr.net/gh/walinejs/emojis/bilibili@1.0.6 requiredMeta: - name - email - url locale: admin: 博主 placeholder: 有什么新点子？（上方留下邮箱可以收到通知哦） twikoo: envId: region: path: lang: # See https://cactus.chat/docs/reference/web-client/#configuration for description of the various options cactus: defaultHomeserverUrl: \u0026#34;https://matrix.cactus.chat:8448\u0026#34; serverName: \u0026#34;cactus.chat\u0026#34; siteName: \u0026#34;\u0026#34; # You must insert a unique identifier here matching the one you registered (See https://cactus.chat/docs/getting-started/quick-start/#register-your-site) giscus: repo: repoID: category: categoryID: mapping: lightTheme: darkTheme: reactionsEnabled: 1 emitMetadata: 0 gitalk: owner: admin: repo: clientID: clientSecret: cusdis: host: id: widgets: homepage: - type: search - type: archives params: limit: 5 - type: timeline params: limit: 10 - type: categories params: limit: 10 - type: tag-cloud params: limit: 50 page: - type: search - type: toc - type: categories params: limit: 10 - type: typeform-widget opengraph: twitter: # Your Twitter username site: # Available values: summary, summary_large_image card: summary_large_image defaultImage: opengraph: enabled: false local: false src: colorScheme: # Display toggle toggle: true # Available values: auto, light, dark default: auto imageProcessing: cover: enabled: true content: enabled: true ### Custom menu ### See https://stack.jimmycai.com/config/menu ### To remove about, archive and search page menu item, remove `menu` field from their FrontMatter menu: main: - identifier: home name: 主页 url: / weight: -90 params: ### For demonstration purpose, the home link will be open in a new tab newTab: false icon: home # - identifier: about # name: 关于 # url: /about/ # weight: -80 # params: # newTab: false # icon: user # - identifier: archives # name: 归档 # url: /archives/ # weight: -70 # params: # newTab: false # icon: archives # - identifier: search # name: 搜索 # url: /search/ # weight: -60 # params: # newTab: false # icon: search # - identifier: tools # name: 工具 # url: /tools/ # weight: -50 # params: # newTab: false # icon: tools # - identifier: friends # name: 朋友 # url:/friends/ # weight: -40 # params: # ### For demonstration purpose, the home link will be open in a new tab # newTab: false # icon: user-group-solid social: - identifier: github name: GitHub url: https://github.com/4evergreat #TODO 这里是你的Github链接 params: icon: brand-github - identifier: travellings name: 开往 url: https://travellings.link params: icon: train-subway-solid newTab: true related: includeNewer: true threshold: 60 toLower: false indices: - name: tags weight: 100 - name: categories weight: 200 markup: goldmark: renderer: ## Set to true if you have HTML content inside Markdown unsafe: true tableOfContents: endLevel: 4 ordered: true startLevel: 2 highlight: noClasses: false codeFences: true guessSyntax: true lineNoStart: 1 lineNos: true lineNumbersInTable: true tabWidth: 4 ignoreErrors: \u0026#34;error-remote-getjson\u0026#34; 5.2 修改默认markdown编译模板 1 2 3 cd \\myblog\\archetypes\\ 修改里面的default.md文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 --- title: \u0026#34;{{ replace .TranslationBaseName \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; subtitle: \u0026#34;\u0026#34; date: {{ .Date }} lastmod: {{ .Date }} draft: true author: \u0026#34;\u0026#34; authorLink: \u0026#34;\u0026#34; license: \u0026#34;\u0026#34; tags: [\u0026#34;\u0026#34;] categories: [\u0026#34;\u0026#34;] featuredImage: \u0026#34;\u0026#34; featuredImagePreview: \u0026#34;\u0026#34; summary: \u0026#34;\u0026#34; hiddenFromHomePage: false hiddenFromSearch: false toc: enable: true auto: true mapbox: share: enable: true comment: enable: true --- ","date":"2024-07-01T22:27:20+08:00","image":"https://4evergreat.github.io/cover/t01d389c22b38efbadc.jpg","permalink":"https://4evergreat.github.io/2024/hugo-blog-2/","title":"hugo-blog-2本地搭建hugo网站"},{"content":"hugo-win10环境的搭建 一、前言 当前市面上的个人博客搭建项目有很多，如wordpress, halo, hexo, hugo等。以下简单聊一聊这几种方案：\n动态博客\nwordpress由php语言开发，使用了mysql作为数据库，属于动态博客，即根据数据库内容动态渲染网页。其官网上提供了许多收费（主）或免费的主题和模板，自带用户界面以及管理后台，上面还提供了丰富的插件扩展，用户可以根据个人喜好进行配置。可见wordpress是一个易用的、动态的、灵活的博客选型方案。但是需要注意的是wordpress加载速度会随插件主题的复杂程增加而变慢，例如市面上用户大量投诉字体加载慢的问题。 halo是一个开源的博客，有java语言开发，使用了springboot框架。也有官方社区论坛，上面提供了一些收费的或免费的主题和模板。支持markdown格式、评论模块、网站统计等丰富的功能。当前这个开源项目还在不断更新当中，学习过java SSM的朋友可以考虑在这个项目的基础上个人再开发定制自己喜欢的内容。需要注意的是，halo使用了java springboot，对服务器内存的需求较大。 静态博客\nhexo是一个基于node.js的静态开源博客框架，支持使用markdown来解析文章。网上可以找到其官网，上面提供了丰富的主题和插件，个人比较推荐butterfly主题。静态的博客的优点与缺点都集中在静态二字，静态意味着网页是预先就编译好的，直接加载已经编译的内容就行，而且无需额外安装数据库也能搭建博客，所以这种方案对服务器的要求很小，搭建环境也比较简单。但是需要注意到静态网页的每个改动都需要重新编译网页。由于博客是静态的，还是用的node.js，特别推荐给学过前端的朋友，博客的外观和风格可以高度个性化！ hugoHugo是一个由Go语言编写的静态网站生成器，它的主要功能是将Markdown或其他格式的内容转换为静态的HTML、CSS和JavaScript文件。这些文件可以直接部署到Web服务器上，从而快速、高效地展示内容。需要注意的是Hugo主要关注于生成静态网站，因此它不支持原生注册登录、原生评论等动态功能。这些功能通常需要依赖第三方服务或插件来实现，对个人动手能力有一定的要求。 关于我为什么选择hugo\n我个人是使用java的，深知 java 虚拟机占用的内存相当可观。个人博客主要是为了记录与分享一些个人学习的内容，没有打算在服务器上花多少钱。也许以后会该也说不定~先这样用着好吧 静态博客的内容保存在本地，方便后期迁移。不怕丢失。可以直接推送到git或者gitee上。 被一款叫stack的主题吸引，淡雅的风格。(全在我的审美点上，简直是梦中情博！！！ 二、在windows10上搭建hugo环境 1. 下载安装git、go并安装 go下载链接\ngit下载链接\n注意事项！！！！\n推荐配置环境变量，把 上述文件的.exe文件与bin文件夹添加到系统环境变量当中 git的网页有些玄学，有时候会被墙。打不开就百度上找，随便装一个，安装最新版就行！ 2.下载hugo解压 hugo下载链接\n选择系统对应的版本号进行下载，这里我需选择 xxx_windowns-amd64.zip\n我实际装的是hugo_extended_0.128.0_windows-amd64.zip，下载链接 注意事项！！！！\nhugo分extend与普通版。extend只是比普通版多了一些可以自己操作的东西。具体区别可以参考官方文档 懒人可以直接看以下内容，我把主要的内容剪切过来了：\nEditions Hugo is available in two editions: standard and extended. With the extended edition you can:\nEncode to the WebP format when processing images. You can decode WebP images with either edition. Transpile Sass to CSS using the embedded LibSass transpiler. The extended edition is not required to use the Dart Sass transpiler. We recommend that you install the extended edition.\n版本 Hugo有两个版本：标准版和扩展版。使用扩展版，您可以：\n处理图像时编码为WebP格式。您可以使用任一版本解码WebP图像。 使用嵌入式LibSass Transpile将Sass转换为CSS。扩展版不需要使用Dart Sass transpiler。 我们建议您安装扩展版。 3.安装验证 任意位置打开cmd终端输入：\n1 2 3 4 # 验证go go version # 验证hugo hugo version 安装成功的效果：\n可能存在的问题：\ngo或hugo不是命令。答：没有配置环境变量。打开系统高级设置-\u0026gt;环境变量，点击用户变量中的Path，点击编辑，点击右上角新建，输入上面go\\hugo安装后的bin文件夹，或者.exe的地址，点击确定。 github类的下载链接无法打开。答：这些链接能不能打开确实是个玄学。建议隔一段时间试试、或者用手机热点、或者使用魔法梯子。 四、总结 如果上述步骤都没有问题，恭喜你！！！hugo环境已经搭建好了！下一篇笔记我将讲解网页搭建过程。\n","date":"2024-07-01T22:26:20+08:00","image":"https://4evergreat.github.io/cover/R%281%29.jpg","permalink":"https://4evergreat.github.io/2024/hugo-blog-1/","title":"hugo-blog-1hugo-win10环境的搭建"},{"content":"1. yum方式Centos7安装Mysql8教程 1.由于centOS7中默认安装了MariaDB,需要先进行卸载\nrpm -qa | grep -i mariadb rpm -e \u0026ndash;nodeps mariadb-libs-5.5.64-1.el7.x86_64\n查询下本机mysql是否卸载干净，若有残留也需要卸载\nrpm -qa | grep mysql\n2.下载MySQL仓库并安装\nwget https://repo.mysql.com//mysql80-community-release-el7-7.noarch.rpm yum -y install mysql80-community-release-el7-7.noarch.rpm\nrpm \u0026ndash;import https://repo.mysql.com/RPM-GPG-KEY-mysql-2023\nyum -y install mysql80-community-release-el7-3.noarch.rpm\n3.安装MySQL数据库\nyum -y install mysql-community-server\n4.开启mysql服务\nsystemctl start mysqld.service\n5.查看mysql默认密码并登陆\ncat /var/log/mysqld.log | grep password\n1 2 [root@localhost tools]# cat /var/log/mysqld.log | grep password 2024-03-11T14:41:25.592058Z 6 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: uBj\u0026gt;f5tC\u0026gt;VQ! 第一次进去提示需要修改密码ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.\nalter user \u0026lsquo;root\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo; identified by \u0026lsquo;yourpassword\u0026rsquo;;\nalter user \u0026lsquo;root\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo; identified by \u0026lsquo;uBj\u0026gt;f5tC\u0026gt;VQ!\u0026rsquo;;\nflush privileges;\n修改初始密码（若想改为弱密码）\nSHOW variables LIKE \u0026lsquo;validate_password%\u0026rsquo;;\n注：如果遇到需要强密码的报错，此时先修改密码为强密码，便可以继续进行修改密码验证策略操作。将密码验证策略改为LOW，密码长度4位以上\nset global validate_password.policy=0; #有的MySQL版本为validate_password_policy,此处请以上一步查询到的字段名称为准 set global validate_password.length=4; #重启MySQL后失效\n此时再进行修改密码操作，可以修改为弱密码了\nALTER USER \u0026lsquo;root\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo; IDENTIFIED BY \u0026lsquo;your password\u0026rsquo;;\n6.设置远程连接(前提：关闭防火墙或开放3306端口) 在实际工作中，经常会远程连接mysql数据库，需要设置允许远程连接。\n在mysql数据库的user表中查看host，默认只允许localhost访问，只需将localhost改为%允许任意地址访问即可\nuse mysql; update user set host = \u0026lsquo;%\u0026rsquo; where user = \u0026lsquo;root\u0026rsquo;; flush privileges; # 刷新权限 权限更新后刷新才会起作用\n注：如果使用客户端连接提示了plugin caching_sha2_password错误，这是因为MySQL8.0的密码策略默认为caching_sha2_password(MySQL5.7无此问题)\n将user表中root对应的记录里plugin字段（加密规则）的值修改成mysql_native_password\nupdate user set plugin = \u0026lsquo;mysql_native_password\u0026rsquo; where user = \u0026lsquo;root\u0026rsquo;; flush privileges; # 刷新权限 权限更新后刷新才会起作用\n8.0以上版本MySQL验证方式发生改变，如果更改成mysql_native_password并不能解决问题的话，请直接跳到第下面这样一步，并把语句中的mysql_native_password替换成caching_sha2_password进行尝试。\nupdate user set plugin = \u0026lsquo;caching_sha2_password\u0026rsquo; where user = \u0026lsquo;root\u0026rsquo;;\n（必要）修改root账户密码以及验证方式：\nalter user \u0026lsquo;root\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo; identified with caching_sha2_password by \u0026lsquo;1234\u0026rsquo;;\nupdate user set authentication_string=password(\u0026lsquo;1234\u0026rsquo;) where user=\u0026lsquo;root\u0026rsquo; and host=\u0026rsquo;%\u0026rsquo;;\n2. 无密码登录 vim /etc/my.cnf\n- 在[mysqld]后添加\r- skip-grant-tables\r- esc :wq保存退出\r重启mysql\nservice mysqld restart 修改密码后删除skip-grant-tables\nvim编辑器的使用\n3.创建账户 在MySQL中，您可以使用CREATE USER语句创建一个新用户并设置密码。以下是一个示例命令：在MySQL中，您可以使用CREATE USER语句创建一个新用户并设置密码。以下是一个示例命令：\n1 2 CREATE USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; CREATE USER \u0026#39;admin\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;admin\u0026#39;; 这里的username是您想要创建的用户名，localhost指定用户可以从本地主机连接到MySQL服务器，password是您想要为新用户设置的密码。\n请确保您有足够的权限来执行这个命令，通常需要具有CREATE USER权限的账户来执行它。\n在执行这个命令之后，您可能还需要为新用户授权权限，例如：\n1 2 GRANT ALL PRIVILEGES ON database_name.* TO \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39;; GRANT ALL PRIVILEGES ON *.* TO \u0026#39;admin\u0026#39;@\u0026#39;%\u0026#39;; 这将授予username在database_name数据库上的所有权限。您可以根据需要更改数据库名和授予的权限。这里的username是您想要创建的用户名，localhost指定用户可以从本地主机连接到MySQL服务器，password是您想要为新用户设置的密码。\n","date":"2024-03-12T23:30:20+08:00","image":"https://picsum.photos/800/600 ","permalink":"https://4evergreat.github.io/2024/mysql-blog-3/","title":"mysql-blog-3mysql8.0"},{"content":"1. 防火墙 1.1 相关命令 查看防火墙状态\n1 systemctl status firewalld 1 2 3 4 5 [root@liangfeifan etc]# systemctl status firewalld ● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled) Active: inactive (dead) #dead没开启防火墙 Docs: man:firewalld(1) 开启防火墙\n1 systemctl start firewalld 1 2 3 4 5 6 7 8 9 [root@liangfeifan etc]# systemctl start firewalld [root@liangfeifan etc]# systemctl status firewalld ● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled) Active: active (running) since 四 2024-06-20 03:10:23 CST; 2s ago Docs: man:firewalld(1) Main PID: 15841 (firewalld) CGroup: /system.slice/firewalld.service └─15841 /usr/bin/python2 -Es /usr/sbin/firewalld --nofork --nopid 关闭防火墙\n1 systemctl firewalld stop 重启防火墙\n1 systemctl firewalld restart 提示错误 FirewallD is not running\n没开防火墙，执行 systemctl start firewalld\n查看防火墙规则\n1 2 firewall-cmd --list-all #查看全部信息 firewall-cmd --list-ports #只查看端口信息 开启端口\n1 2 3 4 5 firewall-cmd --zone=public --add-port=80/tcp --permanent # 参数含义 --zone #作用域 --add-port=80/tcp #添加端口。格式为端口/通信协议 --permanent #永久生效，没有此参数的话重启失效 ","date":"2024-03-11T23:30:20+08:00","image":"https://4evergreat.github.io/cover/01a9d4564d938932f87512f6092e82.jpg@1280w_1l_2o_100sh.jpg","permalink":"https://4evergreat.github.io/2024/linux-blog-1/","title":"linux-blog-1linux运维遇到的问题"},{"content":"apache 开源项目清单\n1. maven的作用 1.依赖管理 直接在pop.xml中管理依赖的信息。maven自动下载替换\n2. 统一项目结构 各种不同的IDE中拥有相同的项目结构，实现跨IDE导入导出\n3. 项目构建 标准跨平台（Linux、Win、Mac）的自动化项目构建方式。清理、编译、测试、打包、发布\n2. maven的介绍 maven 基于项目对象模型POM（project object model）的概念，通过一小段描述信息，来管理项目的构建。 maven官网 仓库:用于存储资源，管理各种jar包。\n本地仓库:自己计算机上的一个目录。 D:\\JavaProject\\Maven\\repository 中央仓库:由Maven团队维护的全球唯一的。仓库地址:https://repo1.maven.org/maven2/ 远程仓库(私服):一般由公司团队搭建的私有仓库。 3.maven的安装 安装步骤:\n下载源码包。以apache-maven-3.6.1-bin.zip为例子\n解压 apache-maven-3.6.1-bin.zip。\n配置本地仓库:修改 conf/settings.xml中的为一个指定目录\n1 2 3 4 //例子：推荐格式： \u0026lt;localRepository\u0026gt;E:\\apache-maven-3.6.1\\mvn_repo\u0026lt;/localRepository\u0026gt; //例子：自用的记录 \u0026lt;localRepository\u0026gt;D:\\JavaProject\\Maven\\repository\u0026lt;/localRepository\u0026gt; 配置阿里云私服(远程仓库):修改 conf/settings.xml中的标签，为其添加如下子标签\n1 2 3 4 5 \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;alimaven\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public/\u0026lt;/url\u0026gt;\t\u0026lt;mirrorOf\u0026gt;centrals/mirrorOf\u0026gt;\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt; 配置环境变量:MAVEN HOME为maven的解压目录，并将其bin目录加入PATH环境变量。\n配置环境变量 MAVEN_HOME 和 maven包下 %MAVEN_HOME%\\bin\n测试\n1 2 3 4 5 6 C:\\Users\\Administrator\u0026gt;mvn -v Apache Maven 3.6.1 (d66c9c0b3152b2e69ee9bac180bb8fcc8e6af555; 2019-04-05T03:00:29+08:00) Maven home: D:\\JavaProject\\Maven\\apache-maven-3.6.1\\bin\\.. Java version: 1.8.0_391, vendor: Oracle Corporation, runtime: D:\\Java\\jdk-1.8\\jre Default locale: zh_CN, platform encoding: GBK OS name: \u0026#34;windows 10\u0026#34;, version: \u0026#34;10.0\u0026#34;, arch: \u0026#34;amd64\u0026#34;, family: \u0026#34;windows\u0026#34; 4. IDEA中创建maven项目 4.1 不使用模板的话可以在new project中按下图操作\n使用模板 archetype 按下述博客操作 如何在IDEA2022中创建maven\nmaven 坐标： 是资源的唯一标识，通过该坐标可以为一定位资源位置\nGroupId : 当前项目隶属组织名（通常是域名反写） ArtifactId : 当前项目名（通常是模块名，如order-service） Version : 当前项目版本号 1 2 3 \u0026lt;groupId\u0026gt;org.None\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;projcet01\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; 4.4 导入maven工程 有两种方式，选中pom.xml文件即可。 4.5 IDEA依赖配置 依赖：指当前项目运行所需的 jar包，一个项目可以引入多个依赖。\n配置步骤：\n1. 在pom.xml中编写 \u0026lt;dependencies\u0026gt;标签\r2. 在\u0026lt;dependencise\u0026gt;标签中使用 \u0026lt;dependency\u0026gt;引入maven坐标\r3. 填写maven坐标（\u0026lt;groupId\u0026gt;\u0026lt;artifactId\u0026gt;\u0026lt;version\u0026gt;）\r4. 点击刷新按钮，实现下载替换\r1 2 3 4 5 6 7 8 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; //如果本地仓库有，填artifactId后自动提示其他两个 \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 如果本地仓库有，填artifactId后自动提示其他两个\n通过一些网站搜索依赖的maven坐标\nmaven 仓库网站\n5. 依赖传递 在pom.xml文件中右键 \u0026gt; Diagrams \u0026gt; Show Dependencies就可以看类似下面的树状图。 5.1 排除依赖： 排除依赖：指主动断开传递过来的依赖的资源，被排除的资源无序指定版本。通过标签实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.None\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;ProjectB\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt;//断开从ProjectB传递过来的依赖APartOfProjectB \u0026lt;groupId\u0026gt;org.None\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;APartOfProjectB\u0026lt;/artifactId\u0026gt; //不需要填写version \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 6. 依赖范围 依赖的jar包，在项目中导入依赖的jar包后，默认情况下，可以在任何地方使用。\n如果希望限制依赖的使用范围，可以通过标签设置其作用范围。\n作用范围：\n主程序范围有效（main文件夹范围内）\n测试程序范围有效（test文件夹范围内）\n是否参与打包运行（package指令范围内）\nscope标签的取值范围：\nscope值 主程序 测试程序 打包（运行） 范例 compile（默认） Y Y Y log4j test - Y - junit provided Y Y - servlet-api runtime - Y Y jdbc驱动 1 2 3 4 5 6 7 8 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; //如果本地仓库有，填artifactId后自动提示其他两个 \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.10\u0026lt;/version\u0026gt; //通过\u0026lt;scope\u0026gt;标签设置其作用范围。 \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 7. maven 生命周期 Maven的生命周期就是为了对所有的构建过程进行抽象和统一。 描述了一次项目构建，经历哪些阶段。在Maven出现之前，项目构建的生命周期就已经存在，软件开发人员每天都在对项目进行清理，编译，测试及部署。\n7.1 maven的三套生命周期 Maven对项目构建的生命周期划分为3套（相互独立）：\nclean：清理工作。\ndefault：核心工作。如：编译、测试、打包、安装、部署等。\nsite：生成报告、发布站点等。\n我们看到这三套生命周期，里面有很多很多的阶段，这么多生命周期阶段，其实我们常用的并不多，主要关注以下几个：\n• clean：移除上一次构建生成的文件\n• compile：编译项目源代码\n• test：使用合适的单元测试框架运行测试(junit)\n• package：将编译后的文件打包，如：jar、war等\n• install：安装项目到本地仓库\n7.2 maven生命周期的运行 方式一 ： 命令行输入 mvn [周期名]\n方式二：IDEA工具为了方便程序员使用maven生命周期，在右侧的maven工具栏中，已给出快速访问通道\n生命周期的顺序是：clean \u0026ndash;\u0026gt; validate \u0026ndash;\u0026gt; compile \u0026ndash;\u0026gt; test \u0026ndash;\u0026gt; package \u0026ndash;\u0026gt; verify \u0026ndash;\u0026gt; install \u0026ndash;\u0026gt; site \u0026ndash;\u0026gt; deploy .\n说明：在同一套生命周期中，我们在执行后面的生命周期时，前面的生命周期都会执行。\n思考：当运行package生命周期时，clean、compile生命周期会不会运行？\n​\tclean不会运行，compile会运行。 因为compile与package属于同一套生命周期，而clean与package不属于同一套生命周期。\n","date":"2024-03-08T22:30:20+08:00","image":"https://4evergreat.github.io/cover/Hong_Kong-Zhuhai-Macau_Bridge1.jpg","permalink":"https://4evergreat.github.io/2024/java-blog-18/","title":"Java-blog-18maven"},{"content":"反射 （1）Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。\n（2）Java属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，**而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到JVM。**通过反射，可以在运行时动态地获取类、创建其对象并调用其属性，不需要提前在编译期知道运行的对象是谁。\n1.获取Class实例的几种方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //1.调用运行时类的静态方法 Class myClass1 = String.class; /* *注意一开始是Class而不是class。Class是一个类，每一个普通类加载到方法区后都是 *一个Class实例。 */ //2.调用运行时类的对象的getClass()方法 //getClass()方法定义在Object类中 String str= new String(); Class myClass2 =str.getClass(); //3.调用Class类的静态方法forName(String className) //String source = \u0026#34;packageName.className\u0026#34;;//全类名，即类在包中的路径+类名//不用写后缀 String source = \u0026#34;java.lang.String\u0026#34;; Class\u0026lt;?\u0026gt; myClass3=Class.forName(source); //上述三种myClass指向都是相同的。下面第四种和第三种差不多，使用场景差不多 //4.使用类的记载器 //source = \u0026#34;java.lang.String\u0026#34;; Class\u0026lt;?\u0026gt;myClass4=ClassLoader.getSystemClassLoader().loadClass(source); 三种方法中，第三种应用较广。第一种需要class已经加载到了内存中，限制较大。第二种都已经能创建对象了，再反过来获取类，有点多此一举的意味。\n使用第三种方式，就算source对应的类不存在，IDEA中也不会报错，只有运行到此处才会发现问题。运行时再加载这一点体现了面向对象的动态性。\n2. Class类的实例 Class类是反射的基础\n哪些类型可以是Class的对象 所有的 java 类型：\nclass : 外部类、成员（成员内部类、静态内部类），局部内部类、匿名内部类\ninterface: 接口\n[] : 数组\n数组只要元素类型与维度一样就是同一个Class实例，与数组长度无关 enum : 枚举\nannotation : 注解\nprimitive type : 基本数据类型\nvoid ： void.class 也是！\nClass : 本身\n3. 类的加载过程 过程1:类的装载(loading) 将类的class文件读入内存，并为之创建一个java.lang.class对象。此过程由类加载器完成 过程2:链接(linking) 验证(Verify):确保加载的类信息符合JVM规范，例如:以cafebabe开头，没有安全方面的问题。 准备(Prepare):正式为类变量(static)分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。 解析(Resolve):虚拟机常量池内的符号引用(常量名)替换为直接引用(地址)的过程。 过程3:初始化(initialization) 执行类构造器()方法的过程。 类构造器()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。 4.使用类的加载器获取流，并读取配置文件信息 通过ClassLoader加载指定的配置文件\n通过类的加载器读取的文件的默认的路径为:当前module下的src下 1 2 3 4 5 6 7 8 9 10 11 12 /*新方式*/ Properties pros = new Propertities(); /*文件的默认的路径为:当前module下的src下*/ InputStream is = ClassLoader.getSystemclassLoader().getResourceAsStream(\u0026#34;filesource\u0026#34;) ; pros.load(is); pros.getPropertity(\u0026#34;name\u0026#34;) ; /*以前的方式*/ Properties pros = new Propertities(); /*文件的默认的路径为:当前module下*/ InputStream is = new InputStream(\u0026#34;filesource\u0026#34;);/**/ pros.load(is); pros.getPropertity(\u0026#34;name\u0026#34;) ; 5.获取带泛型的父类的泛型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** *获取带泛型的父类的泛型 * @input: String source //全类名，即类在包中的路径+类名//不用写后缀 * @return Type[] 泛型的数组 */ public Type[] getParaTypeOfSuperClass (String source)throws ClassNotFoundException { Class clazz = Class.forName( className:source); //获取带泛型的父类(Type是一个接口，Class实现了此接口 Type superclass =clazz.getGenericSuperclass(); //如果父类是带泛型的，则可以强转为ParameterizedType ParameterizedType paramType=(ParameterizedType)superclass; //调用getActualTypeArguments()获取泛型的参数，结果是一个数组，因为可能有多个泛型参数。 Type[] arguments = paramType.getActualTypeArguments(); //返回泛型参数的名称 return arguments; } ","date":"2024-03-06T22:30:20+08:00","image":"https://4evergreat.github.io/cover/e6fc118f-6365-4239-b369-f9e8d74626ee.jpg","permalink":"https://4evergreat.github.io/2024/java-blog-17/","title":"Java-blog-17java反射"},{"content":"1. lambda表达式 1.什么是Lambda表达式 Lambda表达式，也可称为闭包。类似于JavaScript中的闭包，它是推动Java8发布的最重要的新特性。\n2.为什么使用Lambda表达式 我们可以把Lambda表达式理解为一段可以传递的代码（将代码像数据一样进行传递）。Lambda允许把函数作为一个方法的参数，使用Lambda表达式可以写出更简洁、更灵活的代码，而其作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。\n一个简单示例：\n分别使用成员内部类、局部内部类、静态内部类、匿名内部类方式实现Runnable的run()方法并创建和启动线程,如下所示:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public class LambdaDemo { /** * 成员内部类 */ class MyThread01 implements Runnable{ @Override public void run() { System.out.println(\u0026#34;成员内部类：用Lambda语法创建线程吧!\u0026#34;); } } /** * 静态内部类 */ static class MyThread02 implements Runnable{ @Override public void run() { System.out.println(\u0026#34;静态内部类：对啊，用Lambda语法创建线程吧!\u0026#34;); } } public static void main(String[] args) { /** * 局部内部类 */ class MyThread03 implements Runnable{ @Override public void run() { System.out.println(\u0026#34;局部内部类：用Lambda语法创建线程吧!\u0026#34;); } } /** * 匿名内部类 */ Runnable runnable = new Runnable(){ @Override public void run() { System.out.println(\u0026#34;匿名内部类：求求你，用Lambda语法创建线程吧!\u0026#34;); } }; //成员内部类方式 LambdaDemo lambdaDemo = new LambdaDemo(); MyThread01 myThread01 =lambdaDemo.new MyThread01(); new Thread(myThread01).start(); //静态内部类方式 MyThread02 myThread02 = new MyThread02(); new Thread(myThread02).start(); //局部内部类 MyThread03 myThread03 = new MyThread03(); new Thread(myThread03).start(); //匿名内部类的方式 new Thread(runnable).start(); } 可以看到上面创建方式，代码量都不少，使用Lambda表达式实现，如下所示：\n1 2 3 4 //Lambda方式 new Thread(() -\u0026gt; System.out.println(\u0026#34;使用Lambda就对了\u0026#34;)).start(); 可以看到代码明显简洁了许多。 3.Lambda表达式语法 Lambda表达式在Java语言中引入了一个操作符**“-\u0026gt;”**，该操作符被称为Lambda操作符或箭头操作符。它将Lambda分为两个部分：\n左侧：指定了Lambda表达式需要的所有参数 右侧：制定了Lambda体，即Lambda表达式要执行的功能。 像这样： (parameters) -\u0026gt; expression 或\n(parameters) -\u0026gt;{ statements; }\n以下是lambda表达式的重要特征:\n可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。 可选的参数圆括号：一个参数无需定义圆括号，但无参数或多个参数需要定义圆括号。 可选的大括号：如果主体包含了一个语句，就不需要使用大括号。 可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。\n下面对每个语法格式的特征进行举例说明：\n(1)语法格式一：无参，无返回值，Lambda体只需一条语句。如下：\n1 2 3 4 @Test public void test01(){ Runnable runnable=()-\u0026gt; System.out.println(\u0026#34;Runnable 运行\u0026#34;); runnable.run();//结果：Runnable 运行 (2)语法格式二：Lambda需要一个参数，无返回值。如下：\n1 2 3 4 5 @Test public void test02(){ Consumer\u0026lt;String\u0026gt; consumer=(x)-\u0026gt; System.out.println(x); consumer.accept(\u0026#34;Hello Consumer\u0026#34;);//结果：Hello Consumer } (3)语法格式三：Lambda只需要一个参数时，参数的小括号可以省略，如下：\n1 2 3 4 public void test02(){ Consumer\u0026lt;String\u0026gt; consumer=x-\u0026gt; System.out.println(x); consumer.accept(\u0026#34;Hello Consumer\u0026#34;);//结果：Hello Consumer } (4)语法格式四：Lambda需要两个参数，并且Lambda体中有多条语句。\n1 2 3 4 5 6 7 8 @Test public void test04(){ Comparator\u0026lt;Integer\u0026gt; com=(x, y)-\u0026gt;{ System.out.println(\u0026#34;函数式接口\u0026#34;); return Integer.compare(x,y); }; System.out.println(com.compare(2,4));//结果：-1 } （5）语法格式五：有两个以上参数，有返回值，若Lambda体中只有一条语句，return和大括号都可以省略不写\n1 2 3 4 5 @Test public void test05(){ Comparator\u0026lt;Integer\u0026gt; com=(x, y)-\u0026gt; Integer.compare(x,y); System.out.println(com.compare(4,2));//结果：1 } (6)Lambda表达式的参数列表的数据类型可以省略不写，因为JVM可以通过上下文推断出数据类型，即“类型推断”\n1 2 3 4 5 @Test public void test06(){ Comparator\u0026lt;Integer\u0026gt; com=(Integer x, Integer y)-\u0026gt; Integer.compare(x,y); System.out.println(com.compare(4,2));//结果：1 } 类型推断：在执行javac编译程序时，JVM根据程序的上下文推断出了参数的类型。Lambda表达式依赖于上下文环境。\n语法背诵口诀：左右遇一括号省，左侧推断类型省，能省则省。\n4.函数式接口 4.1 什么是函数式接口 只包含一个抽象方法的接口，就称为函数式接口。\n我们可以通过Lambda表达式来创建该接口的实现对象。 我们可以在任意函数式接口上使用@FunctionalInterface注解，这样做可以用于检测它是否是一个函数式接口，同时javadoc也会包含一条声明，说明这个接口是一个函数式接口。\n4.2 自定义函数式接口 按照函数式接口的定义，自定义一个函数式接口，如下：\n1 2 3 4 @FunctionalInterface public interface MyFuncInterf\u0026lt;T\u0026gt; { public T getValue(String origin); } 定义一个方法将函数式接口作为方法参数。\n1 2 3 public String toLowerString(MyFuncInterf\u0026lt;String\u0026gt; mf,String origin){ return mf.getValue(origin); } 将Lambda表达式实现的接口作为参数传递。\n1 2 3 4 5 6 public void test07(){ String value=toLowerString((str)-\u0026gt;{ return str.toLowerCase(); },\u0026#34;ABC\u0026#34;); System.out.println(value);//结果ABC } 4.3 Java内置函数式接口 四大核心函数式接口的介绍，如图所示：\n使用示例： 1.Consumer:消费型接口 void accept(T t)\n1 2 3 4 5 6 7 public void makeMoney(Integer money, Consumer\u0026lt;Integer\u0026gt; consumer){ consumer.accept(money); } @Test public void test01(){ makeMoney(100,t-\u0026gt; System.out.println(\u0026#34;今天赚了\u0026#34;+t));//结果：今天赚了100 } 2.Supplier：供给型接口 T get()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 List list = addNumInList(10, () -\u0026gt; (int) (Math.random() * 100)); list.forEach(t-\u0026gt; System.out.println(t));/** * 产生指定的整数集合放到集合中 * Iterable接口的forEach方法的定义：方法中使用到了Consumer消费型接口， * default void forEach(Consumer\u0026lt;? super T\u0026gt; action) { * Objects.requireNonNull(action); * for (T t : this) { * action.accept(t); * } * } */ @Test public void test02(){ List list = addNumInList(10, () -\u0026gt; (int) (Math.random() * 100)); list.forEach(t-\u0026gt; System.out.println(t)); } public List addNumInList(int size, Supplier\u0026lt;Integer\u0026gt; supplier){ List\u0026lt;Integer\u0026gt; list=new ArrayList(); for (int i = 0; i \u0026lt; size; i++) { list.add(supplier.get()); } return list; } 3.Function\u0026lt;T,R\u0026gt;:函数型接口 R apply(T t)\n1 2 3 4 5 6 7 8 9 10 11 12 /** * * 使用函数式接口处理字符串。 */ public String handleStr(String s,Function\u0026lt;String,String\u0026gt; f){ return f.apply(s); } @Test public void test03(){ System.out.println(handleStr(\u0026#34;abc\u0026#34;,(String s)-\u0026gt;s.toUpperCase())); } //结果：ABC 4.Predicate:断言型接口 boolean test(T t)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * 自定义条件过滤字符串集合 */ @Test public void test04(){ List\u0026lt;String\u0026gt; strings = Arrays.asList(\u0026#34;啊啊啊\u0026#34;, \u0026#34;2333\u0026#34;, \u0026#34;666\u0026#34;, \u0026#34;?????????\u0026#34;); List\u0026lt;String\u0026gt; stringList = filterStr(strings, (s) -\u0026gt; s.length() \u0026gt; 3); for (String s : stringList) { System.out.println(s); } } public List\u0026lt;String\u0026gt; filterStr(List\u0026lt;String\u0026gt; list, Predicate\u0026lt;String\u0026gt; predicate){ ArrayList result = new ArrayList(); for (int i = 0; i \u0026lt; list.size(); i++) { if (predicate.test(list.get(i))){ result.add(list.get(i)); } } return result; } 其他接口的定义，如图所示：\n5.方法引用 当要传递给Lambda体的操作，已经有实现的方法了，就可以使用方法引用！（实现抽象方法的参数列表，必须与方法引用的参数列表一致，方法的返回值也必须一致，即方法的签名一致）。方法引用可以理解为方法引用是Lambda表达式的另外一种表现形式。 方法引用的语法：使用操作符“::”将对象或类和方法名分隔开。 方法引用的使用情况共分为以下三种：\n对象::实例方法名 类::静态方法名 类::实例方法名\n使用示例： 1.对象::实例方法名\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** *PrintStream中的println方法定义 * public void println(String x) { * synchronized (this) { * print(x); * newLine(); * } * } */ //对象::实例方法名 @Test public void test1(){ PrintStream out = System.out; Consumer\u0026lt;String\u0026gt; consumer=out::println; consumer.accept(\u0026#34;hello\u0026#34;); } 2.类::静态方法名\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * Integer类中的静态方法compare的定义： * public static int compare(int x, int y) { * return (x \u0026lt; y) ? -1 : ((x == y) ? 0 : 1); * } */ @Test public void test2(){ Comparator\u0026lt;Integer\u0026gt; comparable=(x,y)-\u0026gt;Integer.compare(x,y); //使用方法引用实现相同效果 Comparator\u0026lt;Integer\u0026gt; integerComparable=Integer::compare; System.out.println(integerComparable.compare(4,2));//结果：1 System.out.println(comparable.compare(4,2));//结果：1 } 3.类::实例方法名\n1 2 3 4 5 6 7 8 @Test public void test3(){ BiPredicate\u0026lt;String,String\u0026gt; bp=(x,y)-\u0026gt;x.equals(y); //使用方法引用实现相同效果 BiPredicate\u0026lt;String,String\u0026gt; bp2=String::equals; System.out.println(bp.test(\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;));//结果：false System.out.println(bp.test(\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;));//结果：false } 6.构造器引用 格式：类名::new 与函数式接口相结合，自动与函数式接口中方法兼容，可以把构造器引用赋值给定义的方法。需要注意构造器参数列表要与接口中抽象方法的参数列表一致。使用示例： 创建一个实体类Employee：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class Employee { private Integer id; private String name; private Integer age; @Override public String toString() { return \u0026#34;Employee{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } public Employee(){ } public Employee(Integer id) { this.id = id; } public Employee(Integer id, Integer age) { this.id = id; this.age = age; } public Employee(int id, String name, int age) { this.id = id; this.name = name; this.age = age; } } 使用构造器引用与函数式接口相结合\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Test public void test01(){ //引用无参构造器 Supplier\u0026lt;Employee\u0026gt; supplier=Employee::new; System.out.println(supplier.get()); //引用有参构造器 Function\u0026lt;Integer,Employee\u0026gt; function=Employee::new; System.out.println(function.apply(21)); BiFunction\u0026lt;Integer,Integer,Employee\u0026gt; biFunction=Employee::new; System.out.println(biFunction.apply(8,24)); } 输出结果： Employee{id=null, name=\u0026#39;null\u0026#39;, age=null} Employee{id=21, name=\u0026#39;null\u0026#39;, age=null} Employee{id=8, name=\u0026#39;null\u0026#39;, age=24} 7.数组引用 数组引用的格式：type[]:new 使用示例：\n1 2 3 4 5 6 @Test public void test02(){ Function\u0026lt;Integer,String[]\u0026gt; function=String[]::new; String[] apply = function.apply(10); System.out.println(apply.length);//结果：10 } 8.Lambda表达式的作用域 Lambda表达式可以看作是匿名内部类实例化的对象，Lambda表达式对变量的访问限制和匿名内部类一样，因此Lambda表达式可以访问局部变量、局部引用，静态变量，实例变量。\n8.1 访问局部变量 在Lambda表达式中规定只能引用标记了final的外层局部变量。我们不能在lambda 内部修改定义在域外的局部变量，否则会编译错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class TestFinalVariable { interface VarTestInterface{ Integer change(String str); } public static void main(String[] args) { //局部变量不使用final修饰 Integer tempInt = 1; VarTestInterface var = (str -\u0026gt; Integer.valueOf(str+tempInt)); //再次修改,不符合隐式final定义 tempInt =2; Integer str =var.change(\u0026#34;111\u0026#34;) ; System.out.println(str); } } 上面代码会出现编译错误，出现如下提示：\n特殊情况下，局部变量也可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）\n例如上面的代码确保Lambda表达式后局部变量后面不做修改，就可以成功啦！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class TestFinalVariable { interface VarTestInterface{ Integer change(String str); } public static void main(String[] args) { //局部变量不使用final修饰 Integer tempInt = 1; VarTestInterface var = (str -\u0026gt; Integer.valueOf(str+tempInt)); Integer str =var.change(\u0026#34;111\u0026#34;) ; System.out.println(str); } } 8.2 访问局部引用，静态变量，实例变量 Lambda表达式不限制访问局部引用变量，静态变量，实例变量。代码测试都可正常执行，代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 public class LambdaScopeTest { /** * 静态变量 */ private static String staticVar; /** * 实例变量 */ private String instanceVar; @FunctionalInterface interface VarChangeInterface{ Integer change(String str); } /** * 测试引用变量 */ private void testReferenceVar(){ ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;111\u0026#34;); //访问外部引用局部引用变量 VarChangeInterface varChangeInterface = ((str) -\u0026gt; Integer.valueOf(list.get(0))); //修改局部引用变量 list.set(0,\u0026#34;222\u0026#34;); Integer str =varChangeInterface.change(\u0026#34;\u0026#34;); System.out.println(str); } /** * 测试静态变量 */ void testStaticVar(){ staticVar=\u0026#34;222\u0026#34;; VarChangeInterface varChangeInterface = (str -\u0026gt; Integer.valueOf(str+staticVar)); staticVar=\u0026#34;333\u0026#34;; Integer str =varChangeInterface.change(\u0026#34;111\u0026#34;) ; System.out.println(str); } /** * 测试实例变量 */ void testInstanceVar(){ instanceVar=\u0026#34;222\u0026#34;; VarChangeInterface varChangeInterface = (str -\u0026gt; Integer.valueOf(str+instanceVar)); instanceVar=\u0026#34;333\u0026#34;; Integer str =varChangeInterface.change(\u0026#34;111\u0026#34;) ; System.out.println(str); } public static void main(String[] args) { new LambdaScopeTest().testReferenceVar();//222 new LambdaScopeTest().testStaticVar();//111333 new LambdaScopeTest().testInstanceVar();//111333 } } Lambda表达式里不允许声明一个与局部变量同名的参数或者局部变量。\n1 2 3 4 5 6 7 //编程报错 Integer tempInt = 1; VarTestInterface varTest01 = (tempInt -\u0026gt; Integer.valueOf(tempInt)); VarTestInterface varTest02 = (str -\u0026gt; { Integer tempInt = 1; Integer.valueOf(str); }); 8.3 Lambda表达式访问局部变量作限制的原因 Lambda表达式不能访问非final修饰的局部变量的原因是，局部变量是保存在栈帧中的。而在Java的线程模型中，栈帧中的局部变量是线程私有的，如果允许Lambda表达式访问到栈帧中的变量地址（可改变的局部变量），则会可能导致线程私有的数据被并发访问，造成线程不安全问题。\n基于上述，对于引用类型的局部变量，因为Java是值传递，又因为引用类型的指向内容是保存在堆中，是线程共享的，因此Lambda表达式中可以修改引用类型的局部变量的内容，而不能修改该变量的引用。\n对于基本数据类型的变量，在 Lambda表达式中只是获取到该变量的副本，且局部变量是线程私有的，因此无法知道其他线程对该变量的修改，如果该变量不做final修饰，会造成数据不同步的问题。\n但是实例变量，静态变量不作限制，因为实例变量，静态变量是保存在堆中(Java8之后)，而堆是线程共享的。在Lambda表达式内部是可以知道实例变量，静态变量的变化。\n9.Lambda表达式的优缺点 优点： 使代码更简洁，紧凑 可以使用并行流来并行处理，充分利用多核CPU的优势 有利于JIT编译器对代码进行优化 缺点： 非并行计算情况下，其计算速度没有比传统的 for 循环快 不容易调试 若其他程序员没有学过 Lambda 表达式，代码不容易看懂 在Stream操作中使用lambda表达式：Java8新特性Stream的使用总结 ","date":"2024-03-06T22:30:20+08:00","image":"https://4evergreat.github.io/cover/OIP-C%20%281%29.jpg","permalink":"https://4evergreat.github.io/2024/java-blog-19/","title":"Java-blog-19Lambda表达式"},{"content":"bbs:\n红黑树旋转详解\n","date":"2024-03-02T22:27:20+08:00","image":"https://4evergreat.github.io/cover/02Y2a12000ahjnt6k6E3F_R_1080_808_Q90.jpg","permalink":"https://4evergreat.github.io/2024/ds-blog-1/","title":"DS-blog-1 红黑树"},{"content":"1. 枚举类 enum 开发中建议，有限的且确定的类可以定义为枚举类。如性别、星期、月份、季节、支付方式等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 //JDK5以前,用class、final、static配合自己定义 //举例: class Gender{ // 2.声明当前类的实例变量，需要是private,final /*关于（实例/类）变量的修饰符用途： *定义为final确保定义后不会被修改； *定义成private是防止被外部修改； *不定义为static是因为此处的性别定义有多个，不是共享的。单例时可以考虑用static； */ private final String GenderName; private final String GenderDesc; //1.私有化构造器,需要是private /*关于构造器的修饰符用途： * private 私有化构造器后，只能在类内定义实例对象； * 这也意味着可以是单例模式； */ private Gender(String GenderName,String GenderDesc){ this.GenderName = GenderName; this.GenderDesc = GenderDesc; } //3.提供实例变量的get方法, 需要是public。alt+insert快捷键快速设计 public String getGenderName(){return this.GenderName;}//只是get方法的举例。注意因为实例变量是final，所有没有set方法 // 4.类内创建实例，需要是public, static, final。建议实例名全大写，因为是常量 /*关于（实例/对象）的修饰符用途： * 定义为 public 是确保类外可以随便调用； * 定义为 static 确保可以通过类名可以直接调用； * 定义为final 是为了防止在类外被修改。虽然（变量）值已经是final了，但是对象是可以指向null的，加上final是防止被修改指向； */ public static final Gender MALE = new Gender(\u0026#34;male\u0026#34;,\u0026#34;雄性\u0026#34;); public static final Gender FEMALE = new Gendr(\u0026#34;female\u0026#34;,\u0026#34;雌性\u0026#34;); //类外直接通过`类名.对象` 调用即可。如 Gender.MALE } //JDK5及以后，使用关键字enum enum Gender1{//此处不再是class //1.需要把实例放在枚举类的最前面 /*关于（实例/对象）创建的新格式： * 1. 实例类型与修饰符必须定义为 public static final [枚举类类名]，所以JDK干脆要求不写； * 2. 实例创建用的都是 new [枚举类类名]，所以JDK干脆要求不写。改为 实例名（实参列表）； * 3. 多个实例之间用`逗号`隔开，末尾实例才加`分号` */ MALE = (\u0026#34;male\u0026#34;,\u0026#34;雄性\u0026#34;), FEMALE = new Gendr1(\u0026#34;female\u0026#34;,\u0026#34;雌性\u0026#34;); // 3.声明当前类的实例变量，需要是private,final 同上 private final String GenderName; private final String GenderDesc; //2.私有化构造器,需要是private 同上 private Gender1(String GenderName,String GenderDesc){ this.GenderName = GenderName; this.GenderDesc = GenderDesc; } //4.提供实例变量的get方法, 需要是public。alt+insert快捷键快速设计 public String getGenderName(){return this.GenderName;}//只是get方法的举例。注意因为实例变量是final，所有没有set方法 //类外直接通过`类名.对象` 调用即可。如 Gender.MALE } /*假设两种方法分别简称为class法（前者） 和 enum法（后者） * class法的默认父类是Object; enum法的默认父类是java.lang.Enum(无法改）; Enum的父类是Object * enum法定义的枚举类，不要再显式地修改其父类，因为必须要是Enum，否则报错 */ 1.1 Enum类中的常用方法 String toString( )； 默认返回的是枚举常量(实例)的名，可以自己重写 static 枚举类型 [ ] values( )； 返回枚举类型的常量(实例)数组。该方法可以用于快速遍历所有枚举值。静态方法不可重写 static 枚举类型 valueOf (String name)；可以把字符串转化为对应的枚举常量(实例)，要求形参中的字符串必须是枚举类型中常量(实例)的名字 String name ( )；得到当前枚举常量的名称，建议用toSting取代该方法 int ordinal ( )；返回当前枚举常量(实例)的次序号。默认从0开始。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //调用上述 enum Gender1 测试举例 // toString() System.out.println(Gender.MALE);//MALE,sout默认调用toString()3 System.out.println(Gender.MALE.toString());//MALE //name() System.out.println(Gender.MALE.name());//MALE //values() Gender1[] gen = Gender1.values();//返回整个数组 for(int i=0;i\u0026lt;gen.length;++i){System.out.print(gen[i])};//(调用了toString()) 输出MALE FEMALE //valueOf() Gender unknowgen = Gender1.valeOf(\u0026#34;MALE\u0026#34;);//unknowgen 指向WINTER对象 Gender unknowgen1 = Gender1.valeOf(\u0026#34;aaa\u0026#34;);//不存在这个aaa类，报错 //ordinal() System.out.println(Gender1.FEMAL.ordinal());// 2，这个方法不常用 2 包装类 包装类用于把普通数据类型转换为引用类型。默认初始化值为 null， 不是0、false等值，所以别写错大小写！！\n数据类型 对应的包装类 cache大小 父类为Object的有2种： \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- boolean Boolean true 和 false char Character 0 ~ 127 父类为Number的有6种： \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- byte Byte -128 ~ 127 short Short -128 ~ 127 int Integer -128 ~ 127 long Long -128 ~ 127 float Float 无 享元模式：java 预先创建一些对象cache，(有点像常量一样)，用户需要创建对象时，直接返回这些对象，而不需要实时新建，提前加载了所以优化了性能。 例如 Integer类使用了一个静态内部类（Static Nested Class），它在首次使用Integer类时被加载。该内部类预先创建了一个一个Integer对象的缓存数组（cache）。当使用Integer.valueOf()方法创建Integer对象时，如果数值在-128到127范围内，方法会直接返回缓存数组中的对应对象，而不会新建对象。 注意，直接使用new关键字创建对象时，无论数值是否在-128到127范围内，都会新建一个对象，而不是使用缓存中的对象。这点于valueOf() 2.1 装箱拆箱 装箱即把普通数据类型装欢成对应的引用类型对象；拆箱相反。了解包装类之前请先看String类型！因为基本数据类型、包装类、String常常要类型转换！\n** 装箱拆箱的作用：**\n一方面，很多情况下，需要使用基本数据类型对应的包装类的对象。例如某些函数接口的参数列表是Object 类型，此时就需要将基本数据类型的变量转换为包装类的对象。比如:ArrayList的add(object obj)；0bject类的equals(0bject obj)\n另一方面，对于包装类来讲，既然我们使用的是对象，那么对象是不能进行+* /等运算的。为了能够进行这些运算，就需要将包装类的对象转换为基本数据类型的变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //以Int类型为例： //JDK 5.0以前需要手动操作 //装箱： int i = 10; Integer ii1 = new Integer(i);//方式一：用构造器（过时） Integer ii2 = new Integer(\u0026#34;10\u0026#34;);//方式二：用字符串参数的构造器 Integer ii3 = Integer.valueOf(i);//方式三：用静态方法 valueOf(); （推荐） //拆箱：用 `对象.[类型]Value()`方法 int i2 = ii1.intValue(); //JDK5.0及其之后自动装箱自动拆箱 Integer ii4 = 10; //自动装箱本质上用的是valueOf() int i3 = ii4; //自动拆箱本质用的还是[类型]Value() 2.2 基本数据类型、包装类、String间的类型转换 3.String 类 4. Thread 类 thread 也就是线程的意思 4.1 创建线程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* 方式一： 自定义类继承 Thread 类 1.自定义类 MyThread 类 继承 Thread类。 2.在 MyThread类 中重写 run() 入口方法。 3.在 main 中newMyThread类 的实例 t 。 4.通过 t 调用 start() 方法，启动线程。 */ /*方式二： 自定义实现类实现Runable接口 1.自定义实现类实现 Runnable 接口。 2.重写run()方法。 3.创建实现类对象 r 3.通过 Thread 类的带参构造函数传入Runnable实现类对象r 来创建 Thread 类实例 /* 方式三： 自定义实现类实现Callable接口 1.创建一个Callable接口的实现类 2.重写call()方法 //call()可以throws 异常且有泛型返回值 3.创建Callable实现类对象 c 4.将此对象c 传递到 FutureTask的构造器中，创建 FutureTask 对象f //本质是间接通过FutureTask使用Runable 5.通过 Thread 类的带参构造函数传入 FutureTask 对象f 来创建 Thread 类实例 */ /*方式四 线程池 */ 4.2 常用接口 常用构造函数：\nThread()\t创建线程对象 Thread(Runnable target)\t使用 Runnable实现类对象创建线程对象 Thread(String name)\t创建线程对象，并命名 Thread(Runnable target, String name)\t使用 Runnable 对象创建线程对象，并命名 其他常用方法：\n返回类型 描述 static Thread currentThread() 返回对当前正在执行的线程对象的引用。 String getName() 返回此线程的名称。 void setName(String name)设置此线程的名称。 int getPriority() 返回此线程的优先级。(1至10，默认5) void setPriority(int newPriority)设置此线程的优先级。(1至10，默认5) boolean isAlive() 测试这个线程是否活着。 void join() 当前程序block，直至调用该函数的线程执行完 static void sleep(long millis) 使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。 void start() 导致此线程开始执行; Java虚拟机调用此线程的run方法。 static void yield() 当前线程让出处理器 String toString()返回此线程的字符串表示，包括线程的名称，优先级和线程组。 void run()如果这个线程使用单独的Runnable运行对象构造，则调用该Runnable对象的run方法; 否则，此方法不执行任何操作并返回。 关于run（）\n线程调用的是Thread 类的 run()方法，可以被重写，重写后直接执行重写的方法，这一点由继承性与多态性决定。但是不重写又是怎么执行的呢？（也就是使用Runnable实现类创建线程是怎么实现run的呢）\nThread 新增实例变量private Runnable target。默认指向空\n使用Thread(Runnable target)创建线程对象可以让 this.target = tatget；\n在看run()源码\n1 2 3 4 5 6 @Override public void run() { if (target != null) {//有传Runnable实现类就不为空，否则么有运行效果 target.run(); } } 思考题：\n1 2 3 4 5 6 7 8 9 10 11 new Thread(new Runnable(){void run(){System.out.println(\u0026#34;a\u0026#34;);}}){ void run(){ System.out.println(\u0026#34;b\u0026#34;); } }.start();//输出的是b //执行的是a new Thread(new Runnable(){void run(){System.out.println(\u0026#34;a\u0026#34;);}}){ // }.start();//输出的是b 关于start()\n调用start()才会生成线程，然后jvm再执行run()方法\n直接调用run()只是在当前线程中调用方法，没有生成新线程\n4.2 线程的生命周期 ","date":"2024-02-02T22:30:20+08:00","image":"https://4evergreat.github.io/cover/fa6d11e00c0f91f7.jpg","permalink":"https://4evergreat.github.io/2024/java-blog-16/","title":"Java-blog-16java对象进阶"},{"content":"1.继承 java 只有单继承 关键字：extends 1 2 class A{}//父类 class B extends class A{}//子类B继承了A类 2.继承权限 相较于C++ 的public，protected, private，java对不写继承的default的定义不一样：\nc++ default = private Java不写则默认是 default，是一个新的权限， 所以 Java 有四种 public，protected, private，default。 default ：包访问权限 默认访问权限没有关键字，通常被称为包访问权限 (packageaccess) (有时也称为friendly)。\n这意味着当前包中的所有其他类都可以访问那个成员。对于这个包之外的类，这个成员看上去是private 的。 由于一个编译单元(即一个文件)只能隶属于一个包，所以通过包访问权限，位于同一编译单元中的所有类彼此之间都是可访问的。包访问权限可以把相关类聚到一个包下，以便它们能轻易地相互访问。 3.访问调用逻辑 子类获取到了父类声明中的全部属性与方法（构造器除外，构造器只能被子类调用）。但是受到封装性的影响，可能不能直接调用。\n在子类方法中访问一个变量或者方法：最先在子类局部范围找，如果没有就在子类成员范围找，最后在父类成员范围找，如果都没有就报错(不考虑父亲的父亲之类的祖先)\n勘误：上面这条查找关系的逻辑错误，正确情况是：子类中如果没找到，会去父类中查找，如果还是没有会一直查到 Object 类为止，还是没有才会报错。如果其中有祖先有定义了待查的变量或者方法，但是没给访问权限，会停止溯源直接报错。\n其实很好理解，因为子类继承了父类的信息，所以子孙也拥有祖先的信息才对，可以套娃式地溯源是理所应当的\n理解是这么理解，和实际上方法和变量在JVM的继承的实现逻辑还是有一点区别的，实例对象由对象头、示例数据、对齐填充三个字段构成。对象头存了Klass指向当前类的定义（该定义存了指向父类的定义的指针），实例数据字段存的才是包括父类在内的实例变量。所以方法的溯源和变量的溯源在实际中还是有区别的。\n4. Object类 Java 中所有类都会继承Object类，无论程序中有没有显式写明这种继承关系。有点像JS对象中的原型prototype的prototype即Object。\n5. Super关键字 ​\t加了super 关键字后 同名 属性 或者 方法 直接直接指向 父类\n1 2 3 4 5 6 7 8 9 10 11 class Person{ String name; } Class Man extends Person{ String name; void showName(String name){ System.out,println(name);//指向形参name System.out.println(this.name);//指向当前实例 Person 中的name System.out.println(super.name);//指向父类Person的name } } 6. this()与super() 定义：\nthis()是调用当前类的构造器，（）内带参数就是有参构造，无参数就是无参构造\nsuper()是调用父类的构造器，（）内带参数就是有参构造，无参数就是无参构造\n作用：\n子类继承父类时，不会继承父类的构造器，只能通过super(形参列表)的方式调用父类指定的构造器 子类想要扩展构造器初始化更多的实例变量，通常可以用this(形参列表)来避免代码的重复 使用方式：\n**super(形参列表)**必须放在构造器方法体的首行， this(形参列表) 亦是如此\n子类构造器首行可以是 this(形参列表) 或者 super(形参列表)，不写的话编译器去就默认添加 **super()**无参\nthis(形参列表) 和 super(形参列表) 都要求放首行，所以想要显式调用，只能二选一。\n推论\n子类须要调用 super(形参列表)，所以子类至少有一个构造器满足第一行调用了 super(形参列表)\n子类如果有构造器首行显式调用了this(形参列表) ，则一定嵌套调用了一个带 **super(形参列表)**的构造器\n7.多继承 java 的类没有多继承，只有单继承 java 的接口可以多继承 ","date":"2024-01-03T22:30:20+08:00","image":"https://4evergreat.github.io/cover/2022091601381437.jpg","permalink":"https://4evergreat.github.io/2024/java-blog-11/","title":"Java-blog-11继承知识点综合"},{"content":"1. jvm 内存模型 JMM 原帖链接 JMM控制 Java 线程之间的通信，决定一个线程对共享变量的写入何时对另一个线程可见。 每条线程在自己的工作内存中对共享变量（副本）进行操作，JMM再负责把这些操作同步到主内存中 JVM1.8 用Meta space（元空间）（在JVM外的本地内存中）取代了方法区（Method Area）（在JVM堆中） 1.1 Java heap Java 堆是垃圾收集器管理的主要区域，因此也被称作GC堆（Garbage Collected Heap）\n1.1.2 字符串常量池 字符串常量池原本存放于方法区，jdk7开始放置于堆中。 字符串常量池存储的是string对象的直接引用，而不是直接存放的对象，是一张string table 1.1.3 对象实例 类初始化生成的对象 基本数据类型的数组也是对象实例 1.1.4 线程分配缓冲区 增加线程分配缓冲区是为了提升对象分配时的效率 1.2 本地内存(元空间实现的方法区) 元空间并不在虚拟机中，而是使用本地内存\nJDK8开始用元空间实现原来java heap中的方法区\n-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC（garbage collection）会对改值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。\n-XX:MaxMetaspaceSize，最大空间，默认是没有限制的\n1.2.1类元信息（Klass）(有点类定义的意思) 类元信息在类编译期间放入方法区，里面放置了类的基本信息，包括类的版本、字段、方法、接口以及常量池表（Constant Pool Table） 常量池表（Constant Pool Table）存储了类在编译期间生成的字面量、符号引用，这些信息在类加载完后会被解析到运行时常量池中 1.2.2运行时常量池（Runtime Constant Pool) 运行时常量池主要存放在类加载后被解析的字面量与符号引用 1.3 本地方法栈 本地方法栈则是为执行本地方法（Native Method）服务的。简单地讲，一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制。\n2.TLAB机制 堆是全局共享的，因此在同一时间，可能有多个线程在堆上申请空间，在并发场景中，就会存在两个线程先后把对象引用指向了同一个内存区域，所以对象的内存分配过程需要一个同步机制，但是无论是使用哪种同步方案（实际上虚拟机使用的可能CAS），都会影响内存的分配效率。所以HotSpot虚拟机的提供了一个解决方案：TLAB分配，即Thread Local Allocation Buffer。（TLAB只是的一个优化方案，不代表所有的虚拟机都有这个特性）\n每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块”私有”内存中分配，当这部分区域用完之后，再分配新的”私有”内存。 因为有了TLAB技术，堆内存是线程共享的这个命题是不准确的\n3. 对象在JVM中的内存布局 推荐看以下链接\nJava对象实例化过程以及对象实例内存分布\nJava对象实例内存分布\n在new一个对象时，jvm创建instanceOopDesc，来表示这个对象，存放在堆区，其引用存放在栈区；平时说的Java Object Layout就是instanceOopDesc，它用来表示对象的实例信息；instanceOopDesc对应java中的对象实例。\ninstanceOopDesc包含三部分：\n对象头，也叫Mark Word，主要存储对象运行时记录信息，如hashcode, GC分代年龄，锁状态标志，线程ID，时间戳等; 对象头还包括 class pointer指向方法区的 Klass\n每个实例对象对klass的引用都是同一个 实例数据，是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段） 填充。无实际意义， 。 HotSpot 要求对象起始地址都是 8 字节的整数倍，所以要对齐 ","date":"2023-12-25T22:30:20+08:00","image":"https://4evergreat.github.io/cover/012750554411a00000019ae9d1d1bf.jpg@1280w_1l_2o_100sh.jpg","permalink":"https://4evergreat.github.io/2023/java-blog-10/","title":"Java-blog-10jvm 内存模型JMM"},{"content":"1.方法重写的定义 重载（overload）是在同一个类中的具有多个相同方法名，参数列表不同（的方法（返回类型可以不同），构造方法、普通方法、抽象方法都可以重载；重写（override）是在子类继承父类的时候重写，可以用@Override检查是否是重写方法，方法重载是一个类的多态性的表现，而方法重写是子类与父类的一种多态性表现。重载是编译时的多态性，重写是运行时的多态性\n重写满足以下规则：（外壳不变，核心重写）\n返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同） 重写方法的参数列表相同 重写方法的函数名相同 被重写方法的访问修饰符不能是private，重写的方法可以范围可以扩大 public \u0026gt; protected \u0026gt; default \u0026gt; private，但是不能缩小 被重写方法不能有修饰符 final 声明为 static 的方法不能被重写，但是能够被再次声明 抛出的异常范围可以被缩小，但不能被扩大 构造方法不能被重写 2.方法的重写后调用（父类引用和子类引用接受子类new的对象） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Person { protected String name=\u0026#34;Person name\u0026#34;; protected static String staticName=\u0026#34;Person staticName\u0026#34;; public String getName() { System.out.println(\u0026#34;function call of Person\u0026#34;); return name; } public static String showName() { System.out.println(\u0026#34;static function call of Person\u0026#34;); return staticName; } } class Man extends Person { protected String name=\u0026#34;Man name\u0026#34;; protected static String staticName=\u0026#34;Man staticName\u0026#34;; public static String showName(){ System.out.println(\u0026#34;static function call of Man\u0026#34;); return staticName; } @Override public String getName() { System.out.println(\u0026#34;function call of Man\u0026#34;); return name; } } 2.1 static方法重写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public static void main(String[] args) { Person person= new Man(); Man man = new Man(); //静态 System.out.println(\u0026#34;person call:\u0026#34;); System.out.println(person.showName()); //编译器警告不要通过实例调用类的静态方法 System.out.println(\u0026#34;man call:\u0026#34;); System.out.println(man.showName()); } /*输出 person call: static function call of Person Person staticName man call: static function call of Man Man staticName */ 2.2 非static方法重写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static void main(String[] args) { Person person= new Man(); Man man = new Man(); //非静态 System.out.println(\u0026#34;person call:\u0026#34;); System.out.println(person.getName()); System.out.println(\u0026#34;man call:\u0026#34;); System.out.println(man.getName()); } /*输出： person call: function call of Man Man name man call: function call of Man Man name */ 2.3 总结 子类引用 和 父类引用 接受 new 出来的 子类对象 时：\n重写静态方法的调用取决于引用类型。因为引用直接调用的是类的方法，所以静态方法重写由引用类型决定 重写非静态方法时取决于构造函数。因为引用类型指向地址实际上是由构造函数决定的。实际上，可以根据多态特性来理解，c++有指针所以没用 virtual 时指向各自引用类型的函数。由于java没有指针，所以跳过了这一步，直接实现多态，也就是父类指针也可以指向子类对象，根据实际的构造函数调用对应的子类对象的方法。 父类引用无法直接使用子类对像特有的方法 3.多态 多态是方法的多态，属性没有多态性 3.1 instance of 操作符 格式：[左值] instanceof [右值]\n左值与右值之间需要有直系的继承关系（一条继承路线上）才可以使用，否则编译器直接报错 左值可以是父类的指针，返回结果取决于左值指向的具体类，即new出来的对象类型。 实际上比较是左值 new 实例类型是否是右值的实例。其中子类是父类的实例，返回true 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Object是Person的父类，Person是Man和 Woman 的父类 Man man=new man(); System.out.println(man instanceof Man);//true System.out.println(man instanceof Person);//true System.out.println(man instanceof Object);//true System.out.println(man instanceof Woman);//编译器直接报错！ System.out.println(man instanceof String);//编译器直接报错！ Pertson person =new man(); System.out.println(person instanceof Man);//true System.out.println(person instanceof Person);//true System.out.println(person instanceof Object);//true System.out.println(person instanceof Woman);//编译器直接报错！ System.out.println(person instanceof String);//编译器直接报错! 4.类型转换 强制类型转换一般用于父类引用调用子类中其独有的方法。\n因为父类比子类更高级，低转高可以直接使用，所以父类引用可以直接接受子类的引用。\n高转低需要直接强制类型转换。父类引用调用子类中其独有的方法需要先把高的父类强制转换成子类。\n","date":"2023-12-22T22:30:20+08:00","image":"https://4evergreat.github.io/cover/201706161557596027.jpg","permalink":"https://4evergreat.github.io/2023/java-blog-12/","title":"Java-blog-12多态知识点综合"},{"content":"常用快捷命令： 移动类 Ctrl + D ： 复制当前行到下一行（*重点 **） Ctrl + Y ： 删除当前行代码（*重点 **） Ctrl + shift + ↑ ： 向上移动代码（把指定代码向上挪位置）（*重点 **） Ctrl + shift + ↓ ： 向下移动代码 Alt + shift + ↑ ： 向上移动一行 （*重点 **） Alt + shift + ↓ ： 向下移动一行 shift + Enter : 切换到下一行代码空位（例如：从当前行任意位置跳转到并新建一行） Ctrl + shift + Enter : 切换到上一行代码空位（例如：从当前行任意位置跳转并新建一行） Ctrl + alt + L : 格式化代码，即自动调格式（如对齐操作） alt + ← ： 切换到左侧文件窗口 alt + → ：切换到右侧文件窗口 Ctrl + alt + ← : 查看上一个超链接（有点像浏览器前进后退，常在溯源源码的时候使用） Ctrl + alt + ← : 查看下一个超链接 Ctrl + g : 快速跳转到指定行的代码 home : 光标跳转到当前行行首 end ： 光标跳转到当前行行末 tap : 把选中区域的代码向右移 shift + tap : 把选中区域的代码向左移 文件操作类 shift + F6 : （批量）文件快速重命名（*重点 **）（*重点 **） shift + F6 还可以修改代码中指定的变量名、方法名、类名等。例如整体修改某个变量的名字（像查找全替换）（*重点 **）（*重点 **） Ctrl + h : 查看类的继承关系 Ctrl + alt + m : 抽取代码重构方法 (抽取指定代码进行封装） （*重点 **）（*重点 **） Ctrl + q : 查看方法文档 Ctrl + alt + u : 查看类的UML关系图 Ctrl+N，可以快速打开类，可用于查找源码 快捷注释类（重点*） Ctrl + / : 单行注释与取消\nCtrl + shift + / : 多行注释与取消\n/** + enter ： 方法或者类的说明注释， 自动根据参数和返回值生成注释\n快捷生成类 ctrl + alt + t : 给选中区域套一层结构（*重点 **） alt + insert : 快速生成get、set、构造器等（*重点 **）\nalt + Enter ： 智能提示 （*重点 **）\nCtrl + alt + v : 自动生成返回值变量\nCtrl + p : 方法形参列表提醒\nnumber.for+ enter: 快速创建for 循环，循环次数为number （*重点 **）\n1 2 // 100.for 1for (int i = 0; i \u0026lt; 100; i++) { } sout（小写）+ enter : 快速编写 （*重点 **）\n1 System.out.println( ); psvm（小写）+ enter : 快速编写\n1 2 public static void main(String[] args) { } Ctrl + O : 重写父类方法（有点像alt + insert 专用化的衍生品）（*重点 **）\nCtrl + i : 实现接口方法（*重点 **）\nCtrl + shift + U ： 选中区域大小写转换\n以下为未验证的复制黏贴： Ctrl+Shift + Enter，语句完成 “！”，否定完成，输入表达式时按 “！”键 Ctrl+E，最近的文件 Ctrl+Shift+E，最近更改的文件 Shift+Click，可以关闭文件 Ctrl+[ OR ]，可以跑到大括号的开头与结尾 Ctrl+F12，可以显示当前文件的结构 Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择 Ctrl+N，可以快速打开类 Ctrl+Shift+N，可以快速打开文件 Alt+Q，可以看到当前方法的声明 Ctrl+P，可以显示参数信息 Ctrl+Shift+Insert，可以选择剪贴板内容并插入 Alt+Insert，可以生成构造器/Getter/Setter等 Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch Ctrl+Enter，导入包，自动修正 Ctrl+Alt+L，格式化代码 Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作 Ctrl+Alt+O，优化导入的类和包 Ctrl+R，替换文本 Ctrl+F，查找文本 Ctrl+Shift+Space，自动补全代码 Ctrl+空格，代码提示（与系统输入法快捷键冲突） Ctrl+Shift+Alt+N，查找类中的方法或变量 Alt+Shift+C，最近的更改 Alt+Shift+Up/Down，上/下移一行 Shift+F6，重构 - 重命名 Ctrl+X，删除行 Ctrl+D，复制行 Ctrl+/或Ctrl+Shift+/，注释（//或者/**/） Ctrl+J，自动代码（例如：serr） Ctrl+Alt+J，用动态模板环绕 Ctrl+H，显示类结构图（类的继承层次） Ctrl+Q，显示注释文档 Alt+F1，查找代码所在位置 Alt+1，快速打开或隐藏工程面板 Ctrl+Alt+left/right，返回至上次浏览的位置 Alt+left/right，切换代码视图 Alt+Up/Down，在方法间快速移动定位 Ctrl+Shift+Up/Down，向上/下移动语句 F2 或 Shift+F2，高亮错误或警告快速定位 Tab，代码标签输入完成后，按 Tab，生成代码 Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失 Alt+F3，逐个往下查找相同文本，并高亮显示 Ctrl+Up/Down，光标中转到第一行或最后一行下 Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处） Ctrl+Alt+B，跳转到方法实现处 Ctrl+Shift+Backspace，跳转到上次编辑的地方 Ctrl+O，重写方法 Ctrl+Alt+Space，类名自动完成 Ctrl+Alt+Up/Down，快速跳转搜索结果 Ctrl+Shift+J，整合两行 Alt+F8，计算变量值 Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本 Ctrl+Alt+Shift+V，简单粘贴 Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口 F12，把焦点从编辑器移到最近使用的工具窗口 Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器 Ctrl+W，可以选择单词继而语句继而行继而函数 Ctrl+Shift+W，取消选择光标所在词 Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置 Ctrl+I，实现方法 Ctrl+Shift+U，大小写转化 Ctrl+Y，删除当前行 Shift+Enter，向下插入新行 psvm/sout，main/System.out.println(); Ctrl+J，查看更多 Ctrl+Shift+F，全局查找 Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找 Ctrl+Shift+S，高级搜索 Ctrl+U，转到父类 Ctrl+Alt+S，打开设置对话框 Alt+Shift+Inert，开启/关闭列选择模式 Ctrl+Alt+Shift+S，打开当前项目/模块属性 Ctrl+G，定位行 Alt+Home，跳转到导航栏 Ctrl+Enter，上插一行 Ctrl+Backspace，按单词删除 Ctrl+\u0026quot;+/-\u0026quot;，当前方法展开、折叠 Ctrl+Shift+\u0026quot;+/-\u0026quot;，全部展开、折叠 ","date":"2023-12-22T22:27:20+08:00","image":"https://4evergreat.github.io/cover/01eb6558dc7021a801219c77252192.jpg@3000w_1l_0o_100sh.jpg","permalink":"https://4evergreat.github.io/2023/idea-blog-1/","title":"IDEA-blog-1 IDEA常见的命令"},{"content":"1. 异常的概述 在编程中，我们经常遇到各种不可预见的问题，例如：文件找不到、网络连接失败、数组越界等。这些问题我们通常称之为“异常”（Exception）。\njava 把异常当作对象来处理，并定义了一个基类 java.lang.Throwable作为所有异常的超类。 java.lang.Throwable主要分为两类 错误Error 和 Exception 。\n常用概念：\n异常类（Exception class）: Java 中的所有异常类都继承自 java.lang.Throwable 类。 Error：这是 Throwable 的一个子类，错误通常包含那些不应由应用程序处理的严重问题。 Exception：这是 Throwable 的另一个子类，它表示程序可 以处理的问题。比如尝试打开一个不存在的文件等。 抛出异常（Throwing an exception）：当程序发生一个异常时，会创建一个异常对象，并将其抛出，提交给 Java 运行时系统。 捕获异常（Catching an exception）：这是对抛出异常的响应。当一个方法抛出一个异常时，这个异常可以被另一个方法捕获并处理 检查异常（Checked Exceptions）：编译器要求必须处置的异常。对于 Exception 及其子类（不包括 RuntimeException 及其子类），编译器强制我们在可能抛出异常的代码中使用 try-catch 语句，或者将异常传递给调用者（通过在方法签名中添加 throws 子句） 非检查异常（Unchecked Exceptions）：对于 RuntimeException 及其子类，编译器并不强制我们处理或声明它们。我们可以选择捕获它们，但也可以忽略它们，让它们在程序运行时自动抛出。非检查异常通常由程序逻辑错误引起，我们应该通过改正程序来避免它们，而不是试图恢复 2.异常的体系结构 任何可以作为参数传递给 catch 子句的类都必须是 java.lang.Throwable 类或者其的子类\nException 类主要有两个子类：IOException 和 RuntimeException。IOException 类是那些可能会导致输入输出操作失败的异常，例如读取不存在的文件。而 RuntimeException 则包括程序逻辑错误，如数组越界、空指针访问等\n3.异常的用途 错误处理：最直接的用途就是处理错误。例如，当你尝试打开一个不存在的文件或者尝试连接一个无法响应的网络服务时，Java 会抛出一个异常。你可以捕获这个异常并决定如何处理它，例如，重新尝试操作，或者显示一条错误信息。 通过错误处理可以避免 JVM 直接停止，防止程序直接崩了 流程控制：虽然使用异常来做流程控制不是一个良好的编程习惯，但在某些特殊情况下，它可以作为一种很有效的流程控制手段。例如，在一个大的循环结构中，当满足特定条件时，你可能希望退出循环，这时可以抛出一个异常。 4.Throwable 类 4.1Throwable 类里常用方法包括： public String getMessage()：返回关于发生的异常的详细信息。这个信息在 Throwable 对象被创建时通过其构造函数设置。 public Throwable getCause()：返回导致异常的原因，或者如果原因不存在或未知，则返回 null。 public String toString()：返回一个简短的描述，包含异常的类型和详情信息。 public void printStackTrace()：将此 Throwable 及其回溯打印到标准错误流。 4.2 抛出异常的过程 通过使用 new 关键字 + Throwable 类或其子类的构造函数来创建一个 Throwable （子类）对象 使用 throw 关键字来抛出 Throwable（子类）对象。 throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开 1 2 3 4 5 6 7 8 9 10 11 12 修饰符 返回值类型 方法名() throws 异常类型1,异常类型2{ //注意上面这里是throws,不是throw。而且是异常类型，不是对象 if (判断条件) { //注意此处是throw,不是throws，而且是异常对象 throw new 异常对象(\u0026#34;异常的原因\u0026#34;); } //方法体 } //生成异常对象是实例，这里的Throwable也可以用其子类代替 Throwable throwable = new Throwable(”发现一个异常！“); throw throwable;//注意此处是throw,不是throws 4.3 捕获异常与处理异常 try-catch 语句 使用 try-catch 语句来捕获和处理异常。在 try 块中，我们放入可能会抛出异常的代码，然后在后面的 catch 块中捕获抛出的异常对象并处理这些异常。\n1 2 3 4 5 6 /*多个异常一次捕获一次处理 + 没写finally*/ try{ //可能会抛出异常的代码块 }catch(异常类型**对象**){ //处理异常的代码块 } try-catch-finally 语句 1 2 3 4 5 6 7 8 9 10 /*多个异常一次捕获多次处理 + fianlly*/ try { // 可能抛出异常的代码 } catch (ExceptionType1 e) { // 处理 ExceptionType1 异常 } catch (ExceptionType2 e) { // 处理 ExceptionType2 异常 } finally { // 无论是否抛出异常，都将执行的代码 } 多次处理实际上是一次处理\n多个catch的效果像 if \u0026hellip; else if 一样，所以在前面的判断条件需要弱于后面的，不然后面的catch永远不会执行。所以 前面的异常类型 不能是 后面异常类型的父类。\n有关 finally { }：\n无论异常是否发生，finally 内的语句都需要执行。因为异常会引发程序跳转，导致有些语句执行不到。而 finally 就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的\nfinally不能单独使用。必须配合着try…catch使用\n当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。\n通常在finally 代码块内添加语句来释放占用的资源\n多个异常使用捕获又该如何处理呢？\n多个异常分别处理\n多个异常一次捕获多次处理\n多个异常一次捕获一次处理\n4.4 assert 断言 1 2 3 4 assert condition : error message; // condition 是一个布尔类型的条件表达式，表示需要检查的条件 //error message 是一个字符串类型的错误提示信息 //如果 condition 的值为 false，则程序会在此处抛出 AssertionError 异常，输出 error message 指定的错误提示信息。 断言是编程中常用的一种技术手段，它用于在程序执行时验证某些条件是否满足。如果条件成立，则程序继续执行；否则程序抛出AssertionError 异常，直接终止。 注意！！！AssertionError 继承自 Error 类，是一个严重的错误，表示程序已经出现了无法处理的异常情况，会导致程序直接终止 断言的主要作用是在开发和调试阶段快速定位和解决问题，有效避免因为程序中存在非预期的逻辑错误而导致程序崩溃或产生误判的情况。相对于传统的 if/else 或 try/catch 方式，使用 assert 断言可以更加简洁明了地表达程序的状态或逻辑关系，提高程序的可读性和可维护性。 在使用 assert 断言时，需要注意断言语句只是一种辅助手段，不能替代异常检查。如果某个条件验证失败会产生正常异常，那么应该使用传统的异常处理机制来处理，并不应该使用断言语句。 5.自定义异常 - 自定义异常类 其实很简单， 只需要继承 Exception 类就行了\r1 2 3 4 5 public class MyException extends Exception{ //构造器 //带参构造器 //重写toString() } 源码示例： ArrayIndexOutOfBoundsException类（数组索引越界）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException { private static final long serialVersionUID = -5116101128118950844L; /** * Constructs an \u0026lt;code\u0026gt;ArrayIndexOutOfBoundsException\u0026lt;/code\u0026gt; with no * detail message. */ public ArrayIndexOutOfBoundsException() { super();//源码溯源会发现是在套娃调用 Exception 类内的方法 } /** * Constructs a new \u0026lt;code\u0026gt;ArrayIndexOutOfBoundsException\u0026lt;/code\u0026gt; * class with an argument indicating the illegal index. * * @param index the illegal index. */ public ArrayIndexOutOfBoundsException(int index) { //实际上就是toSting() super(\u0026#34;Array index out of range: \u0026#34; + index); } /** * Constructs an \u0026lt;code\u0026gt;ArrayIndexOutOfBoundsException\u0026lt;/code\u0026gt; class * with the specified detail message. * * @param s the detail message. */ public ArrayIndexOutOfBoundsException(String s) { super(s);//本质还是toString,不过这个是为了让其子类套娃调用 } } 6.日志 ","date":"2023-12-21T22:30:20+08:00","image":"https://4evergreat.github.io/cover/d26771814a8ca1f2cdb.jpg_r_720x400x95_548232fe.jpg","permalink":"https://4evergreat.github.io/2023/java-blog-15/","title":"Java-blog-15java异常与日志"},{"content":"写在最前面\n网上关于内部类的 blog 很多很乱，甚至写错的也不少。所有我写了一篇笔记，还算齐全，欢迎补充与指正！\n1. 内部类的含义 内部类就是在一个类的内部再定义一个类。比如A类中定义了一个类B，那么 B就是A 的内部类，A是B的外部类\n1 2 3 4 class A{//外部类 class B{//内部类 } } 内部类可以分为：成员内部类、静态内部类、局部内部类、匿名内部类。分类逻辑为（这个分类不精准，只是辅助理解）\n从内部类是类的角度看：\n内部类也可以声明属性、方法、构造器； 内部类也可以继承父类或者接口； 可以用final修饰，让这个内部类不被继承； 可以用abstract修饰 ？？？ 那内部类是抽象类的话，外部类是抽象类吗？ 从内部类是外部类成员的角度看：\n内部类可以调用外部类的结构，包括 外部类中 private 修饰的内容； 内部类可以用 public 、省缺默认、protected、private 修饰； 可以用 static 修饰，作为外部类的静态成员，定义时与外部类一起加载（有点像静态变量、方法与类的关系）； 2.和3.中的重点：内部类可以使用private 和 static 修饰，外部类不可以！ JDK8不支持在成员内部类定义static成员，JDK16才开始支持！ 1.1 关于非静态内部类是否支持 static 的探讨 （主要是成员内部类）\n先聊聊类与类的关系\nhas-a、 is-a 、like-a 与 use-a has-a : 从属关系，如包含。 整体与部分的关系，一个拥有独立存在，但是生命周期应该一致 is-a : 继承关系，如类继承、接口实现 like-a : 具体与抽象的关系，如 抽象类继承与接口实现（可以当作是is-a 的特例） use-a : 使用关系，一个类和另外一个类的属性或方法之间的关系，依然是其中一个拥有另外一个，但是不负责销毁，也就是声明周期不一样，如方法栈，一个类中 new 另一个对象 再聊聊内部类\n内部类自己的继承与实现的行为是 is-a 或者 like-a 外部类包含成员内部类这一行为像是 has-a，但不像是use-a。因为成员内部类是依附外部类实例而存在的 外部类包含静态内部类的这一行为像has-a，且也像是 use-a。因为静态内部类可以独立于外部类实例而存在 回归到static\n成员内部类强调的是成员，即外部类实例的一个成员。成员内部类是依附外部类实例而存在的，这一点是由创建内部类的过程决定的，需要先创建外部类实例，再通过外部类实例来new成员内部类。如果成员内部类中的方法或者属性可以是static，那它不就可以独立存在了？从分类与用途的角度来看，这样它就完全可以取代了静态内部类的工作；从创建的角度看，总所周知，静态属性和方法是可以直接通过类名来调用的，这一点与它的实现相违背；从概念的角度看，static就是共享，有驳于实例私有。 所有 成员内部类中不应有static属性或者方法，对于有static属性或者方法的应该声明为静态内部类。这也是（包含 JDK8 在内）JDK15及之前的 JDK 版本的实现逻辑。\n上述理解只是在对号入座，看了答案后再填过程。实际上，java长期以来允许在非静态嵌套类中使用静态常量变量，例如字符串文字。\n1 2 3 4 5 6 7 8 9 class OuterClass { void foo() { class Inner{ static final int a = 5; // fine static final String s = \u0026#34;hello\u0026#34;; // fine static final Object o = new Object(); // compile error, because cannot be written during compilation } } } JDK16中引入了新变化：成员内部类中也可以有static属性或者方法！！！\n1.2 内部类编译文件解析 2.内部类的作用 封装和隐藏实现细节：内部类可以访问外部类所有成员，这样可以将一些实现细节封装在内部类中，从而对外部类隐藏实现细节，提高代码的安全性和可维护性。 间接实现多继承：Java 不支持类的多继承，但是一个外部类可以包含多个内部类，这些内部类可以继承不同的类或实现多个接口，从而间接实现了多继承的效果。 回调和事件处理：内部类特别是匿名内部类通常用于实现回调和事件处理。 3.内部类的用法 如果声明内部类时不使用任何修饰符，那么默认是public static（静态内部类）\n声明在接口中的内部类，默认是public static。\n3.1.成员内部类 成员内部类的用法类似于实例变量。所以创建成员内部类需要先创建了外部类实例才行。\n3.1.1加载顺序（此处与静态内部类不同！） 生成一个内部实例的执行顺序为：\n先加载外部类的静态代码块（按照上下顺序） 加载外部类的构造方法 先加载内部类的静态代码块（按照上下顺序） 加载内部类的构造方法 3.1.2 实例化格式（此处与静态内部类不同！） 先实例化一个外部类，再通过外部类的实例new 一个内部类的实例，该内部类实例的类型为 Outer.Inner。（成员内部类是依附外部类而存在的）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 格式 外部类实例.new 内部类的构造函数（）； public class Outer { public class Inner{} } public static void main(String[] args) { //方式一： 先创建非匿名外部实例，再用外部实例 new 成员内部类实例 //先创建非匿名外部实例 Outer outer = new Outer(); //再通过这个外部类的实例来实例化内部类 Outer.Inner inner1 = outer.new Inner();//注意new的位置,成员内部类与静态内部类不同 // Outer.Inner inner = new outer.Inner();//错误的格式 //方式二：通过匿名外部类实例直接 new 成员内部类实例 Outer.Inner inner2 = new Outer().new Inner(); } 3.1.3 内部类外部类的访问逻辑与范围 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class Outer { private int outerId = 10; public void sameOut(){System.out.println(\u0026#34;外部类同名的方法被调用\u0026#34;);} public void outerOut(){System.out.println(\u0026#34;外部类非同名的方法被调用\u0026#34;);} /* **********外部类如何调用内部类的属性与方法*********** */ /*public int getInnerId(){ //错误示范 innerOut();//报错 return innerId;//报错,不能直接通过不到innerId }*/ public int getInnerId(Inner in){ //通过实例来调用 in.innerOut();//成功 return in.innerId;//成功 } /*外部类调用成员内部类的总结： 1. 不能通过属性名或者方法名直接获取内部类的属性。因为成员内部类加载在外部类之后，无法直接找到 2. 只能通过内部类的实例来调用内部类的属性或者方法 3. 也就是说外部类无法访问内部类的属性名或者方法 */ public class Inner{ //内部类也可以是public!!! private int innerId = 20; public void sameOut(){System.out.println(\u0026#34;内部类同名的方法被调用\u0026#34;);}//与外部类方法同名没报错！ public void innerOut(){System.out.println(\u0026#34;内部类非同名的方法被调用\u0026#34;);} /* **********内部类如何调用外部类的属性与方法*********** */ public int getOuterId(){ //outerOut();//报错 Outer.this.outerOut();//成功 return outerId;//outerId是private,所以内部类可以获取外部类的私有属性 } /*成员内部类调用外部类的总结： 1. 可以通过属性名直接获取外部类的属性，甚至包括访问权限为private的部分。因为内部类也在外部类声明中 2. 不能通过方法名直接获取外部类的方法，这点与继承不同。从成员的角度看应该能访问到才对，所以java提供了以下3.中的是实现方式。 3. 可以通过 `外部类名.this.外部方法()` 来直接调用外部类的方法 4. 内部类中的 this 指内部类自己的引用；外部类名.this 才是内部类对应外部类的引用 */ }； } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class main { public static void main(String[] args) { /* ***********同名同参方法的调用*************** */ Outer outer = new Outer(); //再通过这个外部类的实例来实例化内部类 Outer.Inner inner = outer.new Inner(); outer.sameOut();//外部类同名的方法被调用 inner.sameOut();//内部类同名的方法被调用 /* ***********不同名方法的调用*************** */ //自己调用 outer.outerOut();//外部类非同名的方法被调用 inner.innerOut();//内部类非同名的方法被调用 //交叉调用 //inner.outerOut();//报错 //outer.innerOut();//报错 inner.getOuterId();//外部类非同名的方法被调用 outer.getInnerId(inner);//内部类非同名的方法被调用 /*成员内部类与外部类的调用的总结： 1. 外部类与成员内部类可以有同名同参的方法，不会报错 2. 用方法名调用同名同参方法，外部类、内部类引用会调用各自的方法 3. 外部类只能通过成员内部类的实例来调用内部类的方法，无论是否同名同参 4. 成员内部类可以通过 `外部类名.this.外部方法()` 来直接调用外部类的方法 */ } } 3.2 静态内部类（编译器源码用的比较多） static可以修饰内部类，非内部类不能被它修饰\n使用static修饰符修饰的内部类称之为静态内部类，也有人称静态内部类为静态嵌套类（其他三者为非静态嵌套类）\n创建静态内部类不会加载外部类的静态代码块，不会调用外部类的构造方法，所有内部类无妨访问外部类非静态成员属性\n内部类中只有静态内部类才可以有静态属性或者方法（JDK16之前的版本）\n1 2 3 4 5 6 7 public class A{//外部类 private int id; public static class B{//静态内部类 public int getOuterId(){//获取外部类的私有属性 return id;//报错，静态内部类无法访问外部类的非静态属性 } } 3.2.1 加载顺序 创建静态内部类不会加载外部类的静态代码块，不会调用外部类的构造方法\n先加载内部类的静态代码块（按照上下顺序） 加载内部类的构造方法 3.2.2 实例化格式 1 2 3 4 5 6 7 8 9 10 11 12 13 // 格式 new 外部类名.内部类的构造函数（）； public class A{//外部类 public static class B{//静态内部类 } } public static void main(String[] args) { //直接通过new 静态内部类的构造函数创建实例，但是需要用`外部类.内部类`为了表明内部类的声明位置，此处的 `外部类.`相当于作用域 Outer.Inner inner2 = new Outer.Inner(); //Warning：通过匿名外部类实例直接 new 成员内部类实例 Outer.Inner inner2 = new Outer().new Inner();//不推荐，通过实例调用静态属性或者方法编译器都会Warning } 3.2.3 调用逻辑 静态内部类可以直接访问外部类的静态成员，如果访问外部类的实例成员，必须通过外部类的实例去访问。 可以通过完整的类名直接访问静态内部类的静态成员，完整类名指 外部类名.内部类名 3.3. 局部内部类（可以认为是函数内部类） 定义在方法内的内部类，我们称之为局部内部类。\n局部类不能用public或private修饰符进行声明。它的作用域被限定在声明这个局部类的块中。\n局部类有一个优势, 即对外部世界可以完全地隐藏起来。\n3.4.匿名内部类 匿名内部类就是继承了某个接口或者某个类的没有名字的局部内部类。相当于在局部给某个接口或者某个类写了个没有名字的子类。\n它是局部内部类，一般写在方法体中，临时创建并调用，作用时长就是方法的时长 它是一个没有名字的类，通常用重写它的父类来定义 它必须是某个已经定义的接口或类的子类。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public interface MyIntertface{//定义了一个接口 public abstract void fun(); } //在测试类的方法中创建一个该接口的匿名实现类，即匿名内部类 public class Test{ public static void main(String[] args){ //创建匿名内部类 MyInterface a = new MyInterface(){ @Override void fun(){System.out.println(\u0026#34;success\u0026#34;);}//重写接口的方法 } /* 显然 Interface 接口不应该有构造方法，而且接口不能直接创建实现类。那么上述代码怎么解释呢？ *\t1. 等号左边的 MyInterface a 实际上是在用父类的引用指向子类的对象 *\t2. 等号又边的 new MyInterface(){//重写} 实质上创建了一个接口的是实现类。 * 3. 显然等号右边这个类是没有类名的 * 如果有类名的话，相当于如下代码： */ a.fun(); } } //如下代码可以实现上述的等价效果 public interface MyIntertface{//定义了一个接口 public abstract void fun(); } public class MyInterfaceInmpl implements MyInterface{ @Override public void fun(){System.out.println(\u0026#34;success\u0026#34;);}//重写 } //在测试类的方法中创建一个该接口的匿名实现类，即匿名内部类 public class Test{ public static void main(String[] args){ //创建实现类实例,且用接口的引用指向其实现类 MyInterface a = new MyInterfaceInmpl(); a.fun(); } } /* 在上面的代码中，实现类MyInterfaceInmpl全程只使用一次， * 为了这一次的使用要去创建一个类，未免太过麻烦。那么我们可以使用匿名内部类 */ ","date":"2023-12-15T22:30:20+08:00","image":"https://4evergreat.github.io/cover/d40f-ikvenft5321203.jpg","permalink":"https://4evergreat.github.io/2023/java-blog-14/","title":"Java-blog-14java内部类"},{"content":"1.抽象类格式 关键字： abstract 1.1抽象类： 1 2 3 4 5 abstract class 类名{} public abstract class ClassName{ int a; public abstract void fun(); } 除非该继承的子类也是抽象类，否则继承了抽象类的所有类都要重写抽象类的抽象方法\n不能 new 一个 java 抽象类，有点像c++中的抽象类，即含纯虚函数的抽象类，需要子类完全重载（java中的重写）后才能生成实例\n抽象类内可以有变量，变量写法与普通类一致\n抽象类中有构造方法\n1.2 抽象类内的抽象方法 1 2 3 修饰符 abstract 返回值类型 方法名(参数列表)； public abstract void fun();//不能写函数体代码块 抽象类不一定有抽象方法，但是有抽象方法的类必须定义成抽象类\n不包含抽象方法的抽象类，目的就是不想让调用者实例化该对象，通常用于某些特殊的类的结构设计\n抽象方法的修饰符可以是 public 或者是 protected, 省缺情况下默认是 public\n抽象类的构造方法能不能是抽象方法？\n1 2 3 4 5 6 7 public abstract class Student { String name; abstract Student();//直接报错！ } /*抽象类的构造方法不能是抽象方法 原因很简单：执行子类构造函数之前需要执行父类的构造函数，如果父类的构造函数可以是抽象方法的话，需要在子类重写，但是调用父类构造函数时，子类的构造函数尚未执行，哪来的重写？ */ 1.3 抽象类中静态方法的调用 直接 [抽象类].[静态方法] ！！！ 1 2 3 4 5 6 7 8 9 10 public abstract class Student { public static void fun(){}; public abstract void fun2(); } public class main { public static void main(String[] args) { Student.fun(); } } 2.接口 ​\t**接口的本质是规范，定义的是一组规则 **\n类的关键字是class, 接口的关键字是 interface\n1 2 class Person{}//类 interface Person{}//接口 接口内的所有方法都是抽象的，不能写函数体代码块\n接口内的方法都是 （public abstract） 类型，不写的话编译器自动补全\n接口与抽象类一样，其内同样可以定义变量\n接口内定义的变量都是 （public static final） 类型的全局静态常量，所有比较少用\n1 2 3 4 5 interface Person{//接口 public static final String name= “name”; void getName(); public abstract void getName() } 2.1 实现类 实现了接口的类简称实现类\n接口都需要有实现类， 用法类似于类继承，把关键字 extends 换成 implements\n1 2 3 4 5 6 7 public class [实现类名 = \u0026#34;接口名\u0026#34; + Impl] implements [接口名],[接口名]{} 例如： public interface Person{}//接口 public interface Man{}//接口 public class PersonImpl implements Person,Man{}//实现类 注意：\n实现类还没有把继承的所有接口里的所有抽象方法全重写之前，编译器会一直报错，这是正常现象 正如上面格式中所写，一个实现类是可以继承多个接口的，也就是伪多继承！！！ 接口的多继承，在 implements 后可跟多个接口名，用逗号隔开，且都不需要在接口名字面前写关键字interface 实现类推荐的命名方式为 对应接口名 + Impl 2.2 JDK8、JDK9的新变化 JDK 8 之前接口只能定义抽象方法，JDK8中接口也可以定义默认方法 default 和静态方法 static。\n默认方法允许接口提供默认实现，从而减少实现类的工作量。当接口的实现类没有提供该方法的具体实现时，将使用默认方法 静态方法可以为接口提供与接口相关的工具方法，静态方法可以直接通过接口名来调用，而不需要创建实现类的实例。因为静态方法无法被实现类覆盖或继承。此外，不能通过 实现类.[方法] 的形式调用静态方法，这点与 class继承 不同。 JDK9可以定义私有方法 private。只能接口自己用，也就是被默认方法调用，所有相当于是JDK8的补充。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public interface MyInterface { default void fun1() { // 默认方法的实现代码,即实现代码是在接口中定义的 }//default 需要明写，因为不写默认是public static void fun2(){ //同上，实现代码是在接口中定义的 } } public class main { public static void main(String[] args) { MyInterface.fun2();//用接口名直接调用静态方法 //此处假设MyInterfaceImpl是MyInterface的实现类 MyInterfaceImpl.fun2();//报错，不能通过实现类调用父类接口的静态方法。只能通过接口名来调用。 } } 2.3 JDK8 默认方法冲突问题，（也叫接口冲突） 当一个实现类继承了多个接口（或者即继承类又继承接口），且接口（类）中有同名同参的默认方法时，实现类调用的是哪一个类的方法？冲突如何解决呢？\n2.3.1 显式调用接口的方法 显式调用 某个接口的默认方法（注意是显式调用！！！不是必须重写！，在不重写的情况下显式调用就不报错！）。\n格式：[接口名] . super . [默认方法名]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 interface A { default void doSomething() { System.out.println(\u0026#34;Do something in A\u0026#34;); } } interface B { default void doSomething() { System.out.println(\u0026#34;Do something in B\u0026#34;); } } class MyClass implements A, B { @Override public void doSomething() { A.super.doSomething(); // 显式调用接口A的默认方法 } } 2.3.2 实现类重写 如果实现类中重写就相当于同时对所有同名同参的默认方法方法都重写了。调用时也是用的实现类自己的重写方法。\n2.3.3 类优先原则 即继承了类又继承了接口，且有同名同参的方法。在子类没有重写方法的情况下，遵从类优先原则，实现类调用父类的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 interface A { default void doSomething() { System.out.println(\u0026#34;Do something in A\u0026#34;); } } Class B { void doSomething() {//注意此处没有default System.out.println(\u0026#34;Do something in B\u0026#34;); } } class MyClass extends class B implements A { //此时即继承了类又继承了接口。且有同名同参的方法 } 2.3.4 JDK8 接口冲突的总结 注意这里 父类、与父类接口有区别，父类是指class，父类接口指 interface。\n问：子类即继承了类又继承了接口，且有同名同参方法。直接以方法名的形式，调用的是哪个方法呢？ 子类若是重写了，则调用子类的方法； 若是子类没重写，则调用父类的方法（类优先原则：无论有多少个父类接口有同名同参方法，默认调用父类方法）； 若是子类没重写，且单个父类接口有同名同参方法时，与父类的操作逻辑一致。 多个父类接口都有同名同参方法时，不会调用接口的方法，直接报错； 问：子类、继承的父类与接口中都有同名同参方法，想要直接调用各自的方法又如何写呢？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 interface A { default void doSomething() {//注意此处是default,可以有代码块 System.out.println(\u0026#34;Do something in interface A\u0026#34;); } } interface B { default void doSomething() {//注意此处是default,可以有代码块 System.out.println(\u0026#34;Do something in interface B\u0026#34;); } } class SuperC { void doSomething() {//注意此处没有default System.out.println(\u0026#34;Do something in class SuperC\u0026#34;); } } class C extends class SuperC implements A,B { void doSomething() {//注意此处没有default System.out.println(\u0026#34;Do something in class C\u0026#34;); } //此时C即继承了类SuperC又继承了接口A,B。且有同名同参的方法. void fun(){ doSomething();//调用C自己的同名同参的方法 super.doSomething();//调用父类SuperC的同名同参的方法 A.super.doSomething();//调用指定父类接口A的同名同参的方法 } } 3.抽象类与接口的异同 异：\n接口中没有构造方法，抽象类中有构造方法 接口的关键字为interface 和 implements，抽象类的关键字为 class 和 extends 接口可以多继承，抽象类只有单继承 接口中的方法必须全是抽象方法，抽象类中可以有非抽象方法（此条不适用于 JDK8及其往后的版本） 接口中的变量都是 public static final 类型（全局静态常量），抽象类没有要求 接口的抽象方法一定是 public abstract， 抽象类的抽象方法可以是public abstract 或者是 protected abstract 接口的抽象方法省缺时默认为 public abstract， 抽象类的抽象方法只可以省缺public ,因为省缺默认是public, 而 abstract 必须写，不写就不是抽象方法了。 同：\n接口和抽象类的抽象函数都是用abstract 接口和抽象类都是为了定义一些约束 接口和抽象类都不能直接实例化，只有继承其的子类（接口为实现类）在完全重写抽象方法后，才能生成子类实例 **补充:**\n4.函数式接口（可以用lambda 表达式简化） 定义：只包含一个抽象方法（可以包含其他非抽象方法）的接口叫做函数式接口。正如上面所说，JDK8之后接口也可以定义默认方法和静态方法。\n注意：\n可以用 lambda 表达式进行创建该接口的实现类。注意若lambda表达式抛出一个非运行时异常，那么该异常须在该接口的抽象方法上声明。 与@Override 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解：@FunctionalInterface 。该注解可用于一个接口的定义上,一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法（equal和hashcode方法不算），否则将会报错。使用@FunctionalInterface 同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。但是这个注解不是必须的，只要符合函数式接口的定义，那么这个接口就是函数式接口。 可以用lambda 表达式简化实例化函数式接口\n函数式接口适用于函数式编程的场景，Lambda就是Java中函数式编程的体现，可以使用Lambda表达式创建一个函数式接口的对象，一定要确保接口中有且只有一个抽象方法，这样Lambda才能顺利的进行推导。 5. Lambda表达式 更多 Lambda 的知识推荐看这个贴子\n定义：lambda表达式即函数式编程，也被称为闭包，它将允许把函数作为一个方法的参数；即行为参数化，把函数作为参数传递进方法中。 Java 8提出了lambda表达式，在Java 8之前，如果想将行为传入函数，仅有的选择就是匿名类。 Lambda表达式可以取代大部分的匿名内部类 Lambda 表达式类似于方法，但它们不需要名称，可以有 return 返回值 1 2 3 4 lambda表达式格式： (params) -\u0026gt; expression (params) -\u0026gt; statement (params) -\u0026gt; { statements } 1 2 3 4 5 6 7 8 9 10 // Java 8之前： new Thread(new Runnable() { @Override public void run() { System.out.println(\u0026#34;A lot code to write!\u0026#34;); } }).start(); //Java 8方式： new Thread( () -\u0026gt; System.out.println(\u0026#34;write in one line!!!\u0026#34;) ).start(); ","date":"2023-12-13T22:30:20+08:00","image":"https://4evergreat.github.io/cover/chicago-downtown-1528367134taW.jpg","permalink":"https://4evergreat.github.io/2023/java-blog-13/","title":"Java-blog-13抽象类与接口"},{"content":"1. 求值策略 编程语言中方法之间进行参数传递时有个传递策略，该策略就被称为求值策略（Evaluation strategies）。求值策略分为两大基本类型，如果按照如何处理传递给方法的实际参数，分为严格的和非严格的两种求值策略。\n1.1 严格求值策略 传值调用(Call by value)\n将实参复制一份给形参，修改形参不会对实参造成影响。形式参数拿到的只是一个\u0026quot;局部拷贝\u0026quot;。\n传引用调用(Call by reference)\n在方法调用时将引用类型的实参地址值 复制 一份传递给形参，相当于形参和实参指向了同一个内存地址。引用传递会将实参的地址传递给形参，修改形参也就是在修改实参。\n传共享对象调用(Call by sharing)\n在传共享对象调用中，先获取到实际参数的地址，然后将其复制，并把该地址的拷贝传递给被调方法的形式参数。因为参数的地址都指向同一个对象\n注意：\n用类类型做形参时c++是调用拷贝构造函数创建整个类的副本，所以不会影响原值。 java 用类类型做形参时, 传的是原值的地址，修改形参会影响原值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class ShareObject { public static void main(String[] args) { //待共享对象 ShareObject shObj= new ShareObject(10); System.out.println(\u0026#34;修改前的值\u0026#34;+ shObj.geti());//修改前的值10 // changeByShareObject(shObj); System.out.println(\u0026#34;通过共享对象传递修改后的值\u0026#34;+ shObj.geti());//通过共享对象传递修改后的值20 /* * 1.创建了一个共享对象的类 shareObject，该类包含了一个私有成员变量i, * 2.调用 changeByShareObject 方法传递了 shObj 的引用在该方法中，修改了 i 的值为20. * 3.比较调用 changeByShareObject(ShareObject Obj) 前后 i 的值可以得出 Obj 可以改变 shObj 中 i 的值 * */ } private int i;//私有实例变量 public void seti(int value){ this.i=value;//通过方法修改实例变量的值 } public int geti(){ return this.i; } public ShareObject(int value){ this.i=value;//构造函数 } public static void changeByShareObject( ShareObject Obj){ Obj.seti(20);//共享对象调用改值 } } 1.1.1 传共享对象调用 到底是 传值调用 还是 传引用调用 的特例 从过程来看，都是复制了实参的地址传给形参，通过修改形参也可以实现修改实参。所以 传共享对象调用 会是传引用调用吗？\n《The Java™ Tutorials》中Reference data type parameters, such as objects, are also passed into methods by value. This means that when the method returns, the passed-in reference still references the same object as before. However, the values of the object’s fields can be changed in the method, if they have the proper access level.\njava 把传对象也认为是传值，应该把其归类为传值调用。其实也很好理解：\nnew 出来的对象是地址映射型的，[key] [addr]。把该实参的本质当作是一种映射关系 把地址复制过去的这一步不就是在赋值映射关系吗，这也就成了传值调用。 一句话：共享对象传递就是值传递，传递的值是对象的引用 1.1.2 总结 总之，在Java方法传参时，无论传递的参数是基本类型还是引用类型，都是值传递！切记一点，Java里面只有值传递，没有引用传递！\n1.2 非严格求值策略 2.可变参数 Java中的方法是可以带有多个参数的，理论上是可以无限个。但实际上一个方法的参数最好不要超过5个。在Java 5中提供了一个可变长参数，该参数允许我们在调用方法时传入不定长度的参数。其实本质上是基于数组来实现的。所以当我们不确定一个方法需要处理的参数个数时，都可以使用可变长参数。\n1 方法名（形参1, 形参2, ...）{} // 此处点点点就是可变参数的意思 可变参数的格式，就是在方法最后一个形参的后面加上三个点 “…“，表示该形参可以接受 0个参数值， 也可以是1个或者多个参数值，多个参数值会被当成数组传入。\n可变参数只能作为方法的最后一个参数，该参数的前面可以有也可以没有其他参数\n由于可变参数必须是 最后一个参数，所以一个方法最多只能有一个可变参数\nJava的可变参数，会被编译器转型为对应类型的数组\n可变参数在编译为字节码后，在方法签名中是以数组形态出现的。这两个方法的签名是一致的，不能作为方法的重载。如果同时出现，是不能编译通过的。可变参数可以兼容数组，反之则不成立。\n可变参数与其他参数列表非数组的同名方法构成重载\n1 2 public static void main(String[] args) {} //不兼容下面式子 public static void main(String... args) {} //兼容上式子，等价于上式 1 2 3 4 5 6 7 8 9 10 public class A{ //已有可变参数的方法 void fun(int... a){} //验证重载可行性 void fun(int a ){}//成功重载 void fun (int a , int b){}//成功重载 void fun(int a,int... a ){}//成功重载,不建议 void fun(int[] a){}//重载失败 } ","date":"2023-12-09T22:30:20+08:00","image":"https://4evergreat.github.io/cover/8599.jpg_wh860.jpg","permalink":"https://4evergreat.github.io/2023/java-blog-7/","title":"Java-blog-7Java方法知识点综合（求值策略与可变参数）"},{"content":"1. 静态方法与非静态方法的区别 静态方法在定义类的时候就随着类装载到了内存中，不会自动销毁，直到关闭 jvm 非静态方法只有实例化对象的时候才会分配内存，与实例化对象共存。 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Demo01 { //静态方法 修饰符 static public static void user(){ //sayHello1();//报错，静态方法不能直接调用非静态方法，因为其还没有分配内存，只能通过实例区调用。 sayHello2(); } //非静态方法 public void sayHello1(){ } public static void sayHello2(){ } public void sayHello3(){ user();//非静态方法可以直接调用静态方法 } } 2. 构造器（c++构造函数） 如果不显式地定义构造函数，编译时编译器会自动生成一个无代码块的无参构造函数 编写时如果添加了有参构造方法而未添加无参构造方法，那么编译器不会再默认添加无参构造方法。 如果只定义有参不定义无参，且后续还需要调用无参构造方法，编译器会报错！ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /*例如，如果不显式调用父类有参构造函数，且没写父类的无参构造函数的情况下： 子类会默认调用父类的无参构造函数，但是编译器无法找到一个无参构造函数，会报错！ */ public class A{ int a; public A(int a){this.a =a;} } public class B extends A{ //以下演示编译器默认的子类B的无参构造函数 public B(){ super();//编译器默认在方法体第一行调用父类的无参构造函数。找不到则报错！ } } //想要不报错，有以下两个方法： //1.自己写B的构造函数，且在方法体第一行写A类的有参构造函数 public class B extends A{ //以下演示编译器默认的子类B的无参构造函数 public B(int a){ super(a);//父类有参 } } //2.在A类中追加一个无参构造函数 public class A{ int a; public A(int a){this.a =a;} public A(){};//追加无参 } 3.修饰符 public, protected, private (与C++一致)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Person { String name; public Person(String name) { this.name = name; } //alt+insert可以快速选择生成getName()和setName函数 //通过规定对外接口，限制外部对内部变量的随便访问 public String getName() { return name; } public void setName(String name) { this.name = name; } } 4.代码块 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Person{ //匿名代码块 { System.out.println(\u0026#34;匿名代码块\u0026#34;)； } //加了Static为静态代码块 static{ System.out.println(\u0026#34;静态代码块\u0026#34;)； } //无参构造函数 public Person(){ System.out.println(\u0026#34;构造方法\u0026#34;)； } } //调用以下函数生成一个Person实例会产生什么结果呢？即上述三者的运行先后次序是什么呢？ new Person(); /* 静态代码块 匿名代码块 构造方法 */ //再执行一次呢？ new Person(); /* 匿名代码块 构造方法 */ 直接由{ }括起来的代码为代码块 普通代码块(叫匿名代码块)，再每次生成对象实例的时候都会执行一次，而且是先于构造函数执行 静态代码块，即 static { }，只有第一次定义实例的时候会执行，且其执行次序先于普通的代码块和构造方法 匿名代码块常用于赋初始值 5. final修饰符用于类 final 可以用于修饰类，放在class之后，类名之前\n被 final 修饰的类没有子类\n1 2 class final Person{} class Man extends Person{}//报错！Person已经是fianl,它不能生成子类 6.类实例化的过程 [原帖链接] (https://blog.csdn.net/qq_41860497/article/details/130335081)\n6.0 双亲委派机制 JVM提供以下三种classLoader 用于把class文件加载到JVM中：\nBootstrap classLoader:主要负责加载核心的类库(java.lang.*等)，构造ExtClassLoader和APPClassLoader。\nExtClassLoader：主要负责加载jre/lib/ext目录下的一些扩展的jar。\nAppClassLoader：主要负责加载应用程序的主函数类\n一个自编的class文件经过以下流程进入JVM：\n6.1 判断对象是否已经加载、链接、初始化 首先根据new对象的类名是否在常量池中定位到一个符号引用，并检查这个符号引用代表的类是否已经加载、解析和初始化。其实就是验证是否是第一个使用该类。如果是第一次使用该类，就会执行类的加载过程。\nJVM加载一个类的时候会创建一个instanceKlass，用来表示这个类的元数据，包括常量池、字段、方法等。存放在方法区。\n6.2 在 java堆 中创建对象 在new一个对象时，jvm创建instanceOopDesc，来表示这个对象，存放在堆区，其引用存放在栈区；平时说的Java Object Layout就是instanceOopDesc，它用来表示对象的实例信息； instanceOopDesc对应java中的对象实例，包括对象头（其中包含类定义的引用Klass，Klass 中定义了类方法），实例数据（对象真正存储的有效信息，包括程序代码中定义父类子类的各种类型的字段）。 ","date":"2023-12-09T22:30:20+08:00","image":"https://4evergreat.github.io/cover/0147435a123c52a80121985cfd8506.jpg@3000w_1l_2o_100sh.jpg","permalink":"https://4evergreat.github.io/2023/java-blog-9/","title":"Java-blog-9Java类对象"},{"content":"1. 数组声明 1 2 3 4 //方法一：首选 dataType[] arrayName; //方法二：非首选，像c++ dataType arrayName[]; 2. 数组创建 2.1 动态初始化 1 2 //不初始化，大小自行决定 dataType[] array = new dataType[arraySize]; 如果动态初始化会赋予该类型元素的默认值：0，0.0，false 可以指定数组长度，其中数组长度：arrayName.length; 1 2 3 4 5 //例如： //int[] a = new int[10];//创建了一个长为10的int型数组 int[] a; a = new int[10];// 4-5与3等价 System.out.println(a);//输出[I@1b6d3586 2.2 静态初始化 1 2 3 4 //不简写格式： dataType[] arrayName = new dataType[]{value1, value2, value3, ... }; //简写格式： dataType[] arrayName = {value1, value2, value3, ... }; 静态初始化，数组大小由系统根据初始赋值数量计算自动得出 不能手动给arraySize，即使和赋值数量相等也不行，也就是说第二个[]内不可以有参数 此种方式也保留了更改数组内每个值的权利 3. 数组的存放 3.1数组内容(元素)都是存放在堆中的。 无论数组是动态初始化还是静态初始化都用了 new 关键字来创建空间。静态初始化简写格式实际上也 new 了。 3.2 数组名存放在堆或栈中 数组名实际上是一个引用，存放的是堆区的地址值。这个变量存放在堆区还是栈区取决于它是局部变量还是实例变量。\n1 2 3 4 5 6 7 public class Number { int array = new int [10];//此array在堆区 public void fun(){ int array = new int [10];//此array在栈区 } } 3.2.1 地址扩展 1 2 int[] a = new int[10];//创建了一个长为10的int型数组 System.out.println(a);//输出[I@1b6d3586 地址值的格式含义 [I@1b6d3586\n[：表示当前是一个数组 I ：表示当前数组里面的元素都是int类型的 @：表示一个间隔符号。（固定格式） 1b6d3586：才是数组真正的地址值.(十六进制), 平时我们习惯性的会把这个整体叫作数组的地址值。 4.数组的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static void main(String[] args) { int[] array = new int[] {1,2,3,4,5}; int count = 0; //增强for遍历数组 for (int a:array) { System.out.println(\u0026#34;array[\u0026#34;+(count++)+\u0026#34;]=\u0026#34; + a); } System.out.println(\u0026#34;-------------\u0026#34;); array[2]=4;//通过下标修改元素的值 //普通for遍历数组 for (int i = 0; i \u0026lt; array.length; i++) { System.out.println(\u0026#34;array[\u0026#34;+i+\u0026#34;]=\u0026#34; + array[i]); } } 5.Arrays类 Arrays类里的方法都是静态方法可以通过Arrays.方法名()直接调用 1 2 import java.util.Arrays; ","date":"2023-11-28T22:30:20+08:00","image":"https://4evergreat.github.io/cover/10950a72292e948ac983fbae08abe0bd_720w.jpg","permalink":"https://4evergreat.github.io/2023/java-blog-8/","title":"Java-blog-8Java数组"},{"content":"1. 知识点 if ,switch, for, while等等和 C++、js等相似，需要注意以下几点：\n1.1 有关switch switch 中的 case value:\nvalue 类型可以是 byte , short, int, char。\nvalue 类型：string 类型是JDK7才开始支持的\n1.2 有关增强for 1 for (元素类型 变量名 : 需要遍历的数组或集合){//代码} 也称为for-each循环，是一种简化遍历数组和集合元素的语法结构。它可以遍历数组、集合或其他实现l了Iterable接口的数据结构。\n增强for循环是只读的，即不能通过它来修改数组或集合中的元素。即增强for循环不能对集合进行修改（添加、删除等）。如果需要在循环过程中对集合进行操作，仍然需要使用迭代器或传统的for循环。\n1 2 3 4 int[] numbers = {1, 2, 3, 4, 5}; for (int number : numbers) { System.out.println(number); } 1.3 有关带标签的for（像js） 如果我们需要在嵌套的循环中一次跳出多层循环或者跳过当前临近某几层迭代，可以使用带标签的 for 循环。先把要跳转的for 前添加标签，然后 continue 或者 break 后追加该标签即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 outer://自定义标签名 i for (int i = 0; i \u0026lt; 10; ++i){ inner：//自定义标签名 j for (int j = 0; j \u0026lt; 10; ++j){ for (int k = 0; k \u0026lt; 2; ++k){ if (k==1){ break outer; \\\\原本break只能跳转到inner层，但是追加标签后可以直接跳转到outer层 } } } } outer://自定义标签名 i for (int i = 0; i \u0026lt; 10; ++i){ inner：//自定义标签名 j for (int j = 0; j \u0026lt; 10; ++j){ if (j==1){ continue outer; \\\\原本continue只能跳过inner层的一轮，但是追加标签后可以直接跳过outer层的一轮 \\\\即跳过当前层for 循环的迭代，继续标签层for 循环的迭代 } } } ","date":"2023-11-27T22:30:20+08:00","image":"https://4evergreat.github.io/cover/3465BE68-3610-FFCA-660A-EE8DBB42D535.jpg","permalink":"https://4evergreat.github.io/2023/java-blog-6/","title":"Java-blog-6java逻辑结构(switch和增强for)"},{"content":"1. 包机制 1.1 语法格式 package pkg1[.pkg2[.pkg3\u0026hellip;]];\n注意：\n​\t此句必须放在文件最开始位置\n1.2 提倡的命名格式 一般利用公司的域名倒置作为包名\n如 www.baidu.com 其包名就推荐命名为 com.baidu.www\n1.3 引用包 import package pkg1[.pkg2[.pkg3\u0026hellip;]].(classname|*);\n​\t- 导入自定义文件时，一般无需添加文件类型 .(classname|*)，只写到文件名即可\n​\t- *号是万能符，可以简单理解成“所有”，和SQL一样用法\n例如：\n1 2 import java.utol.Date; import java.util.Scanner; 1.4 静态导入包 ​\timport static [包名] . [方法名];\nimport static [包名] . [类属性];\n方法名无需加括号，导入后可在该文件内直接调用该方法，无需再用 [包名] . [方法名]的形式 1 2 3 4 5 6 7 8 9 10 11 //使用静态导入包前 import java.lang.Math; System.out.println(Math.random()); System.out.println(Math.PI); //使用静态导入包后 import java.lang.Math.random; import java.lang.Math.PI; System.out.println(random()); System.out.println(PI); 1.5 JDK1.8 API文档 JDK8 API 在线文档 全英文\nJDK8 API 在线文档 中文\nJDK1.8 API文档中文与英文版的离线版：这个哥们提供了一个：\n下载源\n2. JavaDoc生成 2.1 命令行生成JavaDoc文档： javadoc -encoding UTF-8 -charset UTF-8 [文件名].java\n结果：\n生成了好几个文件，其中 index.html打开后与 1.4 节中的在线API文档界面相似\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 C:\\Users\\Administrator\\Desktop\\src\\base\u0026gt;javadoc -encoding UTF-8 -charset UTF-8 Doc.java 正在加载源文件Doc.java... 正在构造 Javadoc 信息... 标准 Doclet 版本 1.8.0_391 正在构建所有程序包和类的树... 正在生成.\\base\\Doc.html... Doc.java:14: 警告: @param 没有说明 * @param name ^ Doc.java:15: 警告: @return 没有说明 * @return ^ Doc.java:16: 警告: @throws 没有说明 * @throws Exception ^ Doc.java:4: 错误: 未知标记: auther * @auther wendao101 ^ 正在生成.\\base\\package-frame.html... 正在生成.\\base\\package-summary.html... 正在生成.\\base\\package-tree.html... 正在生成.\\constant-values.html... 正在构建所有程序包和类的索引... 正在生成.\\overview-tree.html... 正在生成.\\index-all.html... 正在生成.\\deprecated-list.html... 正在构建所有类的索引... 正在生成.\\allclasses-frame.html... 正在生成.\\allclasses-noframe.html... 正在生成.\\index.html... 正在生成.\\help-doc.html... 1 个错误 3 个警告 2.2 IDEA生成JavaDoc文档： Tool==\u0026gt;Generate JavaDoc\n其他参数设置：\noutput directory: 生成路径\nLocale：设置语言区域，决定文档的语言\n简体中文就是zh_CN、繁体(台湾)zh_tw、繁体(香港)zh-hk、英语(香港)en-hk、英语(美国)en-us、英语(英国)en-gb、英语(全球)en-ww Command line arguments：(其他命令行参数)：\n编码设置: 参数一般为-encoding UTF-8 -charset UTF-8 ","date":"2023-11-27T22:27:20+08:00","image":"https://4evergreat.github.io/cover/3027.jpg_wh860.jpg","permalink":"https://4evergreat.github.io/2023/java-blog-5/","title":"Java-blog-5java包机制和JavaDoc文件生成"},{"content":"1.Java三大版本 javaSE: 标准版（桌面程序，控制台程序开发）\nJavaME：精简版（嵌入式开发）\njavaEE：企业级开发（web开发，服务器开发）\n2.JDK、JRE、JVM JDK: java development kit\nJRE : java runtime envirnment\nJVM : java virtual machine\n其中 JDK包含了JRE与JVM。JRE包含了JVM。\n安装了JRE后既可以运行java程序。JDK比JRE 多了一些开发工具，所以开发需要装JDK。\nJDK包含的基本组件包括:\njavac – 编译器，将源程序转成字节码 javadoc – 文档生成器，从源码注释中提取文档 jdb – debugger，查错工具 jar – 打包工具，将相关的类文件打包成一个文件 3.安装JDK 1.如果Openjdk，输入 java -version显示的版本信息为 1 2 3 4 [machao@dev ~]$ java -version openjdk version \u0026#34;1.8.0_144\u0026#34; OpenJDK Runtime Environment (build 1.8.0_144-b01) OpenJDK 64-Bit Server VM (build 25.144-b01, mixed mode) 2.如果是Sun/Oraclejdk ,输入的java -version 显示的版本信息为 注意：java hotspot（TM） 64-BIT是说用的是64位的hotspot虚拟机 server 是说虚拟机运行在server模\t式下。 虚拟机有server 和client两种模式\n1 2 3 4 C:\\Windows\\system32\u0026gt;java -version java version \u0026#34;1.8.0_391\u0026#34; Java(TM) SE Runtime Environment (build 1.8.0_391-b13) Java HotSpot(TM) 64-Bit Server VM (build 25.391-b13, mixed mode) 3.在命令窗口输入 java -verbose，就可以查看安装路径 1 2 3 4 5 6 7 8 9 C:\\Windows\\system32\u0026gt;java -verbose [Opened C:\\Program Files\\Java\\jre-1.8\\lib\\rt.jar] [Loaded java.lang.Object from C:\\Program Files\\Java\\jre-1.8\\lib\\rt.jar] [Loaded java.io.Serializable from C:\\Program Files\\Java\\jre-1.8\\lib\\rt.jar] ... 有关详细信息, 请参阅 http://www.oracle.com/technetwork/java/javase/documentation/index.html。 [Loaded jdk.internal.misc.TerminatingThreadLocal$1 from C:\\Program Files\\Java\\jre-1.8\\lib\\rt.jar] [Loaded java.lang.Shutdown from C:\\Program Files\\Java\\jre-1.8\\lib\\rt.jar] [Loaded java.lang.Shutdown$Lock from C:\\Program Files\\Java\\jre-1.8\\lib\\rt.jar] 4. 安装JDK 建议下载JDK8, JDK11和JDK17, 其中企业运用JDK8比较多\n下载安装包 windows x86 JDK8 添加环境变量 JAVA_HOME 添加path 变量 %JAVA_HOME%\\bin //%%是路径引用 %JAVA_HOME%\\jre\\bin 用java -version检验 5.卸载JDK 删除Java的安装目录\n删除JAVA_HOME\n删除环境变量 PATH 下关于Java的目录\n用java -version检验\n","date":"2023-11-26T22:27:20+08:00","image":"https://4evergreat.github.io/cover/5a65990461edd3b5.jpg","permalink":"https://4evergreat.github.io/2023/java-blog-1/","title":"Java-blog-1JavaSE介绍与安装卸载"},{"content":"代码（用控制台便运行文件） 1 2 3 4 5 public class Hello{ public static void main(String[] args){ System.out.print(\u0026#34;Hello Word!\u0026#34;); } } 1. 创建文件 文件后缀名为.java\nHello.java\n[注意点]系统可能没有显示文件后缀名，我们需要手动打开\n窗口状态栏=\u0026gt;查看=\u0026gt;显示=\u0026gt;文件扩展名（勾选）\n2. 编译 : javac [文件名.java] 1 2 C:\\Users\\Administrator\\Desktop\\新建文件夹\\java\u0026gt;javac Hello.java //会生成 Hello.class 文件 3. 运行： java [文件名] 1 2 C:\\Users\\Administrator\\Desktop\\新建文件夹\\java\u0026gt;java Hello Hello Word! 在运行 Hello.class文件，但是不需要添加文件后缀\n可能会遇到的情况 Java大小写敏感， 如上述代码中 System, String[], public 的大小写区分 尽量使用英文 文件名 和 类名必须保证一致，并且首字母大写 符号使用的了中文 4. java 运行机制 ","date":"2023-11-24T22:27:20+08:00","image":"https://4evergreat.github.io/cover/41F215B9.jpg","permalink":"https://4evergreat.github.io/2023/java-blog-2/","title":"Java-blog-2用javac和java命令输出HelloWord"},{"content":"1. 注释 单行注释 //注释 多行注释 /* 注释 */ 文档注释 /** 注释 */ 2. 标识符命名规则 (与 js 规则一样) 标识符可以含有 字母, 数字, 下划线_, (*注意此处相较于 c 语言多出一个符)\n不能以数字开头\n不能是java中的保留字和关键字\njava也采用了 unicode 编码方式，所以字母也可以是中文\n建议采用驼峰法：\n-首字母小写，每个单词开头字母大写，其余均小写\r3.基本数据类型 3.1 整数型 类型 长度字节 位数 取值范围 备注 byte类型 1个字节 8位 -2^7 - 2^7-1 -128 - 127 short类型 2个字节 16位 -2^15 - 2^15-1 －32768－32767 int 类型 4个字节 32位 -2^31 - 1~2^31-1 long 类型 8个字节 64位 -2^63 - 1~2^63-1 末尾加L 注解：\n整型的范围与运行java代码的机器无关，这一点和C、C++不同，保证了代码在不同的平台之间的可移植型。\nint最为常用，char和short主要用于特定场合，比如底层处理文件、处理需要占用大量存储空间的数组。要表示的数据超过int类型的范围时使用长整型int.\n通常long类型后通常加字符“L”，例如 long a = 123L ; ， 但是\u0026quot;L\u0026quot;理论上不区分大小写，但若写成小写的\u0026quot;l\u0026quot;，容易与数字\u0026quot;1\u0026quot;混淆，不容易分辩，所以最好写成大写的“L”\n3.2 浮点型 类型 长度字节 位数 取值范围 备注 float 类型 4字节 32位 大约±3.402 823 47E+38F(有效位为6～7位) 末尾加f double 类型 8字节 64位 大约±1.79769313486231570E+308(有效位为15位) 注解：\n默认浮点数使用类型为double， 其后可加字符“d”,\u0026ldquo;d\u0026quot;理论上不区分大小写\n所以为了区分，通常浮点型末尾末尾加字符”f”, 例如 float a =3.1415926535f ;， \u0026ldquo;f\u0026quot;理论上不区分大小写\nfloat 和 double 不能用来表示精确的值，如不能用来表示货币等。实际使用 BigDecimal 类\n科学记数法: 结尾的\u0026quot;E+数字\u0026quot;表示E之前的数字要乘以10的多少次方。比如3.14E3就是3.14 × 103=3140，3.14E-3 就是 3.14 x 10-3 =0.00314\n显然±3.402 823 47E+38F范围大于-2^63 - 1~2^63-1，即float范围大于long，可惜float不是完全精确的。\n3.3 字符型 类型 长度字节 位数 取值范围 备注 char 类型 2个字节 16位 \\u0000 - \\uffff 0 - 65535 注解：\nJava的char类型可以表示标准的ASCII，\nchar类型还可以表示一个Unicode字符，代表一个单一的16位 Unicode 字符\n想要打印 Unicode 字符 可以使用 “\\u”+数字\n字符和字符串是两种不同的数据类型。char类型使用单引号\u0026rsquo;\u0026lsquo;表示，单引号里面只能有一个字符。字符串用双引号\u0026quot;\u0026ldquo;表示，双引号中可以有很多字符。\n3.4 布尔型 类型 长度字节 位数 取值范围 备注 boolean 类型 0字节 1 位 true or false 默认值是 false 注解:\nJAVA规范中没有定义boolean类型的大小, 理论上组需要1bit 即可，但是编译时有定义：JVM规范第2版 3.3.4节：\n单个的boolean 类型变量在编译的时候是使用的int 类型，4个字节(32bit) 但如果是boolean数组在编译的时候是作为byte array来编译的，每一个元件占1字节(8 bits) 3.5 对比总结 byte 作用类似于 c++中的char，但又无法直接存字符\nchar 大小与c++不同，多了一个字节，2字节可存 unicode, 所以可以是中文\njava 无 unsigned 类型\njava 常量的需要加修饰符 final，相当于c++中的 const\n3.6 类型转换 类型 byte =\u0026gt; short =\u0026gt;int =\u0026gt; long =\u0026gt; float =\u0026gt; double 优先级 低\u0026raquo;\u0026raquo;\u0026raquo;\u0026raquo;\u0026raquo;\u0026raquo;\u0026raquo;\u0026raquo;\u0026raquo;\u0026raquo;\u0026raquo;\u0026raquo;\u0026raquo;\u0026raquo;\u0026gt;高 低可以直接转高，但是高转低会出现溢出和丢精度的现象\n不能对boolean类型进行类型转换，（String不是基本数据类型，能进行拼接）\n高转低需要强制类型转换，显式写明要转换的类型\n当多种数据类型的数据混合运算时，Java首先会自动将所有的数据转换成优先级高的的那种数据类型，然后再进行计算\nchar byte short 三者计算时都会先转换为int型再进行运算。\n不需要显式强制转换的特例：由于整数默认类型是int，JVM会根据声明和char byte short 三者各自的数值范围把 int 值 自动强制转换成对应的类型，如果值超过范围还是需要显式地强制转换\n4.变量 类变量\n实例变量\n局部变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public class Person { //类变量： 需要关键词 static static int population = 1; //实例变量：从属于对象; 如果不初始化，会赋予默认值0, 0.0, false, null String name; int age; //mian方法 public static void main(String[] args) { //局部变量： 声明后必须初始化值,不然报错 /*int i; System.out.println(i);*/ int i; i=10; System.out.println(i); /* * 实例变量需要先创建一个对象 * 实例变量如果不复赋值则为默认值 */ /* * 创建对象 * 变量类型 变量名 = new 构造函数； */ Person person = new Person(); System.out.println(person.name); System.out.println(person.age); person = null; /* * 类变量的调用 * 类变量无需对象就可以调用 * 相当于c++中的静态成员,整个类共用一个 */ System.out.println(population); } } 4.1 变量命名规则 所有变量、方法、类名: 见名知意 类名 : 首字母 大写 和驼峰原则: Man, GoodMan 类成员变量、局部变量: 首字母 小写 和驼峰原则 : monthSalary 常量 : 大写字母和下划线 : MAX_VALUE 方法名 : 首字母小写和驼峰原则 : run(), runRun0 枚举类型里的枚举常量的名称应使用全大写字母，且不能包含空格、标点符号和其他符号。 5.关键字 在Java中目前一共有53个关键字：\n48个关键字：abstract、assert、boolean、break、byte、case、catch、char、class、continue、default、do、double、else、enum、extends、final、finally、float、for、if、implements、import、int、interface、instanceof、long、native、new、package、private、protected、public、return、short、static、strictfp、super、switch、synchronized、this、throw、throws、transient、try、void、volatile、while\n3个特殊直接量：true、false、null\n2个保留字：goto、const\n几个不常用的关键字：\nassert : 断言（在异常这一章用）。它用于在程序执行时验证某些条件是否满足。如果条件成立，则程序继续执行；否则程序抛出异常或直接终止。\nenum：枚举类。Java5之前，发挥类似作用的是final class。但是enum更方便。enum枚举类存储着枚举值的索引、名称、所有枚举值等重要信息，并且可以将每一个枚举值视为一个对象，进行自定义扩展属性和方法。\n枚举类型的定义使用关键字“enum”，在定义中列出所有的枚举常量。每个枚举常量都是该枚举类型的实例，它们被分配了默认的名称 枚举类型的实例可以通过名称或序号来访问。 枚举类型的名称应该使用大写字母，以便与其他类和变量区分开来。枚举常量的名称也应该使用大写字母，且不能包含空格、标点符号和其他符号。 strictfp ： 用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范\ntransient ：声明不用序列化的成员域\nsynchronized ： 表明一段代码需要同步执行\nvolatile ： 表明两个或者多个变量必须同步地发生变化\nnative : 用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的\n","date":"2023-11-24T22:27:20+08:00","image":"https://4evergreat.github.io/cover/85b4b7adc8a3227a66565b22bf63231c.jpg","permalink":"https://4evergreat.github.io/2023/java-blog-3/","title":"Java-blog-3java注释、基本数据类型、类型转换、变量、命名规则和关键字"},{"content":"1. 位运算 1 2 3 4 5 6 7 8 9 10 11 12 /* A = 0011 1100; * B = 0000 1101; * ---------------------------------- * 与： * A\u0026amp;B = 0000 1100;//都为1的才是1 * 或： * A|B = 0011 1101;//有1的就是1 * 异或： * A^B = 0011 0001;//只有一个1的才是1 * 非： * ~A = 1100 0011;//所有位取反 */ 1 2 3 4 5 //\t\u0026lt;\u0026lt; : a\u0026lt;\u0026lt;n, a（转二进制后）左移n位 相当于乘了2^n System.out.println(\u0026#34;2*8 = 2\u0026lt;\u0026lt;3 = \u0026#34; + (2\u0026lt;\u0026lt;3));//16 //\t\u0026gt;\u0026gt; ：a\u0026gt;\u0026gt;n, a（转二进制后）右移n位 相当于除了2^n System.out.println(\u0026#34;24/8 = 24\u0026gt;\u0026gt;3 =\u0026#34; + (24\u0026gt;\u0026gt;3));//8 2. 优先级 算术运算符：+，-，*，/，%，++，\u0026ndash;\n赋值运算符：=\n扩展后的赋值运算符：+=，-=，*=，/=，%=，\u0026amp;=，|=，^=，\u0026laquo;=，\u0026raquo;=，\u0026raquo;\u0026gt;=\n关系比较运算符：\u0026gt;，\u0026gt;=，\u0026lt;，\u0026lt;=，==\n逻辑运算符：\u0026amp;\u0026amp;，\u0026amp;，||，|，！，^\n位运算符：\u0026amp;，|，~，^，\u0026laquo;，\u0026raquo;，\u0026raquo;\u0026gt;\n​\t- \u0026raquo;\u0026gt;(无符号右移运算符)和 \u0026raquo; 的区别在于: \u0026raquo;\u0026gt; 负数高位补 0；\u0026raquo; 负数高位补1；\n三目运算符：? :\n​\t- (expression) ? if-true-statement : if-false-statement;\n2.1逻辑与或非优先级： 逻辑非\u0026gt;逻辑与\u0026gt;逻辑或 2.2 符号优先级表 优先级 运算符名字 说明 类 结合性 其他说明 1 () [] . {} 括号，方括号，点， 集合 分隔符 从左往右 2 ！+（正）-（负）~ ++ \u0026ndash; 逻辑非，正号，负号，按位取反，自增，自减 一元运算符 从右往左 3 (type) 强制类型转换运算符 无 本质是()提出来的优先级 4 * / % 乘，除， 取余 二元运算符 从左往右 5 + - 加，减 二元运算符 从左往右 6 \u0026laquo; \u0026raquo; \u0026raquo;\u0026gt; 左移，右移，无符号右移 位移运算符 从左往右 a\u0026raquo;b, a (转二进制后)右移b位 7 \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= instanceof 小于，小于等于，大于，大于等于，类属 关系运算符 从左往右 8 == != 等价于，不等于 等价运算符（关系运算符） 从左往右 9 \u0026amp; | ^ 按位与，按位或，按位异或 位逻辑运算符 从左往右 按位与\u0026gt;按位异或\u0026gt;按位或 10 \u0026amp;\u0026amp; || 逻辑与，逻辑或 逻辑运算符 从左往右 逻辑与\u0026gt;逻辑或 11 ? : (expression) ? if-true-statement : if-false-statement； 三目运算符 从左往右 12 = += -= *= /= 赋值运算符 从右往左 12 \u0026amp;= |= ^= %= \u0026laquo;= \u0026raquo;= \u0026raquo;\u0026gt;= 赋值运算符 从右往左 下图来源\n2.3 \u0026amp;与\u0026amp;\u0026amp;，|与||的异同 \u0026amp;与\u0026amp;\u0026amp;\n相同点：都需要两边为true结果才是true 不同点：\u0026amp;是位逻辑运算，即使左边为false，右侧照样执行。但是\u0026amp;\u0026amp;如果左边为false，将直接忽略右侧，有人把这种性质称为短路，（短路与）。 |与||\n相同点：有一边为true结果就是true\n不同点：\u0026amp;是位逻辑运算，即使左边为true，右侧照样执行。但是\u0026amp;\u0026amp;如果左边为true，将直接忽略右侧，（短路或）。\n","date":"2023-11-24T22:27:20+08:00","image":"https://4evergreat.github.io/cover/0170df5f081104a801215aa0ad6ddd.jpg@1280w_1l_2o_100sh.jpg","permalink":"https://4evergreat.github.io/2023/java-blog-4/","title":"Java-blog-4java运算符"},{"content":"typora基本语法 1.层级标题： 1 格式：# + space + 自定义字符 ​\t其中#号的数量代表了标题的层级，单个#为最大的标题。“#” 号与自定义标题字符之间有个空格！！\n效果演示：\n1 2 #### 我是标题 ##### 我是小一级的标题 我是标题 我是小一级的标题 2.字体 1 2 3 4 5 粗体格式： ** + 字体 + ** 斜体格式： * + 字体 + * 中间删除线格式： ~~ + 字体+ ~~ 效果演示：\n1 2 3 **我是一段粗体文字** *我是一段斜体文字* ~~我是一段带删除线的文字~~ 我是一段粗体文字 我是一段斜体文字 我是一段带删除线的文字\n3.引用 1 引用格式： \u0026gt; + 段落 效果演示：\n1 \u0026gt; 这是一个用于显示引用效果的句子 这是一个用于显示引用效果的句子\n4.分割线 1 2 分割线格式1： --- 分割线格式2： *** 演示效果：\n5.插入图片 1 插入图片的格式： ![图片名称](图片路径) 图片路径可以是本地路径，也可以是图片的网络链接。图片名称为自定义的新标签，可以与路径中图片的名字不一样。\n演示效果：\n1 ![蜡笔小新](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201905%2F29%2F20190529213011_dttcv.thumb.400_0.jpeg\u0026amp;refer=http%3A%2F%2Fb-ssl.duitang.com\u0026amp;app=2002\u0026amp;size=f9999,10000\u0026amp;q=a80\u0026amp;n=0\u0026amp;g=0n\u0026amp;fmt=auto?sec=1703259985\u0026amp;t=acb8150462356310d36fde4ad513218c) 本地图片加载出问题的解决方案：\n​\t1.文件=\u0026gt;偏好设置 =\u0026gt; 图像 勾选优先使用相对路径\n​\t2.检测文件图片是否放到了压缩包里面\n网络图片加载出问题的解决方案：\n​\t暂时没找到解决方案。可能是图片源丢失，建议把图片转存到自己的服务器或者本地。\n6.超链接 1 超链接格式： [超链接名字](链接地址) 演示效果：\n1 [我的博客](https://www.cnblogs.com/wendao101) 我的博客\nTypora 点击超链接后会展出链接名字，但没有跳转网页，这是该软件不支持。\n7.列表 1 有序列表 无标准格式 enter 后会自动按格式排列 像word 一样, 按ENTER 后序号自动补全，删除中间的部分，序号自动变化\n演示效果\n1 2 3 4 5 6 7 8 9 有序列表示例 1. A + ENTER 2. B + ENTER 3. 无序列表示例 - space A - space B - space A B A B 8.表格 1 2 3 4 表格格式： | 属性1 | 属性2 | 属性3| | -- | —— | -- | //中间的横线 | 值1 | 值2 | 值3 | 竖线代表列 ，\u0026ndash; 代表横 ，两者需要对其， 而且整个表格的命令代码需要放在同一个代码块内才会自动识别成一个表格。\n效果演示：\n1 2 3 | 姓名 | 性别 | 民族| | -- | —— | -- | | 问稻 | 男 | 汉 | 姓名 性别 民族 问稻 男 汉 遇到的问题：\n​\t直接用源代码编写，typora 容易出现不对齐、不编译、多个表格等问题，建议直接用右键创建表格，用\t法与在word中插入表格类似。\n9.代码块 1 代码块调用格式: ``` + 语言名称 其中`是TAB上方那个键 演示效果：\n1 2 3 4 5 6 #include\u0026lt;iostream\u0026gt; using namespace std; int main (viod){ cout\u0026lt;\u0026lt; \u0026#34;Hello Word!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } ","date":"2023-11-24T22:27:20+08:00","image":"https://4evergreat.github.io/cover/01a3015d9a83a2a801211d537434e4.jpg@2o.jpg","permalink":"https://4evergreat.github.io/2023/typora-blog-1/","title":"typora-blog-1typora基本语法"},{"content":"常见的Terminal命令： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 # 盘符切换： 直接输入盘符，不区分大小写 直接输入 E: 等 # 查看当前目录下的所有文件：dir # 切换目录： cd newdirectory 只返回目标路径但不会跳转 cd \\d newdirectory 跨盘符切换的话要加\\d参数后才会切换到目标路径， Linux 用 cd [路径] 即可切换到目标路径 cd .. 切换到上一级目录 cd ./ 切换代当前目录（原地） cd \\d C:\\Windows\\System32 # 查看当前路径内的所有文件： dir Linux是ls ： 只写ls，默认查看当前工作目录的所有文件夹(不含隐藏文件夹),也可加以下一个或多个参数： -a，即-all，所有的意思，表示查看当前目录所有文件夹(包含隐藏的文件夹)，这些隐藏文件夹主要是以 . 开头的文件夹和默认隐藏的文件夹 -l 表示以竖向形式展示内容，并展示更多的信息 -h，是展示出所有文件的大小，如KB，MB，GB，如果不展示则为Byte # 査看当前所在目录的命令: pwd # 清理屏幕： c1s clear screen的缩写 # 退出终端： exit # 查看电脑的ip：ipconfig 如果没识别，需要添加PATH C:\\Windows\\System32 # 打开常见的应用： calc ：计算器 mspaint ： 画图软件 notepad ： notepad记事本 # ping 命令 ping www.baidu .com # 文件操作 md [目录名] ： 当前路径下创建目标文件夹; Linux是mkdir [文件夹] rd [目录名] ： 移除当前路径下的目标文件夹，直接使用 rd 只能删除空目录，如果要删除的目录有子目录或\t文件，就必须使用 /s 选项\tLinux是rm -r [文件夹], 其中 -r：递归删除目录及其子目录下的所有文件 cd\u0026gt;[文件名] ： 在当前路径下创建目标文件; Linux是touch [文件名] 或者 vim [文件名] del [文件名] ：在当前路径下删除目标文件 Linux是rm -f [文件名], 其中 -f：强制删除文件，不提示确认信息 ","date":"2023-11-24T22:27:20+08:00","image":"https://4evergreat.github.io/cover/01cf6858635528a8012060c8b33f77.jpg@2o.jpg","permalink":"https://4evergreat.github.io/2023/win-blog-1/","title":"win-blog-1常见的Terminal命令"},{"content":"多实例安装mysql 5.6.50 1. 卸载旧软件、关防火墙、安装依赖 卸载旧软件 1 2 3 4 5 6 7 [root@localhost local]# rpm -qa | grep mysql [root@localhost local]# rpm -qa | grep mariadb mariadb-libs-5.5.56-2.el7.x86_64 [root@localhost local]# yum -y remove mariadb-libs.x86_64 autoconf 设置防火墙 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [root@localhost agr]# vim /etc/selinux/config #This file controls the state of SELinux on the system. #SELINUX= can take one of these three values: # enforcing - SELinux security policy is enforced. # permissive - SELinux prints warnings instead of enforcing. # disabled - No SELinux policy is loaded. SELINUX=permissive #SELINUXTYPE= can take one of three values: # targeted - Targeted processes are protected, # minimum - Modification of targeted policy. Only selected processes are protected. # mls - Multi Level Security protection. SELINUXTYPE=targeted [root@localhost agr]# shutdown -r now #重启 [root@localhost agr]# getenforce Permissive 安装依赖 1 [root@localhost agr]# yum install libaio 2.下载二进制格式的mysql 1 [root@localhost agr]# wget https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-5.6/mysql-5.6.50-linux-glibc2.12-x86_64.tar.gz 3.解压文件，设置软连接 1 2 3 4 5 6 7 8 9 10 [root@localhost agr]# cd /usr/local [root@localhost agr]# tar -zxvf mysql-5.6/mysql-5.6.50-linux-glibc2.12-x86_64.tar.gz [root@localhost agr]# ls /usr/local/ bin games lib libexec sbin src etc include lib64 mysql-5.6/mysql-5.6.50-linux-glibc2.12-x86_64.tar.gz share [root@localhost agr]# cd /usr/local/ 软连接 1 [root@localhost local]# ln -sv mysql-5.7.38-linux-glibc2.12-x86_64 mysql 4.创建MySQL用户 1 2 3 4 5 [root@localhost agr]# useradd -M -r -s /sbin/nologin mysql #/sbin/nologin是不允许登录 [root@localhost agr]# id mysql uid=995(mysql) gid=992(mysql) groups=992(mysql) 登录用户显示bash-4.2的解决方法 1 [root@localhost agr]cp -r/etc/skel/.bash* /home/mysql “This account is currently not available”的解决方法 1 2 3 4 5 [root@localhost agr] vim /etc/passwd #“/sbin /nologin”改成“/bin/bash” [root@localhost agr] cat /etc/passwd ... mysql:x:987:980::/home/mysql:/bin/bash 5.多用户文件夹 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 [root@localhost agr]# yum install -y tree [root@localhost agr]# mkdir -p /mysql/{3306,3307,3308}/{data,my.cnf} [root@localhost agr]# vim /mysql/3307/my.cnf [mysql] [client] port=3307 socket=/mysql/3307/temp/mysql_3307.sock [mysqld] user=mysql port=3307 socket=/mysql/3307/temp/mysql_3307.sock basedir=/usr/local/mysql/ datadir=/mysql/3307/data innodb_buffer_pool_size=128M #缓存InnoDB的容量 character-set-server=utf8 log-bin=/mysql/3307/log/mysql-bin server-id = 3 [mysqld_safe] log-error=/mysql/3307/log/mysql_3307_error.log pid-file=/mysql/3307/mysqld_3307.pid 验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 [root@localhost 3307]# cat my.cnf [mysql] [client] port=3307 socket=/mysql/3307/temp/mysql_3307.sock [mysqld] user=mysql port=3307 socket=/mysql/3307/temp/mysql_3307.sock basedir=/usr/local/mysql/ datadir=/mysql/3307/data innodb_buffer_pool_size=128M #缓存InnoDB的容量 character-set-server=utf8 log-bin=/mysql/3307/log/mysql-bin server-id = 3 [mysqld_safe] log-error=/mysql/3307/log/mysql_3307_error.log pid-file=/mysql/3307/mysqld_3307.pid [root@localhost 3307]# 6.修改文件权限 1 2 3 4 5 6 7 8 [root@localhost agr]# chown -R mysql.mysql /mysql/ [root@localhost agr]# ls -l /mysql total 0 drwxr-xr-x. 3 mysql mysql 32 2月 26 15:48 3306 drwxr-xr-x. 3 mysql mysql 32 2月 26 15:50 3307 drwxr-xr-x. 3 mysql mysql 32 2月 26 15:50 3308 7.添加环境变量 1 2 3 4 5 6 [root@localhost 3307]# mysql ERROR 2002 (HY000): Can\u0026#39;t connect to local MySQL server through socket \u0026#39;/tmp/mysql.sock\u0026#39; (2) [root@localhost agr]# vim /etc/profile #文件最后添加 export PATH=/usr/local/mysql/bin/:$PATH 刷新缓存 1 [root@localhost agr]# source /etc/profile 验证 1 2 [root@localhost 3307]# which mysql /usr/local/mysql/bin/mysql 方式二 1 2 [root@localhost 3307]#tail -1 /etc/profile export PATH=/usr/local/mysql/bin/:$PATH 8.配置启动脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 [root@localhost 3306]# cat mysql_3307 [mysqld] port=3307 mysql_user=\u0026#34;mysql\u0026#34; CmdPath=\u0026#34;/usr/local/mysql/bin\u0026#34; mysql_sock=\u0026#34;/mysql/${port}/temp/mysql_${port}.sock\u0026#34; mysqld_pid_file_path=/mysql/${port}/mysqld_${port}.pid function_start_mysql() { if [ ! -e \u0026#34;$mysql_sock\u0026#34; ]; then printf \u0026#34;Starting MySQL... \\n\u0026#34; /bin/sh ${CmdPath}/mysqld_safe --defaults-file=/mysql/${port}/my.cnf --pid-file=$mysqld_pid_file_path 2\u0026gt;\u0026amp;1 \u0026gt;/dev/null \u0026amp; sleep 3 else printf \u0026#34;MySQL is running...\\n\u0026#34; exit 1 fi } function_stop_mysql() { if [ ! -e \u0026#34;$mysql_sock\u0026#34; ]; then printf \u0026#34;MySQL is stopped ...\\n\u0026#34; exit 1 else printf \u0026#34;Stoping MYSQL ...\\n\u0026#34; mysqld_pid = \u0026#39;cat \u0026#34;mysqld_pid_file_path\u0026#34;\u0026#39; if(kill -0 $mysqld_pid 2\u0026gt;/dev/null) then kill $mysqld_pid sleep 2 fi fi } function_restart_mysql() { printf \u0026#34;Restarting MySQL...\\n\u0026#34; function_stop_mysql sleep 2 function_start_mysql } case \u0026#34;$1\u0026#34; in start) function_start_mysql ;; stop) function_stop_mysql ;; restart) function_restart_mysql ;; *) printf \u0026#34;Usage: /mysql/${port}/mysql{start|stop|restart}\\n\u0026#34; esac 赋予执行权限 1 chmod +x /mysql/3307/mysql_3307 降低文件夹权限 1 2 3 4 5 6 7 chown -R mysql.mysql /mysql/ [root@localhost profile.d]# /usr/local/mysql/scripts/mysql_install_db --basedir=/usr/local/mysql --datadir=/mysql/3306/data --user=mysql [root@youxi1 mysql]# cp support-files/mysql.server /etc/init.d/mysqld [root@youxi1 mysql]# chmod +x /etc/init.d/mysqld 9.初始化 1 [root@localhost 3307]# /usr/local/mysql/scripts/mysql_install_db --defaults-file=/mysql/3307/my.cnf --basedir=/usr/local/mysql/ --datadir=/mysql/3307/data/ --user=mysql 验证及sock登录 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [root@localhost 3308]# netstat -tunlp|grep mysql tcp6 0 0 :::3307 :::* LISTEN 4189/mysqld tcp6 0 0 :::3308 :::* LISTEN 4569/mysqld [root@localhost 3308]# mysql -S /mysql/3307/temp/mysql_3307.sock Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 1 Server version: 5.6.50-log MySQL Community Server (GPL) Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type \u0026#39;help;\u0026#39; or \u0026#39;\\h\u0026#39; for help. Type \u0026#39;\\c\u0026#39; to clear the current input statement. mysql\u0026gt; ","date":"2022-03-11T23:30:20+08:00","image":"https://4evergreat.github.io/cover/1005sa133rcv63bao0472.jpg","permalink":"https://4evergreat.github.io/2022/mysql02/","title":"mysql-blog-2多实例安装mysql 5.6.50"},{"content":"登录方式： sock登录 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #需要先在localhost才可以使用此种方式登录，需要直接调用sock文件 [root@localhost agr]# mysql -S /mysql/3307/temp/mysql_3307.sock Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 4 Server version: 5.6.50-log MySQL Community Server (GPL) Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type \u0026#39;help;\u0026#39; or \u0026#39;\\h\u0026#39; for help. Type \u0026#39;\\c\u0026#39; to clear the current input statement. mysql\u0026gt; #一般需要加入 -p 参数输入密码 [root@localhost agr]# mysql -p -S /mysql/3307/temp/mysql_3307.sock 添加用户及修改密码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 mysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | test | +--------------------+ 4 rows in set (0.00 sec) mysql\u0026gt; use mysql; Database changed mysql\u0026gt; select user,host,password from user; +------+-----------------------+----------+ | user | host | password | +------+-----------------------+----------+ | root | localhost | | | root | localhost.localdomain | | | root | 127.0.0.1 | | | root | ::1 | | | | localhost | | | | localhost.localdomain | | +------+-----------------------+----------+ 6 rows in set (0.00 sec) mysql\u0026gt; 修改密码的方式 方式一 用SET PASSWORD命令 1 2 3 格式：mysql\u0026gt; set password for 用户名@‘localhost’ = password(\u0026#39;新密码\u0026#39;); 例子：mysql\u0026gt; set password for root@‘localhost’ = password(\u0026#39;1234\u0026#39;); 方式二 用mysqladmin 1 2 3 4 格式：mysqladmin -u用户名 -p旧密码 password 新密码 [root@localhost agr]# mysqladmin -uroot -p -P 3307 password 1234 Enter password: 方式三 用UPDATE 直接编辑表user 1 2 3 4 5 mysql\u0026gt; use mysql; mysql\u0026gt; update user set password=password(\u0026#39;123\u0026#39;) where user=\u0026#39;root\u0026#39; and host=\u0026#39;localhost\u0026#39;; mysql\u0026gt; flush privileges; 忘记密码的越过密码登录的操作 检查mysql服务是否启动，如果启动，关闭mysql服务 1 2 3 4 5 6 7 8 #检查是否已经启动 [root@localhost agr]# netstat -tunlp|grep mysql tcp6 0 0 :::3307 :::* LISTEN 4189/mysqld tcp6 0 0 :::3308 :::* LISTEN 4569/mysqld #关闭服务 [root@localhost agr]# /mysql/3307/mysql_3307 stop 修改my.cnf文件 在/etc/my.cnf， 中插入以下两行代码\n1 2 3 4 5 6 7 [mysqld] skip-grant-tables [root@localhost agr]# vim /etc/my.cnf [mysqld] skip-grant-tables 免密码登录数据库并采用上一步中的操作修改密码 创建数据库，插入数据表 创建数据库格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name [create_option] ... create_option: [DEFAULT] { CHARACTER SET [=] charset_name | COLLATE [=] collation_name } mysql\u0026gt; CREATE DATABASE IF NOT EXISTS lol -\u0026gt; DEFAULT CHARACTER SET utf8 -\u0026gt; DEFAULT COLLATE utf8_general_ci; #有些版本是utf8_chinese_ci; ### 验证 mysql\u0026gt; show create database lol; +----------+--------------------------------------------------------------+ | Database | Create Database | +----------+--------------------------------------------------------------+ | lol | CREATE DATABASE `lol` /*!40100 DEFAULT CHARACTER SET utf8 */ | +----------+--------------------------------------------------------------+ 1 row in set (0.00 sec) 插入数据表 1 2 3 4 5 6 7 8 mysql\u0026gt; create table if not exists tanks( -\u0026gt; id int, -\u0026gt; name varchar(100) not null, -\u0026gt; skills varchar(255) not null, -\u0026gt; price int not null, -\u0026gt; primary key(id) -\u0026gt; ) engine=InnoDB DEFAULT CHARSET = utf8; Query OK, 0 rows affected (0.01 sec) 验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 mysql\u0026gt; show create table tanks; +-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | Table | Create Table | +-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | tanks | CREATE TABLE `tanks` ( `id` int(11) NOT NULL DEFAULT \u0026#39;0\u0026#39;, `name` varchar(100) NOT NULL, `skills` varchar(255) NOT NULL, `price` int(11) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 | +-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ mysql\u0026gt; desc tanks; +--------+--------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+--------------+------+-----+---------+-------+ | id | int(11) | NO | PRI | 0 | | | name | varchar(100) | NO | | NULL | | | skills | varchar(255) | NO | | NULL | | | price | int(11) | NO | | NULL | | +--------+--------------+------+-----+---------+-------+ 4 rows in set (0.01 sec) 往数据标中写入数据 1 mysql\u0026gt; insert into tanks(id,name,skills,price) values(1,\u0026#39;程咬金\u0026#39;,\u0026#39;大招回血，血量越低，伤害越高\u0026#39;，8888）,(2,\u0026#39;庄周\u0026#39;,\u0026#39;大招解除控制，为队友添加护盾\u0026#39;,2888); 验证 1 2 3 4 5 6 7 8 mysql\u0026gt; select * from tanks; +----+-----------+------------------------------------------+-------+ | id | name | skills | price | +----+-----------+------------------------------------------+-------+ | 1 | 程咬金 | 大招回血,血量越低,伤害越高 | 8888 | | 2 | 庄周 | 大招解除控制,为队友添加护盾 | 2888 | +----+-----------+------------------------------------------+-------+ 2 rows in set (0.00 sec) 修改数据表 增 添加数据表字段 1 mysql\u0026gt; alter table [表名] add [字段名] [字段数据类型（长度）] 额外的字段属性； 添加指定位置的字段 1 mysql\u0026gt; alter table [表名] add [字段名] after [字段名]； 添加多个字段 1 2 3 4 mysql\u0026gt; alter table [表名] add [字段名1、类型1] ， add [字段名2、类型2] ； #特殊例子，指定位置插入多个字段 mysql\u0026gt; alter table [表名] add [字段名1、类型1] after [字段a]， add [字段名2、类型2] after [字段b]； 删 删除数据表 1 drop table [表名]； 删除table中的字段 1 mysql\u0026gt; alter table [表名] drop [字段名]； 删除数据表的内容 方式一 delete语句 1 mysql\u0026gt; delete from [数据表]；#由于delete会保留id(key)序号，清空语句执行后，id(key)自增属性丢失 id(key)自增属性丢失解决方法：添加自增属性 1 2 3 #modify语句，可以修改字段数据类型、额外属性（在此用到的功能二） mysql\u0026gt; alter table tanks modify id int(11) auto_increment; #auto_increment id自增 带条件删除表中指定内容 1 2 3 4 5 6 7 #delete是一行一行地删除，对大容量表删除很慢。但是delete会保留序号 举个例子，删除含（1、2、3）的所有内容后，再次插入数据将从4开始（已添加增属性） #用where语句判断 mysql\u0026gt; delete from [表名] where [条件a?b]； #delete from tanks where id=3; 删了3，之后id=4的不会变成3 方式二 tuncate语句 1 2 3 #原理：重新创建一个新的数据表，完全抛弃原有内容 mysql\u0026gt;truncket table [表名]; 改 修改数据表名字 方式一 rename 1 mysql\u0026gt; rename table [旧名字] to [新名字]； 方式二 alter 1 mysql\u0026gt; alter table [旧的表名] rename to [新名字]； 修改表字段的数据类型 1 mysql\u0026gt; alter table [表名] change [旧字段名] [新字段名] [新数据类型] ； 改表中数据 update语句 1 2 3 mysql\u0026gt; update [数据库].[表名] set [修改字段=b] where [定位条件a?b];#若无精准定位条件，将会把其他数据行也修改 mysql\u0026gt; update [数据库].[表名] set [修改字段1=b]，[修改字段2=c] where [定位条件a?b];#同时改多个字段 查 查询表的全部内容 ，用 * 1 mysql\u0026gt; select * from [表名]； 查询表的某些字段 ，填入字段名 1 mysql\u0026gt; select [字段名]，[字段名] from [表名]； 查询符合条件的：where 语句 1 2 3 mysql\u0026gt; select [字段名]，[字段名] from [表名] where [条件a?b]; mysql\u0026gt; select [字段名]，[字段名] from [表名] where [条件a?b] and [条件c?d]; 限制结果查询的数量: limit 语句 1 2 mysql\u0026gt; select [字段名]，[字段名] from [表名] where [条件a?b] limit [起始位置][数量]； #不包含起始位置 索引 查看当前表的索引 1 2 3 4 5 6 7 mysql\u0026gt; show index from tanks \\G； +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | tanks | 0 | PRIMARY | 1 | id | A | 2 | NULL | NULL | | BTREE | | | +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 1 row in set (0.00 sec) 添加索引 1 2 3 4 5 mysql\u0026gt; alter table [表名] add index [要设置的索引名（字段名）]； mysql\u0026gt; alter table tanks add index name_index(name); Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 检查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 mysql\u0026gt; show index from tanks \\G; *************************** 1. row *************************** Table: tanks Non_unique: 0 Key_name: PRIMARY Seq_in_index: 1 Column_name: id Collation: A Cardinality: 2 Sub_part: NULL Packed: NULL Null: Index_type: BTREE Comment: Index_comment: *************************** 2. row *************************** Table: tanks Non_unique: 1 Key_name: name_index Seq_in_index: 1 Column_name: name Collation: A Cardinality: 2 Sub_part: NULL Packed: NULL Null: Index_type: BTREE Comment: Index_comment: 2 rows in set (0.00 sec) 删除索引 1 alter table [表名] drop index [索引名]； 排序 查询结果排序： order by语句 1 mysql\u0026gt; select [字段名1]，[字段名2]，[字段名3] from [表名] order by [字段名2]；#由按默认的字段（假设是1）排序改成按字段2排序 排序默认是升序asc,改成降序desc 1 mysql\u0026gt; select [字段名1]，[字段名2]，[字段名3] from [表名] order by [字段名2] desc; ","date":"2022-03-10T23:30:20+08:00","image":"https://4evergreat.github.io/cover/8599.jpg_wh860.jpg","permalink":"https://4evergreat.github.io/2022/mysql01/","title":"mysql-blog-1数据库常见操作"},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://4evergreat.github.io/1/","title":""},{"content":" 控制反转：Inversion of control 简称IOC\n对象的创建控制由程序自身转移到外部程序。spring容器或者IOC容器\n依赖注入：Dependecncy Injection 简称DI\n容器为程序提供 运行时的所以来的资源\nBean 对象： IOC容器中创建的、管理的对象称为bean\n","date":"0001-01-01T00:00:00Z","permalink":"https://4evergreat.github.io/1/","title":""},{"content":"1.代理 Java代理是一种设计模式，它允许在不改变原始类或接口的情况下对其进行增强或修改。在运行时通过创建一个代理对象来控制对原始对象的访问，并允许我们在访问原始对象之前或之后执行一些额外的逻辑，从而实现一些特定的功能，如日志记录、安全控制、缓存处理、远程调用、延迟加载和事务处理等。\n[代理](https://blog.csdn.net/x_xhuashui/article/details/129292297\n","date":"0001-01-01T00:00:00Z","permalink":"https://4evergreat.github.io/1/","title":""}]